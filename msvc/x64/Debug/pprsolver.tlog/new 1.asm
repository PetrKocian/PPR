; Listing generated by Microsoft (R) Optimizing Compiler Version 19.20.27508.1 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R0?AVruntime_error@std@@@8			; std::runtime_error `RTTI Type Descriptor'
PUBLIC	??_R2system_error@std@@8			; std::system_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@system_error@std@@8		; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	_TI4?AVsystem_error@std@@
PUBLIC	_CT??_R0?AVfilesystem_error@filesystem@std@@@8??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z136
PUBLIC	??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4runtime_error@std@@6B@			; std::runtime_error::`RTTI Complete Object Locator'
PUBLIC	??_R4_System_error_category@std@@6B@		; std::_System_error_category::`RTTI Complete Object Locator'
PUBLIC	??_7filesystem_error@filesystem@std@@6B@	; std::filesystem::filesystem_error::`vftable'
PUBLIC	??_R4_System_error@std@@6B@			; std::_System_error::`RTTI Complete Object Locator'
PUBLIC	??_R4_Generic_error_category@std@@6B@		; std::_Generic_error_category::`RTTI Complete Object Locator'
PUBLIC	??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7_Generic_error_category@std@@6B@		; std::_Generic_error_category::`vftable'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R0?AVerror_category@std@@@8			; std::error_category `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@runtime_error@std@@8		; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2_System_error@std@@8			; std::_System_error::`RTTI Base Class Array'
PUBLIC	??_R0?AVsystem_error@std@@@8			; std::system_error `RTTI Type Descriptor'
PUBLIC	??_R0?AV_System_error_category@std@@@8		; std::_System_error_category `RTTI Type Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R4system_error@std@@6B@			; std::system_error::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@_Generic_error_category@std@@8	; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3_System_error@std@@8			; std::_System_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV_Generic_error_category@std@@@8		; std::_Generic_error_category `RTTI Type Descriptor'
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_R2_System_error_category@std@@8		; std::_System_error_category::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	_CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
PUBLIC	_TI5?AVfilesystem_error@filesystem@std@@
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	?_Flag@?1???$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@1@XZ@4PEAXEA ; `std::_Immortalize<std::_Generic_error_category>'::`2'::_Flag
PUBLIC	??_R2error_category@std@@8			; std::error_category::`RTTI Base Class Array'
PUBLIC	_CTA4?AVsystem_error@std@@
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7runtime_error@std@@6B@			; std::runtime_error::`vftable'
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_7_System_error@std@@6B@			; std::_System_error::`vftable'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
PUBLIC	??_R2_Generic_error_category@std@@8		; std::_Generic_error_category::`RTTI Base Class Array'
PUBLIC	_CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R1A@?0A@EA@_System_error@std@@8		; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3error_category@std@@8			; std::error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3filesystem_error@filesystem@std@@8		; std::filesystem::filesystem_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	?_Flag@?1???$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@1@XZ@4PEAXEA ; `std::_Immortalize<std::_System_error_category>'::`2'::_Flag
PUBLIC	??_R3_System_error_category@std@@8		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVfilesystem_error@filesystem@std@@@8	; std::filesystem::filesystem_error `RTTI Type Descriptor'
PUBLIC	??_R2filesystem_error@filesystem@std@@8		; std::filesystem::filesystem_error::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	_CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
PUBLIC	??_R2runtime_error@std@@8			; std::runtime_error::`RTTI Base Class Array'
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7_System_error_category@std@@6B@		; std::_System_error_category::`vftable'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	_CTA5?AVfilesystem_error@filesystem@std@@
PUBLIC	??_R0?AV_System_error@std@@@8			; std::_System_error `RTTI Type Descriptor'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	??_R3system_error@std@@8			; std::system_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R1A@?0A@EA@filesystem_error@filesystem@std@@8 ; std::filesystem::filesystem_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@_System_error_category@std@@8	; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7system_error@std@@6B@			; std::system_error::`vftable'
PUBLIC	??_R3runtime_error@std@@8			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@error_category@std@@8		; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4filesystem_error@filesystem@std@@6B@	; std::filesystem::filesystem_error::`RTTI Complete Object Locator'
PUBLIC	??_C@_02LMMGGCAJ@?3?5@				; `string'
PUBLIC	??_C@_00CNPNBAHC@@				; `string'
PUBLIC	??_C@_07DCLBNMLN@generic@			; `string'
PUBLIC	??_C@_06FHFOAHML@system@			; `string'
PUBLIC	??_C@_0O@BFJCFAAK@unknown?5error@		; `string'
PUBLIC	??_C@_03NONCDIOG@?3?5?$CC@			; `string'
PUBLIC	??_C@_04PHMHGEMA@?$CC?0?5?$CC@			; `string'
PUBLIC	??_C@_09CKOOOICH@file_size@			; `string'
PUBLIC	??_C@_0BE@KGFJJEOF@File?5failed?5to?5open@	; `string'
PUBLIC	??_C@_09BCDLOFHA@?5us?5time?5@			; `string'
PUBLIC	??_C@_07IFFFBIED@?5time?3?5@			; `string'
PUBLIC	??_C@_0M@HIHLCHBM@?5only?5ints?5@		; `string'
PUBLIC	??_C@_0L@LFEILHLO@?5kurtosis?5@			; `string'
PUBLIC	??_C@_0M@FGOCKPMK@stats?5mean?5@		; `string'
PUBLIC	??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@		; `string'
PUBLIC	??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@	; `string'
EXTRN	__imp__get_stream_buffer_pointers:PROC
EXTRN	__imp__fseeki64:PROC
EXTRN	__std_fs_get_stats:PROC
EXTRN	__imp_fread:PROC
EXTRN	__std_fs_code_page:PROC
EXTRN	__imp_fsetpos:PROC
EXTRN	__imp_ungetc:PROC
EXTRN	__imp_setvbuf:PROC
EXTRN	__imp_fgetpos:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp__lock_file:PROC
EXTRN	__imp__unlock_file:PROC
EXTRN	__imp_terminate:PROC
EXTRN	__imp_fgetc:PROC
EXTRN	__imp_?_Syserror_map@std@@YAPEBDH@Z:PROC
EXTRN	__imp_?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z:PROC
EXTRN	__imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A:QWORD
EXTRN	__imp_?_Winerror_map@std@@YAHH@Z:PROC
EXTRN	__imp_?_Winerror_message@std@@YAKKPEADK@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?_Execute_once@std@@YAHAEAUonce_flag@1@P6AHPEAX1PEAPEAX@Z1@Z:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp__dtest:PROC
EXTRN	__std_fs_convert_wide_to_narrow:PROC
EXTRN	__std_fs_convert_narrow_to_wide:PROC
EXTRN	__imp_calloc:PROC
EXTRN	__imp_fputc:PROC
EXTRN	__imp__Mbrtowc:PROC
EXTRN	__imp_?_Getcvt@_Locinfo@std@@QEBA?AU_Cvtvec@@XZ:PROC
EXTRN	__imp_?_Getdays@_Locinfo@std@@QEBAPEBDXZ:PROC
EXTRN	__imp_?_Getmonths@_Locinfo@std@@QEBAPEBDXZ:PROC
EXTRN	__imp_?_W_Getdays@_Locinfo@std@@QEBAPEBGXZ:PROC
EXTRN	__imp_?_W_Getmonths@_Locinfo@std@@QEBAPEBGXZ:PROC
EXTRN	__imp_?always_noconv@codecvt_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_??7ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?fail@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_N@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z:PROC
EXTRN	__imp_?gcount@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_JXZ:PROC
EXTRN	__imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z:PROC
EXTRN	__imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z:PROC
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	__imp_?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z:PROC
EXTRN	__imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z:PROC
EXTRN	__imp_?_Pnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z:PROC
EXTRN	__imp_?_Gnavail@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBA_JXZ:PROC
EXTRN	__imp_?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z:PROC
EXTRN	__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ:PROC
EXTRN	__imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEAD1AEAPEAD@Z:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAPEAD0PEAH001@Z:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ:PROC
EXTRN	__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD0@Z:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
;	COMDAT ?_Flag@?1???$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@1@XZ@4PEAXEA
_BSS	SEGMENT
?_Flag@?1???$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@1@XZ@4PEAXEA DQ 01H DUP (?) ; `std::_Immortalize<std::_Generic_error_category>'::`2'::_Flag
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB DQ 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
_BSS	ENDS
;	COMDAT ?_Flag@?1???$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@1@XZ@4PEAXEA
_BSS	SEGMENT
?_Flag@?1???$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@1@XZ@4PEAXEA DQ 01H DUP (?) ; `std::_Immortalize<std::_System_error_category>'::`2'::_Flag
_BSS	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@ DB 'vector<T> too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@
CONST	SEGMENT
??_C@_1BK@MHIKGOKE@?$AA?3?$AAA?$AAM?$AA?3?$AAa?$AAm?$AA?3?$AAP?$AAM?$AA?3?$AAp?$AAm@ DB ':'
	DB	00H, 'A', 00H, 'M', 00H, ':', 00H, 'a', 00H, 'm', 00H, ':', 00H
	DB	'P', 00H, 'M', 00H, ':', 00H, 'p', 00H, 'm', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@
CONST	SEGMENT
??_C@_0N@LPFKKEBD@?3AM?3am?3PM?3pm@ DB ':AM:am:PM:pm', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FGOCKPMK@stats?5mean?5@
CONST	SEGMENT
??_C@_0M@FGOCKPMK@stats?5mean?5@ DB 'stats mean ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@LFEILHLO@?5kurtosis?5@
CONST	SEGMENT
??_C@_0L@LFEILHLO@?5kurtosis?5@ DB ' kurtosis ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HIHLCHBM@?5only?5ints?5@
CONST	SEGMENT
??_C@_0M@HIHLCHBM@?5only?5ints?5@ DB ' only ints ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_07IFFFBIED@?5time?3?5@
CONST	SEGMENT
??_C@_07IFFFBIED@?5time?3?5@ DB ' time: ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09BCDLOFHA@?5us?5time?5@
CONST	SEGMENT
??_C@_09BCDLOFHA@?5us?5time?5@ DB ' us time ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KGFJJEOF@File?5failed?5to?5open@
CONST	SEGMENT
??_C@_0BE@KGFJJEOF@File?5failed?5to?5open@ DB 'File failed to open', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_09CKOOOICH@file_size@
CONST	SEGMENT
??_C@_09CKOOOICH@file_size@ DB 'file_size', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PHMHGEMA@?$CC?0?5?$CC@
CONST	SEGMENT
??_C@_04PHMHGEMA@?$CC?0?5?$CC@ DB '", "', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03NONCDIOG@?3?5?$CC@
CONST	SEGMENT
??_C@_03NONCDIOG@?3?5?$CC@ DB ': "', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@BFJCFAAK@unknown?5error@
CONST	SEGMENT
??_C@_0O@BFJCFAAK@unknown?5error@ DB 'unknown error', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06FHFOAHML@system@
CONST	SEGMENT
??_C@_06FHFOAHML@system@ DB 'system', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07DCLBNMLN@generic@
CONST	SEGMENT
??_C@_07DCLBNMLN@generic@ DB 'generic', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@@
CONST	SEGMENT
??_C@_00CNPNBAHC@@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMMGGCAJ@?3?5@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_R4filesystem_error@filesystem@std@@6B@
rdata$r	SEGMENT
??_R4filesystem_error@filesystem@std@@6B@ DD 01H	; std::filesystem::filesystem_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVfilesystem_error@filesystem@std@@@8
	DD	imagerel ??_R3filesystem_error@filesystem@std@@8
	DD	imagerel ??_R4filesystem_error@filesystem@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@error_category@std@@8 DD imagerel ??_R0?AVerror_category@std@@@8 ; std::error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ios_base@std@@8
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3runtime_error@std@@8
rdata$r	SEGMENT
??_R3runtime_error@std@@8 DD 00H			; std::runtime_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_7system_error@std@@6B@
CONST	SEGMENT
??_7system_error@std@@6B@ DQ FLAT:??_R4system_error@std@@6B@ ; std::system_error::`vftable'
	DQ	FLAT:??_Esystem_error@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error_category@std@@8 DD imagerel ??_R0?AV_System_error_category@std@@@8 ; std::_System_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@filesystem_error@filesystem@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@filesystem_error@filesystem@std@@8 DD imagerel ??_R0?AVfilesystem_error@filesystem@std@@@8 ; std::filesystem::filesystem_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3filesystem_error@filesystem@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R3system_error@std@@8
rdata$r	SEGMENT
??_R3system_error@std@@8 DD 00H				; std::system_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error@std@@@8
data$r	SEGMENT
??_R0?AV_System_error@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_System_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_System_error@std@@', 00H
data$r	ENDS
;	COMDAT _CTA5?AVfilesystem_error@filesystem@std@@
xdata$x	SEGMENT
_CTA5?AVfilesystem_error@filesystem@std@@ DD 05H
	DD	imagerel _CT??_R0?AVfilesystem_error@filesystem@std@@@8??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z136
	DD	imagerel _CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
	DD	imagerel _CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
	DD	imagerel _CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD imagerel ??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7_System_error_category@std@@6B@
CONST	SEGMENT
??_7_System_error_category@std@@6B@ DQ FLAT:??_R4_System_error_category@std@@6B@ ; std::_System_error_category::`vftable'
	DQ	FLAT:??_E_System_error_category@std@@UEAAPEAXI@Z
	DQ	FLAT:?name@_System_error_category@std@@UEBAPEBDXZ
	DQ	FLAT:?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DQ	FLAT:?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2runtime_error@std@@8
rdata$r	SEGMENT
??_R2runtime_error@std@@8 DD imagerel ??_R1A@?0A@EA@runtime_error@std@@8 ; std::runtime_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT _CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
xdata$x	SEGMENT
_CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40 DD 00H
	DD	imagerel ??_R0?AV_System_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	imagerel ??0_System_error@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2filesystem_error@filesystem@std@@8
rdata$r	SEGMENT
??_R2filesystem_error@filesystem@std@@8 DD imagerel ??_R1A@?0A@EA@filesystem_error@filesystem@std@@8 ; std::filesystem::filesystem_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@system_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@_System_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@runtime_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AVfilesystem_error@filesystem@std@@@8
data$r	SEGMENT
??_R0?AVfilesystem_error@filesystem@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::filesystem::filesystem_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVfilesystem_error@filesystem@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3_System_error_category@std@@8
rdata$r	SEGMENT
??_R3_System_error_category@std@@8 DD 00H		; std::_System_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2_System_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3filesystem_error@filesystem@std@@8
rdata$r	SEGMENT
??_R3filesystem_error@filesystem@std@@8 DD 00H		; std::filesystem::filesystem_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	imagerel ??_R2filesystem_error@filesystem@std@@8
rdata$r	ENDS
;	COMDAT ??_R3error_category@std@@8
rdata$r	SEGMENT
??_R3error_category@std@@8 DD 00H			; std::error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_System_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_System_error@std@@8 DD imagerel ??_R0?AV_System_error@std@@@8 ; std::_System_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_System_error@std@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVruntime_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0runtime_error@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R2_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R2_Generic_error_category@std@@8 DD imagerel ??_R1A@?0A@EA@_Generic_error_category@std@@8 ; std::_Generic_error_category::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@error_category@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
	DD	0b0H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7_System_error@std@@6B@
CONST	SEGMENT
??_7_System_error@std@@6B@ DQ FLAT:??_R4_System_error@std@@6B@ ; std::_System_error::`vftable'
	DQ	FLAT:??_E_System_error@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_7runtime_error@std@@6B@
CONST	SEGMENT
??_7runtime_error@std@@6B@ DQ FLAT:??_R4runtime_error@std@@6B@ ; std::runtime_error::`vftable'
	DQ	FLAT:??_Eruntime_error@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	0b0H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT _CTA4?AVsystem_error@std@@
xdata$x	SEGMENT
_CTA4?AVsystem_error@std@@ DD 04H
	DD	imagerel _CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
	DD	imagerel _CT??_R0?AV_System_error@std@@@8??0_System_error@std@@QEAA@AEBV01@@Z40
	DD	imagerel _CT??_R0?AVruntime_error@std@@@8??0runtime_error@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT ??_R2error_category@std@@8
rdata$r	SEGMENT
??_R2error_category@std@@8 DD imagerel ??_R1A@?0A@EA@error_category@std@@8 ; std::error_category::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R3_Generic_error_category@std@@8 DD 00H		; std::_Generic_error_category::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT _TI5?AVfilesystem_error@filesystem@std@@
xdata$x	SEGMENT
_TI5?AVfilesystem_error@filesystem@std@@ DD 00H
	DD	imagerel ??1filesystem_error@filesystem@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA5?AVfilesystem_error@filesystem@std@@
xdata$x	ENDS
;	COMDAT _CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40
xdata$x	SEGMENT
_CT??_R0?AVsystem_error@std@@@8??0system_error@std@@QEAA@AEBV01@@Z40 DD 00H
	DD	imagerel ??_R0?AVsystem_error@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	028H
	DD	imagerel ??0system_error@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2_System_error_category@std@@8
rdata$r	SEGMENT
??_R2_System_error_category@std@@8 DD imagerel ??_R1A@?0A@EA@_System_error_category@std@@8 ; std::_System_error_category::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@error_category@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV_Generic_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_Generic_error_category@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_Generic_error_category `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_Generic_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3_System_error@std@@8
rdata$r	SEGMENT
??_R3_System_error@std@@8 DD 00H			; std::_System_error::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2_System_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
	DQ	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
	DQ	FLAT:?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
	DQ	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DQ	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DQ	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
	DQ	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@_Generic_error_category@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@_Generic_error_category@std@@8 DD imagerel ??_R0?AV_Generic_error_category@std@@@8 ; std::_Generic_error_category::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3_Generic_error_category@std@@8
rdata$r	ENDS
;	COMDAT ??_R4system_error@std@@6B@
rdata$r	SEGMENT
??_R4system_error@std@@6B@ DD 01H			; std::system_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVsystem_error@std@@@8
	DD	imagerel ??_R3system_error@std@@8
	DD	imagerel ??_R4system_error@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV_System_error_category@std@@@8
data$r	SEGMENT
??_R0?AV_System_error_category@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::_System_error_category `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV_System_error_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVsystem_error@std@@@8
data$r	SEGMENT
??_R0?AVsystem_error@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::system_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVsystem_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2_System_error@std@@8
rdata$r	SEGMENT
??_R2_System_error@std@@8 DD imagerel ??_R1A@?0A@EA@_System_error@std@@8 ; std::_System_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@runtime_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@runtime_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@runtime_error@std@@8 DD imagerel ??_R0?AVruntime_error@std@@@8 ; std::runtime_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3runtime_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVerror_category@std@@@8
data$r	SEGMENT
??_R0?AVerror_category@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::error_category `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVerror_category@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_7_Generic_error_category@std@@6B@
CONST	SEGMENT
??_7_Generic_error_category@std@@6B@ DQ FLAT:??_R4_Generic_error_category@std@@6B@ ; std::_Generic_error_category::`vftable'
	DQ	FLAT:??_E_Generic_error_category@std@@UEAAPEAXI@Z
	DQ	FLAT:?name@_Generic_error_category@std@@UEBAPEBDXZ
	DQ	FLAT:?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DQ	FLAT:?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
	DQ	FLAT:?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
CONST	ENDS
;	COMDAT ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	imagerel ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4_Generic_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_Generic_error_category@std@@6B@ DD 01H		; std::_Generic_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_Generic_error_category@std@@@8
	DD	imagerel ??_R3_Generic_error_category@std@@8
	DD	imagerel ??_R4_Generic_error_category@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R4_System_error@std@@6B@
rdata$r	SEGMENT
??_R4_System_error@std@@6B@ DD 01H			; std::_System_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_System_error@std@@@8
	DD	imagerel ??_R3_System_error@std@@8
	DD	imagerel ??_R4_System_error@std@@6B@
rdata$r	ENDS
;	COMDAT ??_7filesystem_error@filesystem@std@@6B@
CONST	SEGMENT
??_7filesystem_error@filesystem@std@@6B@ DQ FLAT:??_R4filesystem_error@filesystem@std@@6B@ ; std::filesystem::filesystem_error::`vftable'
	DQ	FLAT:??_Efilesystem_error@filesystem@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@filesystem_error@filesystem@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R4_System_error_category@std@@6B@
rdata$r	SEGMENT
??_R4_System_error_category@std@@6B@ DD 01H		; std::_System_error_category::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV_System_error_category@std@@@8
	DD	imagerel ??_R3_System_error_category@std@@8
	DD	imagerel ??_R4_System_error_category@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R4runtime_error@std@@6B@
rdata$r	SEGMENT
??_R4runtime_error@std@@6B@ DD 01H			; std::runtime_error::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVruntime_error@std@@@8
	DD	imagerel ??_R3runtime_error@std@@8
	DD	imagerel ??_R4runtime_error@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT _CT??_R0?AVfilesystem_error@filesystem@std@@@8??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z136
xdata$x	SEGMENT
_CT??_R0?AVfilesystem_error@filesystem@std@@@8??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z136 DD 00H
	DD	imagerel ??_R0?AVfilesystem_error@filesystem@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	088H
	DD	imagerel ??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z
xdata$x	ENDS
;	COMDAT _TI4?AVsystem_error@std@@
xdata$x	SEGMENT
_TI4?AVsystem_error@std@@ DD 00H
	DD	imagerel ??1system_error@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA4?AVsystem_error@std@@
xdata$x	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@system_error@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@system_error@std@@8 DD imagerel ??_R0?AVsystem_error@std@@@8 ; std::system_error::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3system_error@std@@8
rdata$r	ENDS
;	COMDAT ??_R2system_error@std@@8
rdata$r	SEGMENT
??_R2system_error@std@@8 DD imagerel ??_R1A@?0A@EA@system_error@std@@8 ; std::system_error::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@_System_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@runtime_error@std@@8
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AVruntime_error@std@@@8
data$r	SEGMENT
??_R0?AVruntime_error@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::runtime_error `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVruntime_error@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
PUBLIC	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??$_Zero_range@PEAD@std@@YAPEADQEAD0@Z		; std::_Zero_range<char *>
PUBLIC	??$_Seek_wrapped@N@std@@YAXAEAPEANQEAN@Z	; std::_Seek_wrapped<double>
PUBLIC	??$_Copy_memmove@PEANPEAN@std@@YAPEANPEAN00@Z	; std::_Copy_memmove<double *,double *>
PUBLIC	??$_Get_unwrapped_n@N_J$0A@@std@@YAPEANQEAN_J@Z	; std::_Get_unwrapped_n<double,__int64,0>
PUBLIC	??$_Get_unwrapped@N@std@@YAPEANQEAN@Z		; std::_Get_unwrapped<double>
PUBLIC	??$_Uninitialized_value_construct_n1@PEAD_KV?$allocator@D@std@@@std@@YAPEADPEAD_KAEAV?$allocator@D@0@U?$integral_constant@_N$00@0@@Z ; std::_Uninitialized_value_construct_n1<char *,unsigned __int64,std::allocator<char> >
PUBLIC	??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?__autoclassinit2@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ; std::basic_string_view<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$_Get_size_of_n@$07@std@@YA_K_K@Z		; std::_Get_size_of_n<8>
PUBLIC	??$_Idl_distance@PEANPEAN@std@@YA_JAEBQEAN0@Z	; std::_Idl_distance<double *,double *>
PUBLIC	??$_Uninitialized_move@PEANPEANV?$allocator@N@std@@@std@@YAPEANQEAN0PEANAEAV?$allocator@N@0@@Z ; std::_Uninitialized_move<double *,double *,std::allocator<double> >
PUBLIC	??$_Uninitialized_value_construct_n@PEAD_KV?$allocator@D@std@@@std@@YAPEADPEAD_KAEAV?$allocator@D@0@@Z ; std::_Uninitialized_value_construct_n<char *,unsigned __int64,std::allocator<char> >
PUBLIC	??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z	; std::forward<wchar_t * const &>
PUBLIC	??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ; std::forward<std::allocator<wchar_t> >
PUBLIC	??$forward@V?$allocator@N@std@@@std@@YA$$QEAV?$allocator@N@0@AEAV10@@Z ; std::forward<std::allocator<double> >
PUBLIC	??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const &>
PUBLIC	??$_Stringoid_from_Source@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::filesystem::_Stringoid_from_Source<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z ; std::filesystem::_Convert_Source_to_wide<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::filesystem::_Normal_conversion>
PUBLIC	??$append@V?$basic_string_view@DU?$char_traits@D@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append<std::basic_string_view<char,std::char_traits<char> >,void>
PUBLIC	??$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z ; std::filesystem::_Convert_wide_to<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Immortalize_impl@V_System_error_category@std@@@std@@YAHPEAX0PEAPEAX@Z ; std::_Immortalize_impl<std::_System_error_category>
PUBLIC	??$_Immortalize_impl@V_Generic_error_category@std@@@std@@YAHPEAX0PEAPEAX@Z ; std::_Immortalize_impl<std::_Generic_error_category>
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QEBAAEBV?$allocator@N@2@XZ ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_first
PUBLIC	?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEBAAEBV?$allocator@D@2@XZ ; std::vector<char,std::allocator<char> >::_Getal
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
PUBLIC	?capacity@?$vector@NV?$allocator@N@std@@@std@@QEBA_KXZ ; std::vector<double,std::allocator<double> >::capacity
PUBLIC	?_Umove_if_noexcept1@?$vector@NV?$allocator@N@std@@@std@@AEAAXPEAN00U?$integral_constant@_N$00@2@@Z ; std::vector<double,std::allocator<double> >::_Umove_if_noexcept1
PUBLIC	?_Getal@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBV?$allocator@N@2@XZ ; std::vector<double,std::allocator<double> >::_Getal
PUBLIC	?_Myfirst@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBQEANXZ ; std::vector<double,std::allocator<double> >::_Myfirst
PUBLIC	?_Myend@?$vector@NV?$allocator@N@std@@@std@@AEAAAEAPEANXZ ; std::vector<double,std::allocator<double> >::_Myend
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@N@std@@@std@@SA_KAEBV?$allocator@N@2@@Z ; std::_Default_allocator_traits<std::allocator<double> >::max_size
PUBLIC	?max_size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ ; std::vector<char,std::allocator<char> >::max_size
PUBLIC	?_Buy_raw@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z ; std::vector<char,std::allocator<char> >::_Buy_raw
PUBLIC	?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ ; std::vector<char,std::allocator<char> >::_Xlength
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
PUBLIC	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
PUBLIC	??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
PUBLIC	?allocate@?$allocator@N@std@@QEAAPEAN_K@Z	; std::allocator<double>::allocate
PUBLIC	?size@?$vector@NV?$allocator@N@std@@@std@@QEBA_KXZ ; std::vector<double,std::allocator<double> >::size
PUBLIC	?max_size@?$vector@NV?$allocator@N@std@@@std@@QEBA_KXZ ; std::vector<double,std::allocator<double> >::max_size
PUBLIC	?_Umove@?$vector@NV?$allocator@N@std@@@std@@AEAAPEANPEAN00@Z ; std::vector<double,std::allocator<double> >::_Umove
PUBLIC	?_Umove_if_noexcept@?$vector@NV?$allocator@N@std@@@std@@AEAAXPEAN00@Z ; std::vector<double,std::allocator<double> >::_Umove_if_noexcept
PUBLIC	?_Calculate_growth@?$vector@NV?$allocator@N@std@@@std@@AEBA_K_K@Z ; std::vector<double,std::allocator<double> >::_Calculate_growth
PUBLIC	?_Change_array@?$vector@NV?$allocator@N@std@@@std@@AEAAXQEAN_K1@Z ; std::vector<double,std::allocator<double> >::_Change_array
PUBLIC	?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ ; std::vector<double,std::allocator<double> >::_Xlength
PUBLIC	?_Myfirst@?$vector@NV?$allocator@N@std@@@std@@AEAAAEAPEANXZ ; std::vector<double,std::allocator<double> >::_Myfirst
PUBLIC	?_Ufill@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADPEAD_KU_Value_init_tag@2@@Z ; std::vector<char,std::allocator<char> >::_Ufill
PUBLIC	?_Buy_nonzero@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z ; std::vector<char,std::allocator<char> >::_Buy_nonzero
PUBLIC	?_Mylast@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAPEADXZ ; std::vector<char,std::allocator<char> >::_Mylast
PUBLIC	??1?$_Tidy_guard@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ; std::_Tidy_guard<std::vector<char,std::allocator<char> > >::~_Tidy_guard<std::vector<char,std::allocator<char> > >
PUBLIC	??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_Vector_val<std::_Simple_types<char> >::_Vector_val<std::_Simple_types<char> >
PUBLIC	??$_Get_size_of_n@$01@std@@YA_K_K@Z		; std::_Get_size_of_n<2>
PUBLIC	??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPEAD0AEAV?$allocator@D@0@@Z ; std::_Destroy_range<std::allocator<char> >
PUBLIC	??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z ; std::addressof<std::codecvt<char,char,_Mbstatet> const >
PUBLIC	??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
PUBLIC	??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>
PUBLIC	??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>,char>
PUBLIC	??$construct@PEA_WAEBQEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEAPEA_WAEBQEA_W@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * const &>
PUBLIC	??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_a3050a43f3157934f354774ab3dd2e02>,unsigned __int64,wchar_t>
PUBLIC	??$destroy@PEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEAPEA_W@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
PUBLIC	??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z	; std::addressof<wchar_t *>
PUBLIC	??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z		; std::_Unfancy<wchar_t>
PUBLIC	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
PUBLIC	??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z		; std::_Refancy<char *,0>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
PUBLIC	??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
PUBLIC	??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ; std::move<std::allocator<wchar_t> &>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
PUBLIC	??$?0V?$allocator@N@std@@$$V@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@N@1@@Z ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1><std::allocator<double> >
PUBLIC	??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z ; std::vector<double,std::allocator<double> >::_Emplace_reallocate<double const &>
PUBLIC	??$construct@NAEBN@?$_Default_allocator_traits@V?$allocator@N@std@@@std@@SAXAEAV?$allocator@N@1@QEANAEBN@Z ; std::_Default_allocator_traits<std::allocator<double> >::construct<double,double const &>
PUBLIC	??$_Unfancy@N@std@@YAPEANPEAN@Z			; std::_Unfancy<double>
PUBLIC	??$forward@AEBN@std@@YAAEBNAEBN@Z		; std::forward<double const &>
PUBLIC	??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@DV?$allocator@D@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ; std::vector<char,std::allocator<char> >::_Construct_n_copies_of_ty<std::_Value_init_tag>
PUBLIC	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
PUBLIC	??$_Unfancy_maybe_null@D@std@@YAPEADPEAD@Z	; std::_Unfancy_maybe_null<char>
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z ; std::filesystem::path::path<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
PUBLIC	??$?YV?$basic_string_view@DU?$char_traits@D@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=<std::basic_string_view<char,std::char_traits<char> >,void>
PUBLIC	??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z ; std::filesystem::_Convert_wide_to_narrow<std::char_traits<char>,std::allocator<char> >
PUBLIC	??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z ; std::filesystem::path::string<char,std::char_traits<char>,std::allocator<char>,0>
PUBLIC	??$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@0@XZ ; std::_Immortalize<std::_System_error_category>
PUBLIC	??$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@0@XZ ; std::_Immortalize<std::_Generic_error_category>
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_second
PUBLIC	?_Get_data@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ ; std::vector<double,std::allocator<double> >::_Get_data
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z	; std::allocator<wchar_t>::deallocate
PUBLIC	?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z	; std::allocator<wchar_t>::allocate
PUBLIC	?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z ; std::_WChar_traits<wchar_t>::assign
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?_Mylast@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBQEANXZ ; std::vector<double,std::allocator<double> >::_Mylast
PUBLIC	?_Myend@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBQEANXZ ; std::vector<double,std::allocator<double> >::_Myend
PUBLIC	?_Destroy@?$vector@DV?$allocator@D@std@@@std@@AEAAXPEAD0@Z ; std::vector<char,std::allocator<char> >::_Destroy
PUBLIC	?_Orphan_all@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ ; std::vector<char,std::allocator<char> >::_Orphan_all
PUBLIC	?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$allocator@D@2@XZ ; std::vector<char,std::allocator<char> >::_Getal
PUBLIC	?_Get_data@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ; std::vector<char,std::allocator<char> >::_Get_data
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ ; std::fpos<_Mbstatet>::state
PUBLIC	??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ		; std::fpos<_Mbstatet>::operator __int64
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
PUBLIC	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
PUBLIC	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
PUBLIC	?copy@?$_WChar_traits@_W@std@@SAPEA_WQEA_WQEB_W_K@Z ; std::_WChar_traits<wchar_t>::copy
PUBLIC	?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z	; std::_WChar_traits<wchar_t>::assign
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBAXQEADQEBD_K2D@Z ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator()
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z ; <lambda_66f57f934f28d61049862f64df852ff0>::operator()
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	??R<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@QEBAXQEAD_KD@Z ; <lambda_138c3d7c38c85abb84c7fc7bfe5747b7>::operator()
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents
PUBLIC	?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEBV12@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_lv_contents
PUBLIC	??R<lambda_a3050a43f3157934f354774ab3dd2e02>@@QEBAXQEA_WQEB_W_K2_W@Z ; <lambda_a3050a43f3157934f354774ab3dd2e02>::operator()
PUBLIC	?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
PUBLIC	?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAX_K@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
PUBLIC	?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
PUBLIC	?_Get_data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Get_data
PUBLIC	?_Get_data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Get_data
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?_Move_construct@?$vector@NV?$allocator@N@std@@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z ; std::vector<double,std::allocator<double> >::_Move_construct
PUBLIC	?_Has_unused_capacity@?$vector@NV?$allocator@N@std@@@std@@AEBA_NXZ ; std::vector<double,std::allocator<double> >::_Has_unused_capacity
PUBLIC	?_Orphan_range@?$vector@NV?$allocator@N@std@@@std@@AEBAXPEAN0@Z ; std::vector<double,std::allocator<double> >::_Orphan_range
PUBLIC	?_Mylast@?$vector@NV?$allocator@N@std@@@std@@AEAAAEAPEANXZ ; std::vector<double,std::allocator<double> >::_Mylast
PUBLIC	?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ ; std::vector<char,std::allocator<char> >::_Tidy
PUBLIC	?_Myfirst@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAPEADXZ ; std::vector<char,std::allocator<char> >::_Myfirst
PUBLIC	?zero@?$duration_values@_J@chrono@std@@SA_JXZ	; std::chrono::duration_values<__int64>::zero
PUBLIC	??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
PUBLIC	?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
PUBLIC	??0?$allocator@_W@std@@QEAA@XZ			; std::allocator<wchar_t>::allocator<wchar_t>
PUBLIC	??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAA@QEBD@Z ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >
PUBLIC	??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAA@QEBD_K@Z ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >
PUBLIC	?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_KXZ ; std::basic_string_view<char,std::char_traits<char> >::size
PUBLIC	?empty@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_string_view<char,std::char_traits<char> >::empty
PUBLIC	?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBA_KXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size
PUBLIC	?empty@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBA_NXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::empty
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::shrink_to_fit
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
PUBLIC	?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
PUBLIC	??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator std::basic_string_view<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
PUBLIC	?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEA_WXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
PUBLIC	?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
PUBLIC	?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
PUBLIC	?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize
PUBLIC	?_Orphan_all@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Orphan_all
PUBLIC	?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::zero
PUBLIC	??0?$vector@NV?$allocator@N@std@@@std@@QEAA@$$QEAV01@@Z ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
PUBLIC	??$_Emplace_back_with_unused_capacity@AEBN@?$vector@NV?$allocator@N@std@@@std@@AEAAAEANAEBN@Z ; std::vector<double,std::allocator<double> >::_Emplace_back_with_unused_capacity<double const &>
PUBLIC	??$emplace_back@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAAEANAEBN@Z ; std::vector<double,std::allocator<double> >::emplace_back<double const &>
PUBLIC	?push_back@?$vector@NV?$allocator@N@std@@@std@@QEAAXAEBN@Z ; std::vector<double,std::allocator<double> >::push_back
PUBLIC	??0?$vector@DV?$allocator@D@std@@@std@@QEAA@_KAEBV?$allocator@D@1@@Z ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
PUBLIC	??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
PUBLIC	?data@?$vector@DV?$allocator@D@std@@@std@@QEAAPEADXZ ; std::vector<char,std::allocator<char> >::data
PUBLIC	??0Numbers@@QEAA@$$QEAU0@@Z			; Numbers::Numbers
PUBLIC	?__autoclassinit2@?$vector@DV?$allocator@D@std@@@std@@QEAAX_K@Z ; std::vector<char,std::allocator<char> >::__autoclassinit2
PUBLIC	?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@XZ ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
PUBLIC	??0Timer@@QEAA@XZ				; Timer::Timer
PUBLIC	?file_size@filesystem@std@@YA_KAEBVpath@12@@Z	; std::filesystem::file_size
PUBLIC	?_File_size@filesystem@std@@YA?AW4__std_win_error@@AEBVpath@12@AEA_K@Z ; std::filesystem::_File_size
PUBLIC	?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z ; std::filesystem::_Throw_fs_error
PUBLIC	??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z ; std::filesystem::filesystem_error::filesystem_error
PUBLIC	??1filesystem_error@filesystem@std@@UEAA@XZ	; std::filesystem::filesystem_error::~filesystem_error
PUBLIC	??_Gfilesystem_error@filesystem@std@@UEAAPEAXI@Z ; std::filesystem::filesystem_error::`scalar deleting destructor'
PUBLIC	?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z ; std::filesystem::filesystem_error::_Pretty_message
PUBLIC	?what@filesystem_error@filesystem@std@@UEBAPEBDXZ ; std::filesystem::filesystem_error::what
PUBLIC	??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z ; std::filesystem::filesystem_error::filesystem_error
PUBLIC	??0path@filesystem@std@@QEAA@AEBV012@@Z		; std::filesystem::path::path
PUBLIC	??0path@filesystem@std@@QEAA@XZ			; std::filesystem::path::path
PUBLIC	??1path@filesystem@std@@QEAA@XZ			; std::filesystem::path::~path
PUBLIC	??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEAA@QEB_W_K@Z ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >
PUBLIC	?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ ; std::filesystem::path::string
PUBLIC	?c_str@path@filesystem@std@@QEBAPEB_WXZ		; std::filesystem::path::c_str
PUBLIC	?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBAPEB_WXZ ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data
PUBLIC	?data@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBAPEBDXZ ; std::basic_string_view<char,std::char_traits<char> >::data
PUBLIC	?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z ; std::filesystem::_Convert_narrow_to_wide
PUBLIC	?_Check_convert_result@filesystem@std@@YAHU__std_fs_convert_result@@@Z ; std::filesystem::_Check_convert_result
PUBLIC	?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z ; std::filesystem::_Make_ec
PUBLIC	?_Xsystem_error_invalid_argument@filesystem@std@@YAXXZ ; std::filesystem::_Xsystem_error_invalid_argument
PUBLIC	??U@YA?AW4__std_fs_stats_flags@@W40@0@Z		; operator|
PUBLIC	??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
PUBLIC	??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z	; std::_Ungetc<char>
PUBLIC	??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z		; std::_Fputc<char>
PUBLIC	??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z		; std::_Fgetc<char>
PUBLIC	??0runtime_error@std@@QEAA@AEBV01@@Z		; std::runtime_error::runtime_error
PUBLIC	??0_System_error@std@@QEAA@AEBV01@@Z		; std::_System_error::_System_error
PUBLIC	??0system_error@std@@QEAA@AEBV01@@Z		; std::system_error::system_error
PUBLIC	?system_category@std@@YAAEBVerror_category@1@XZ	; std::system_category
PUBLIC	?generic_category@std@@YAAEBVerror_category@1@XZ ; std::generic_category
PUBLIC	??1_System_error_category@std@@UEAA@XZ		; std::_System_error_category::~_System_error_category
PUBLIC	??_G_System_error_category@std@@UEAAPEAXI@Z	; std::_System_error_category::`scalar deleting destructor'
PUBLIC	?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z ; std::_System_error_category::default_error_condition
PUBLIC	?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_System_error_category::message
PUBLIC	?name@_System_error_category@std@@UEBAPEBDXZ	; std::_System_error_category::name
PUBLIC	??0_System_error_category@std@@QEAA@XZ		; std::_System_error_category::_System_error_category
PUBLIC	??1_Generic_error_category@std@@UEAA@XZ		; std::_Generic_error_category::~_Generic_error_category
PUBLIC	??_G_Generic_error_category@std@@UEAAPEAXI@Z	; std::_Generic_error_category::`scalar deleting destructor'
PUBLIC	?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ; std::_Generic_error_category::message
PUBLIC	?name@_Generic_error_category@std@@UEBAPEBDXZ	; std::_Generic_error_category::name
PUBLIC	??0_Generic_error_category@std@@QEAA@XZ		; std::_Generic_error_category::_Generic_error_category
PUBLIC	??1system_error@std@@UEAA@XZ			; std::system_error::~system_error
PUBLIC	??_Gsystem_error@std@@UEAAPEAXI@Z		; std::system_error::`scalar deleting destructor'
PUBLIC	??0system_error@std@@QEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::system_error::system_error
PUBLIC	??0system_error@std@@QEAA@Verror_code@1@@Z	; std::system_error::system_error
PUBLIC	??1_System_error@std@@UEAA@XZ			; std::_System_error::~_System_error
PUBLIC	??_G_System_error@std@@UEAAPEAXI@Z		; std::_System_error::`scalar deleting destructor'
PUBLIC	??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
PUBLIC	?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ; std::_System_error::_Makestr
PUBLIC	?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z ; std::make_error_code
PUBLIC	?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z ; std::error_category::equivalent
PUBLIC	?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z ; std::error_category::equivalent
PUBLIC	?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z ; std::error_category::default_error_condition
PUBLIC	??8std@@YA_NAEBVerror_condition@0@0@Z		; std::operator==
PUBLIC	?category@error_condition@std@@QEBAAEBVerror_category@2@XZ ; std::error_condition::category
PUBLIC	?value@error_condition@std@@QEBAHXZ		; std::error_condition::value
PUBLIC	??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z ; std::error_condition::error_condition
PUBLIC	?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::error_code::message
PUBLIC	?category@error_code@std@@QEBAAEBVerror_category@2@XZ ; std::error_code::category
PUBLIC	?value@error_code@std@@QEBAHXZ			; std::error_code::value
PUBLIC	??0error_code@std@@QEAA@HAEBVerror_category@1@@Z ; std::error_code::error_code
PUBLIC	??8error_category@std@@QEBA_NAEBV01@@Z		; std::error_category::operator==
PUBLIC	??1error_category@std@@UEAA@XZ			; std::error_category::~error_category
PUBLIC	??0error_category@std@@QEAA@XZ			; std::error_category::error_category
PUBLIC	??1runtime_error@std@@UEAA@XZ			; std::runtime_error::~runtime_error
PUBLIC	??_Gruntime_error@std@@UEAAPEAXI@Z		; std::runtime_error::`scalar deleting destructor'
PUBLIC	??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::runtime_error::runtime_error
PUBLIC	??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@3@PEBD_K@Z ; std::literals::string_view_literals::operator "" sv
PUBLIC	?not_eof@?$char_traits@D@std@@SAHAEBH@Z		; std::char_traits<char>::not_eof
PUBLIC	?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z	; std::char_traits<char>::assign
PUBLIC	?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ	; std::_Fake_proxy_ptr_impl::_Release
PUBLIC	??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	??0exception@std@@QEAA@QEBD@Z			; std::exception::exception
PUBLIC	?fpclassify@@YAHN@Z				; fpclassify
PUBLIC	wmemset
PUBLIC	wmemcpy
PUBLIC	?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; read_and_analyze_file
PUBLIC	?_Storage@?1???$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A ; `std::_Immortalize<std::_System_error_category>'::`2'::_Storage
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	?_Storage@?1???$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A ; `std::_Immortalize<std::_Generic_error_category>'::`2'::_Storage
EXTRN	??_E_System_error_category@std@@UEAAPEAXI@Z:PROC ; std::_System_error_category::`vector deleting destructor'
EXTRN	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E_System_error@std@@UEAAPEAXI@Z:PROC		; std::_System_error::`vector deleting destructor'
EXTRN	??_Esystem_error@std@@UEAAPEAXI@Z:PROC		; std::system_error::`vector deleting destructor'
EXTRN	??_Eruntime_error@std@@UEAAPEAXI@Z:PROC		; std::runtime_error::`vector deleting destructor'
EXTRN	??_Efilesystem_error@filesystem@std@@UEAAPEAXI@Z:PROC ; std::filesystem::filesystem_error::`vector deleting destructor'
EXTRN	??_E_Generic_error_category@std@@UEAAPEAXI@Z:PROC ; std::_Generic_error_category::`vector deleting destructor'
;	COMDAT ?_Storage@?1???$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A
_BSS	SEGMENT
?_Storage@?1???$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A DB 010H DUP (?) ; `std::_Immortalize<std::_System_error_category>'::`2'::_Storage
_BSS	ENDS
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
_BSS	ENDS
;	COMDAT ?_Storage@?1???$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A
_BSS	SEGMENT
?_Storage@?1???$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A DB 010H DUP (?) ; `std::_Immortalize<std::_Generic_error_category>'::`2'::_Storage
?t@@3VTimer@@A DB 018H DUP (?)				; t
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Zero_range@PEAD@std@@YAPEADQEAD0@Z DD imagerel $LN4
	DD	imagerel $LN4+31
	DD	imagerel $unwind$??$_Zero_range@PEAD@std@@YAPEADQEAD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Copy_memmove@PEANPEAN@std@@YAPEANPEAN00@Z DD imagerel $LN4
	DD	imagerel $LN4+48
	DD	imagerel $unwind$??$_Copy_memmove@PEANPEAN@std@@YAPEANPEAN00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n1@PEAD_KV?$allocator@D@std@@@std@@YAPEADPEAD_KAEAV?$allocator@D@0@U?$integral_constant@_N$00@0@@Z DD imagerel $LN6
	DD	imagerel $LN6+35
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n1@PEAD_KV?$allocator@D@std@@@std@@YAPEADPEAD_KAEAV?$allocator@D@0@U?$integral_constant@_N$00@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z DD imagerel $LN7
	DD	imagerel $LN7+48
	DD	imagerel $unwind$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_move@PEANPEANV?$allocator@N@std@@@std@@YAPEANQEAN0PEANAEAV?$allocator@N@0@@Z DD imagerel $LN16
	DD	imagerel $LN16+48
	DD	imagerel $unwind$??$_Uninitialized_move@PEANPEANV?$allocator@N@std@@@std@@YAPEANQEAN0PEANAEAV?$allocator@N@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Uninitialized_value_construct_n@PEAD_KV?$allocator@D@std@@@std@@YAPEADPEAD_KAEAV?$allocator@D@0@@Z DD imagerel $LN8
	DD	imagerel $LN8+35
	DD	imagerel $unwind$??$_Uninitialized_value_construct_n@PEAD_KV?$allocator@D@std@@@std@@YAPEADPEAD_KAEAV?$allocator@D@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z DD imagerel $LN34
	DD	imagerel $LN34+62
	DD	imagerel $unwind$??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DD imagerel $LN73
	DD	imagerel $LN73+362
	DD	imagerel $unwind$??$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0???$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$1@?0???$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$1@?0???$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0???$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_raw@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD imagerel $LN40
	DD	imagerel $LN40+42
	DD	imagerel $unwind$?_Buy_raw@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@N@std@@QEAAPEAN_K@Z DD imagerel $LN31
	DD	imagerel $LN31+117
	DD	imagerel $unwind$?allocate@?$allocator@N@std@@QEAAPEAN_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove@?$vector@NV?$allocator@N@std@@@std@@AEAAPEANPEAN00@Z DD imagerel $LN23
	DD	imagerel $LN23+45
	DD	imagerel $unwind$?_Umove@?$vector@NV?$allocator@N@std@@@std@@AEAAPEANPEAN00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Umove_if_noexcept@?$vector@NV?$allocator@N@std@@@std@@AEAAXPEAN00@Z DD imagerel $LN25
	DD	imagerel $LN25+48
	DD	imagerel $unwind$?_Umove_if_noexcept@?$vector@NV?$allocator@N@std@@@std@@AEAAXPEAN00@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Change_array@?$vector@NV?$allocator@N@std@@@std@@AEAAXQEAN_K1@Z DD imagerel $LN101
	DD	imagerel $LN101+136
	DD	imagerel $unwind$?_Change_array@?$vector@NV?$allocator@N@std@@@std@@AEAAXQEAN_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Ufill@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADPEAD_KU_Value_init_tag@2@@Z DD imagerel $LN15
	DD	imagerel $LN15+38
	DD	imagerel $unwind$?_Ufill@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADPEAD_KU_Value_init_tag@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Buy_nonzero@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD imagerel $LN56
	DD	imagerel $LN56+42
	DD	imagerel $unwind$?_Buy_nonzero@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$_Tidy_guard@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ DD imagerel $LN53
	DD	imagerel $LN53+93
	DD	imagerel $unwind$??1?$_Tidy_guard@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD imagerel $LN133
	DD	imagerel $LN133+45
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD imagerel $LN133+45
	DD	imagerel $LN133+374
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD imagerel $LN133+374
	DD	imagerel $LN133+380
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN119
	DD	imagerel $LN119+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN119+39
	DD	imagerel $LN119+286
	DD	imagerel $chain$1$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN119+286
	DD	imagerel $LN119+293
	DD	imagerel $chain$3$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel $LN119+293
	DD	imagerel $LN119+299
	DD	imagerel $chain$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z DD imagerel $LN116
	DD	imagerel $LN116+275
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z DD imagerel $LN157
	DD	imagerel $LN157+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z DD imagerel $LN157+47
	DD	imagerel $LN157+420
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z DD imagerel $LN157+420
	DD	imagerel $LN157+426
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD imagerel $LN71
	DD	imagerel $LN71+284
	DD	imagerel $unwind$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z DD imagerel $LN318
	DD	imagerel $LN318+70
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z DD imagerel $LN318+70
	DD	imagerel $LN318+388
	DD	imagerel $chain$2$??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z DD imagerel $LN318+388
	DD	imagerel $LN318+395
	DD	imagerel $chain$4$??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z DD imagerel $LN318+395
	DD	imagerel $LN318+401
	DD	imagerel $chain$5$??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@DV?$allocator@D@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD imagerel $LN142
	DD	imagerel $LN142+96
	DD	imagerel $unwind$??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@DV?$allocator@D@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN109
	DD	imagerel $LN109+464
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+56
	DD	imagerel $unwind$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z DD imagerel $LN37
	DD	imagerel $LN37+62
	DD	imagerel $unwind$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DD imagerel $LN68
	DD	imagerel $LN68+319
	DD	imagerel $unwind$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA DD imagerel ?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA
	DD	imagerel ?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA+41
	DD	imagerel $unwind$?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z DD imagerel $LN93
	DD	imagerel $LN93+351
	DD	imagerel $unwind$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA DD imagerel ?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA
	DD	imagerel ?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA+38
	DD	imagerel $unwind$?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@0@XZ DD imagerel $LN6
	DD	imagerel $LN6+54
	DD	imagerel $unwind$??$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@0@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@0@XZ DD imagerel $LN6
	DD	imagerel $LN6+54
	DD	imagerel $unwind$??$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@0@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD imagerel $LN17
	DD	imagerel $LN17+90
	DD	imagerel $unwind$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD imagerel $LN36
	DD	imagerel $LN36+339
	DD	imagerel $unwind$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z DD imagerel $LN21
	DD	imagerel $LN21+63
	DD	imagerel $unwind$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z DD imagerel $LN31
	DD	imagerel $LN31+113
	DD	imagerel $unwind$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z DD imagerel $LN15
	DD	imagerel $LN15+12
	DD	imagerel $unwind$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z DD imagerel $LN15+12
	DD	imagerel $LN15+34
	DD	imagerel $chain$0$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z DD imagerel $LN15+34
	DD	imagerel $LN15+42
	DD	imagerel $chain$1$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN10
	DD	imagerel $LN10+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN10
	DD	imagerel $LN10+45
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD imagerel $LN19
	DD	imagerel $LN19+127
	DD	imagerel $unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z DD imagerel $LN13
	DD	imagerel $LN13+192
	DD	imagerel $unwind$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN23
	DD	imagerel $LN23+53
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN23+53
	DD	imagerel $LN23+148
	DD	imagerel $chain$0$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN23+148
	DD	imagerel $LN23+211
	DD	imagerel $chain$2$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN23+211
	DD	imagerel $LN23+232
	DD	imagerel $chain$3$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z DD imagerel $LN15
	DD	imagerel $LN15+72
	DD	imagerel $unwind$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DD imagerel $LN62
	DD	imagerel $LN62+512
	DD	imagerel $unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$_WChar_traits@_W@std@@SAPEA_WQEA_WQEB_W_K@Z DD imagerel $LN7
	DD	imagerel $LN7+26
	DD	imagerel $unwind$?copy@?$_WChar_traits@_W@std@@SAPEA_WQEA_WQEB_W_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z DD imagerel $LN83
	DD	imagerel $LN83+207
	DD	imagerel $unwind$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBAXQEADQEBD_K2D@Z DD imagerel $LN11
	DD	imagerel $LN11+69
	DD	imagerel $unwind$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBAXQEADQEBD_K2D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN21
	DD	imagerel $LN21+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN21+35
	DD	imagerel $LN21+100
	DD	imagerel $chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN21+100
	DD	imagerel $LN21+125
	DD	imagerel $chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z DD imagerel $LN9
	DD	imagerel $LN9+42
	DD	imagerel $unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN138
	DD	imagerel $LN138+138
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN138+138
	DD	imagerel $LN138+325
	DD	imagerel $chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN138+325
	DD	imagerel $LN138+332
	DD	imagerel $chain$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN138+332
	DD	imagerel $LN138+338
	DD	imagerel $chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@QEBAXQEAD_KD@Z DD imagerel $LN9
	DD	imagerel $LN9+38
	DD	imagerel $unwind$??R<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@QEBAXQEAD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN137
	DD	imagerel $LN137+84
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN137+84
	DD	imagerel $LN137+330
	DD	imagerel $chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN137+330
	DD	imagerel $LN137+337
	DD	imagerel $chain$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z DD imagerel $LN26
	DD	imagerel $LN26+61
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEBV12@@Z DD imagerel $LN89
	DD	imagerel $LN89+240
	DD	imagerel $unwind$?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_a3050a43f3157934f354774ab3dd2e02>@@QEBAXQEA_WQEB_W_K2_W@Z DD imagerel $LN22
	DD	imagerel $LN22+90
	DD	imagerel $unwind$??R<lambda_a3050a43f3157934f354774ab3dd2e02>@@QEBAXQEA_WQEB_W_K2_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K_W@Z DD imagerel $LN30
	DD	imagerel $LN30+101
	DD	imagerel $unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DD imagerel $LN49
	DD	imagerel $LN49+98
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN28
	DD	imagerel $LN28+126
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN15
	DD	imagerel $LN15+72
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ DD imagerel $LN49
	DD	imagerel $LN49+88
	DD	imagerel $unwind$?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN7
	DD	imagerel $LN7+52
	DD	imagerel $unwind$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+152
	DD	imagerel $unwind$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN31
	DD	imagerel $LN31+179
	DD	imagerel $unwind$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN70
	DD	imagerel $LN70+96
	DD	imagerel $unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN70+96
	DD	imagerel $LN70+386
	DD	imagerel $chain$0$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN70+386
	DD	imagerel $LN70+416
	DD	imagerel $chain$1$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN73
	DD	imagerel $LN73+224
	DD	imagerel $unwind$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN24
	DD	imagerel $LN24+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN24+51
	DD	imagerel $LN24+77
	DD	imagerel $chain$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN24+77
	DD	imagerel $LN24+101
	DD	imagerel $chain$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN521
	DD	imagerel $LN521+735
	DD	imagerel $unwind$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD imagerel $LN39
	DD	imagerel $LN39+60
	DD	imagerel $unwind$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD imagerel $LN39+60
	DD	imagerel $LN39+336
	DD	imagerel $chain$1$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD imagerel $LN39+336
	DD	imagerel $LN39+341
	DD	imagerel $chain$3$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z DD imagerel $LN19
	DD	imagerel $LN19+212
	DD	imagerel $unwind$?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN23
	DD	imagerel $LN23+262
	DD	imagerel $unwind$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN22
	DD	imagerel $LN22+211
	DD	imagerel $unwind$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD imagerel $LN20
	DD	imagerel $LN20+77
	DD	imagerel $unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD imagerel $LN20+77
	DD	imagerel $LN20+221
	DD	imagerel $chain$0$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD imagerel $LN20+221
	DD	imagerel $LN20+243
	DD	imagerel $chain$1$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN13
	DD	imagerel $LN13+71
	DD	imagerel $unwind$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z DD imagerel $LN17
	DD	imagerel $LN17+80
	DD	imagerel $unwind$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z DD imagerel $LN19
	DD	imagerel $LN19+68
	DD	imagerel $unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN105
	DD	imagerel $LN105+208
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN34
	DD	imagerel $LN34+59
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD imagerel $LN160
	DD	imagerel $LN160+43
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD imagerel $LN160+43
	DD	imagerel $LN160+116
	DD	imagerel $chain$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD imagerel $LN160+116
	DD	imagerel $LN160+123
	DD	imagerel $chain$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN132
	DD	imagerel $LN132+23
	DD	imagerel $unwind$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN132+23
	DD	imagerel $LN132+134
	DD	imagerel $chain$1$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN132+134
	DD	imagerel $LN132+321
	DD	imagerel $chain$3$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN132+321
	DD	imagerel $LN132+327
	DD	imagerel $chain$4$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN132+327
	DD	imagerel $LN132+334
	DD	imagerel $chain$5$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD imagerel $LN47
	DD	imagerel $LN47+42
	DD	imagerel $unwind$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD imagerel $LN47+42
	DD	imagerel $LN47+117
	DD	imagerel $chain$1$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD imagerel $LN47+117
	DD	imagerel $LN47+138
	DD	imagerel $chain$3$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN111
	DD	imagerel $LN111+236
	DD	imagerel $unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD imagerel $LN60
	DD	imagerel $LN60+98
	DD	imagerel $unwind$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z DD imagerel $LN55
	DD	imagerel $LN55+135
	DD	imagerel $unwind$?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$vector@DV?$allocator@D@std@@@std@@QEAA@_KAEBV?$allocator@D@1@@Z DD imagerel $LN151
	DD	imagerel $LN151+84
	DD	imagerel $unwind$??0?$vector@DV?$allocator@D@std@@@std@@QEAA@_KAEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ DD imagerel $LN52
	DD	imagerel $LN52+88
	DD	imagerel $unwind$??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN8
	DD	imagerel $LN8+101
	DD	imagerel $unwind$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?file_size@filesystem@std@@YA_KAEBVpath@12@@Z DD imagerel $LN29
	DD	imagerel $LN29+95
	DD	imagerel $unwind$?file_size@filesystem@std@@YA_KAEBVpath@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_File_size@filesystem@std@@YA?AW4__std_win_error@@AEBVpath@12@AEA_K@Z DD imagerel $LN24
	DD	imagerel $LN24+93
	DD	imagerel $unwind$?_File_size@filesystem@std@@YA?AW4__std_win_error@@AEBVpath@12@AEA_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z DD imagerel $LN63
	DD	imagerel $LN63+112
	DD	imagerel $unwind$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z DD imagerel $LN20
	DD	imagerel $LN20+148
	DD	imagerel $unwind$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1filesystem_error@filesystem@std@@UEAA@XZ DD imagerel $LN197
	DD	imagerel $LN197+290
	DD	imagerel $unwind$??1filesystem_error@filesystem@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gfilesystem_error@filesystem@std@@UEAAPEAXI@Z DD imagerel $LN202
	DD	imagerel $LN202+324
	DD	imagerel $unwind$??_Gfilesystem_error@filesystem@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z DD imagerel $LN273
	DD	imagerel $LN273+513
	DD	imagerel $unwind$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA DD imagerel ?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA
	DD	imagerel ?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z DD imagerel $LN137
	DD	imagerel $LN137+292
	DD	imagerel $unwind$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0path@filesystem@std@@QEAA@AEBV012@@Z DD imagerel $LN115
	DD	imagerel $LN115+241
	DD	imagerel $unwind$??0path@filesystem@std@@QEAA@AEBV012@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1path@filesystem@std@@QEAA@XZ DD imagerel $LN64
	DD	imagerel $LN64+98
	DD	imagerel $unwind$??1path@filesystem@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ DD imagerel $LN100
	DD	imagerel $LN100+351
	DD	imagerel $unwind$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA DD imagerel ?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA
	DD	imagerel ?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA+38
	DD	imagerel $unwind$?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z DD imagerel $LN122
	DD	imagerel $LN122+441
	DD	imagerel $unwind$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA DD imagerel ?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA
	DD	imagerel ?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA+41
	DD	imagerel $unwind$?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_convert_result@filesystem@std@@YAHU__std_fs_convert_result@@@Z DD imagerel $LN7
	DD	imagerel $LN7+77
	DD	imagerel $unwind$?_Check_convert_result@filesystem@std@@YAHU__std_fs_convert_result@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z DD imagerel $LN15
	DD	imagerel $LN15+86
	DD	imagerel $unwind$?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xsystem_error_invalid_argument@filesystem@std@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$?_Xsystem_error_invalid_argument@filesystem@std@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z DD imagerel $LN6
	DD	imagerel $LN6+41
	DD	imagerel $unwind$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0runtime_error@std@@QEAA@AEBV01@@Z DD imagerel $LN7
	DD	imagerel $LN7+63
	DD	imagerel $unwind$??0runtime_error@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_System_error@std@@QEAA@AEBV01@@Z DD imagerel $LN10
	DD	imagerel $LN10+82
	DD	imagerel $unwind$??0_System_error@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0system_error@std@@QEAA@AEBV01@@Z DD imagerel $LN13
	DD	imagerel $LN13+92
	DD	imagerel $unwind$??0system_error@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?system_category@std@@YAAEBVerror_category@1@XZ DD imagerel $LN10
	DD	imagerel $LN10+54
	DD	imagerel $unwind$?system_category@std@@YAAEBVerror_category@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?generic_category@std@@YAAEBVerror_category@1@XZ DD imagerel $LN10
	DD	imagerel $LN10+54
	DD	imagerel $unwind$?generic_category@std@@YAAEBVerror_category@1@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_System_error_category@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+33
	DD	imagerel $unwind$??_G_System_error_category@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z DD imagerel $LN27
	DD	imagerel $LN27+174
	DD	imagerel $unwind$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD imagerel $LN316
	DD	imagerel $LN316+660
	DD	imagerel $unwind$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA DD imagerel ?dtor$0@?0??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA
	DD	imagerel ?dtor$0@?0??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_Generic_error_category@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+33
	DD	imagerel $unwind$??_G_Generic_error_category@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD imagerel $LN38
	DD	imagerel $LN38+78
	DD	imagerel $unwind$?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gsystem_error@std@@UEAAPEAXI@Z DD imagerel $LN18
	DD	imagerel $LN18+67
	DD	imagerel $unwind$??_Gsystem_error@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0system_error@std@@QEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+48
	DD	imagerel $unwind$??0system_error@std@@QEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0system_error@std@@QEAA@Verror_code@1@@Z DD imagerel $LN96
	DD	imagerel $LN96+188
	DD	imagerel $unwind$??0system_error@std@@QEAA@Verror_code@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G_System_error@std@@UEAAPEAXI@Z DD imagerel $LN15
	DD	imagerel $LN15+67
	DD	imagerel $unwind$??_G_System_error@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN284
	DD	imagerel $LN284+449
	DD	imagerel $unwind$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD imagerel $LN204
	DD	imagerel $LN204+252
	DD	imagerel $unwind$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z DD imagerel $LN15
	DD	imagerel $LN15+78
	DD	imagerel $unwind$?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z DD imagerel $LN19
	DD	imagerel $LN19+63
	DD	imagerel $unwind$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN11
	DD	imagerel $LN11+35
	DD	imagerel $unwind$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gruntime_error@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+67
	DD	imagerel $unwind$??_Gruntime_error@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN20
	DD	imagerel $LN20+112
	DD	imagerel $unwind$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z DD imagerel $LN5
	DD	imagerel $LN5+28
	DD	imagerel $unwind$?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@QEBD@Z DD imagerel $LN5
	DD	imagerel $LN5+92
	DD	imagerel $unwind$??0exception@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?fpclassify@@YAHN@Z DD imagerel $LN5
	DD	imagerel $LN5+55
	DD	imagerel $unwind$?fpclassify@@YAHN@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wmemset DD imagerel $LN12
	DD	imagerel $LN12+12
	DD	imagerel $unwind$wmemset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$wmemset DD imagerel $LN12+12
	DD	imagerel $LN12+34
	DD	imagerel $chain$0$wmemset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$wmemset DD imagerel $LN12+34
	DD	imagerel $LN12+42
	DD	imagerel $chain$1$wmemset
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$wmemcpy DD imagerel $LN4
	DD	imagerel $LN4+26
	DD	imagerel $unwind$wmemcpy
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN664
	DD	imagerel $LN664+1543
	DD	imagerel $unwind$?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$1@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$1@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+41
	DD	imagerel $unwind$?dtor$1@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel ?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+146
	DD	01H
	DD	imagerel ?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+206
	DD	02H
	DD	imagerel ?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+321
	DD	03H
	DD	imagerel ?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+460
	DD	04H
	DD	imagerel ?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+621
	DD	03H
	DD	imagerel ?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1259
	DD	02H
	DD	imagerel ?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1472
	DD	00H
	DD	imagerel ?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1537
	DD	04H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$0@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$3@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$4@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	00H
	DD	00H
	DD	08H
	DD	imagerel $ip2state$?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	088H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0f4319H
	DD	0207832H
	DD	021682dH
	DD	04e3428H
	DD	044011cH
	DD	0e00cf00eH
	DD	0c008d00aH
	DD	060057006H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	01faH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wmemcpy DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$wmemset DD 021H
	DD	imagerel $LN12
	DD	imagerel $LN12+12
	DD	imagerel $unwind$wmemset
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$wmemset DD 020421H
	DD	07404H
	DD	imagerel $LN12
	DD	imagerel $LN12+12
	DD	imagerel $unwind$wmemset
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$wmemset DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?fpclassify@@YAHN@Z DD 011319H
	DD	06204H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@QEBD@Z DD 021519H
	DD	030027206H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 021519H
	DD	030027206H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gruntime_error@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD imagerel ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z+74
	DD	00H
	DD	imagerel ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z+98
	DD	01H
	DD	imagerel ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z+129
	DD	00H
	DD	imagerel ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z+239
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	00H
	DD	00H
	DD	04H
	DD	imagerel $ip2state$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z DD 042019H
	DD	07004b208H
	DD	030026003H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel ??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z+57
	DD	0ffffffffH
	DD	imagerel ??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z+103
	DD	00H
	DD	imagerel ??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z+130
	DD	01H
	DD	imagerel ??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z+167
	DD	00H
	DD	imagerel ??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z+433
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 0ffffffffH
	DD	imagerel ?dtor$3@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$4@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	048H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 052619H
	DD	014010bH
	DD	060037004H
	DD	03002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
	DD	092H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_System_error@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0system_error@std@@QEAA@Verror_code@1@@Z DD imagerel ??0system_error@std@@QEAA@Verror_code@1@@Z+62
	DD	0ffffffffH
	DD	imagerel ??0system_error@std@@QEAA@Verror_code@1@@Z+91
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0system_error@std@@QEAA@Verror_code@1@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0system_error@std@@QEAA@Verror_code@1@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0system_error@std@@QEAA@Verror_code@1@@Z
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$??0system_error@std@@QEAA@Verror_code@1@@Z
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0system_error@std@@QEAA@Verror_code@1@@Z DD 041411H
	DD	0103414H
	DD	07004b208H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0system_error@std@@QEAA@Verror_code@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0system_error@std@@QEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gsystem_error@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_Generic_error_category@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD imagerel ?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z+149
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z DD 0a1e11H
	DD	010341eH
	DD	0f00e7212H
	DD	0d00ae00cH
	DD	07006c008H
	DD	050046005H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z DD imagerel ?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z+34
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z DD 061919H
	DD	096419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G_System_error_category@std@@UEAAPEAXI@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?generic_category@std@@YAAEBVerror_category@1@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?system_category@std@@YAAEBVerror_category@1@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0system_error@std@@QEAA@AEBV01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_System_error@std@@QEAA@AEBV01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0runtime_error@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xsystem_error_invalid_argument@filesystem@std@@YAXXZ DD 010401H
	DD	0e204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_convert_result@filesystem@std@@YAHU__std_fs_convert_result@@@Z DD 010401H
	DD	0e204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z DD imagerel ?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z+250
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z
	DD	038H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z DD 0b2611H
	DD	01a5426H
	DD	0193422H
	DD	0120116H
	DD	0e00df00fH
	DD	07009c00bH
	DD	06008H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ DD imagerel ?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ+152
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ DD 0ffffffffH
	DD	imagerel ?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ DD 091f11H
	DD	020541fH
	DD	01e341bH
	DD	01a010eH
	DD	07005e007H
	DD	06004H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1path@filesystem@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0path@filesystem@std@@QEAA@AEBV012@@Z DD 063001H
	DD	0c6430H
	DD	070045208H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z DD imagerel ??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z+46
	DD	0ffffffffH
	DD	imagerel ??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z+69
	DD	00H
	DD	imagerel ??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z+206
	DD	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA
	DD	02H
	DD	imagerel ?dtor$3@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z DD 019930522H
	DD	04H
	DD	imagerel $stateUnwindMap$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z DD 031011H
	DD	07003e207H
	DD	03002H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z DD imagerel ?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z+92
	DD	00H
	DD	imagerel ?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z+106
	DD	01H
	DD	imagerel ?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z+148
	DD	02H
	DD	imagerel ?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z+334
	DD	01H
	DD	imagerel ?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z+496
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z DD 042319H
	DD	07004f20bH
	DD	030026003H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z
	DD	07aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gfilesystem_error@filesystem@std@@UEAAPEAXI@Z DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1filesystem_error@filesystem@std@@UEAA@XZ DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z DD imagerel ??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z+100
	DD	00H
	DD	imagerel ??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z+114
	DD	01H
	DD	imagerel ??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z+128
	DD	02H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z DD imagerel ?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z+53
	DD	0ffffffffH
	DD	imagerel ?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z+89
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z DD 031211H
	DD	0200109H
	DD	03002H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_File_size@filesystem@std@@YA?AW4__std_win_error@@AEBVpath@12@AEA_K@Z DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?file_size@filesystem@std@@YA_KAEBVpath@12@@Z DD 021519H
	DD	030029206H
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$vector@DV?$allocator@D@std@@@std@@QEAA@_KAEBV?$allocator@D@1@@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z DD 062b01H
	DD	0a642bH
	DD	070043208H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD 020021H
	DD	067400H
	DD	imagerel $LN47
	DD	imagerel $LN47+42
	DD	imagerel $unwind$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD 041b21H
	DD	08341bH
	DD	067405H
	DD	imagerel $LN47
	DD	imagerel $LN47+42
	DD	imagerel $unwind$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z DD 010401H
	DD	06204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 040021H
	DD	087400H
	DD	076400H
	DD	imagerel $LN132
	DD	imagerel $LN132+23
	DD	imagerel $unwind$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 021H
	DD	imagerel $LN132
	DD	imagerel $LN132+23
	DD	imagerel $unwind$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 040021H
	DD	087400H
	DD	076400H
	DD	imagerel $LN132
	DD	imagerel $LN132+23
	DD	imagerel $unwind$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 040e21H
	DD	08740eH
	DD	076405H
	DD	imagerel $LN132
	DD	imagerel $LN132+23
	DD	imagerel $unwind$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD 021H
	DD	imagerel $LN160
	DD	imagerel $LN160+43
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD 020521H
	DD	073405H
	DD	imagerel $LN160
	DD	imagerel $LN160+43
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD 020601H
	DD	070023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 062b01H
	DD	0a642bH
	DD	070043208H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD 021H
	DD	imagerel $LN20
	DD	imagerel $LN20+77
	DD	imagerel $unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD 020521H
	DD	087405H
	DD	imagerel $LN20
	DD	imagerel $LN20+77
	DD	imagerel $unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD 031619H
	DD	060038207H
	DD	03002H
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 041719H
	DD	070045208H
	DD	030026003H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 061a19H
	DD	0e007520bH
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z DD 0a4501H
	DD	076445H
	DD	065440H
	DD	097410H
	DD	083410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD 040021H
	DD	047400H
	DD	053400H
	DD	imagerel $LN39
	DD	imagerel $LN39+60
	DD	imagerel $unwind$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD 041f21H
	DD	05341fH
	DD	047405H
	DD	imagerel $LN39
	DD	imagerel $LN39+60
	DD	imagerel $unwind$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z DD 040901H
	DD	0e0055209H
	DD	050026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+309
	DD	00H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+521
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 072d19H
	DD	016741fH
	DD	015341bH
	DD	012010fH
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	082H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020021H
	DD	067400H
	DD	imagerel $LN24
	DD	imagerel $LN24+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020521H
	DD	067405H
	DD	imagerel $LN24
	DD	imagerel $LN24+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 021H
	DD	imagerel $LN70
	DD	imagerel $LN70+96
	DD	imagerel $unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 020821H
	DD	0146408H
	DD	imagerel $LN70
	DD	imagerel $LN70+96
	DD	imagerel $unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 041c19H
	DD	015340dH
	DD	07006f20dH
	DD	imagerel __GSHandlerCheck
	DD	078H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ+102
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ+32
	DD	0ffffffffH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ+62
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z+53
	DD	0ffffffffH
	DD	imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z+88
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K_W@Z DD 020601H
	DD	070025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_a3050a43f3157934f354774ab3dd2e02>@@QEBAXQEA_WQEB_W_K2_W@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEBV12@@Z DD 064301H
	DD	0a5443H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 020021H
	DD	075400H
	DD	imagerel $LN137
	DD	imagerel $LN137+84
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 020521H
	DD	075405H
	DD	imagerel $LN137
	DD	imagerel $LN137+84
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 060f01H
	DD	09640fH
	DD	08340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@QEBAXQEAD_KD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021H
	DD	imagerel $LN138
	DD	imagerel $LN138+138
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020021H
	DD	0d5400H
	DD	imagerel $LN138
	DD	imagerel $LN138+138
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020521H
	DD	0d5405H
	DD	imagerel $LN138
	DD	imagerel $LN138+138
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 060c01H
	DD	0f008320cH
	DD	07004e006H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 021H
	DD	imagerel $LN21
	DD	imagerel $LN21+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 020521H
	DD	083405H
	DD	imagerel $LN21
	DD	imagerel $LN21+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 040a01H
	DD	09640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBAXQEADQEBD_K2D@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z DD 064301H
	DD	0a5443H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$_WChar_traits@_W@std@@SAPEA_WQEA_WQEB_W_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DD imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z+74
	DD	0ffffffffH
	DD	imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z+105
	DD	00H
	DD	imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z+155
	DD	01H
	DD	imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z+183
	DD	02H
	DD	imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z+221
	DD	03H
	DD	imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z+371
	DD	04H
	DD	imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z+415
	DD	03H
	DD	imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z+480
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DD	01H
	DD	imagerel ?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
	DD	03H
	DD	imagerel ?dtor$4@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
	DD	00H
	DD	00H
	DD	08H
	DD	imagerel $ip2state$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z DD 062819H
	DD	0143419H
	DD	07004d208H
	DD	050026003H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
	DD	06aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 021H
	DD	imagerel $LN23
	DD	imagerel $LN23+53
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 020021H
	DD	0f7400H
	DD	imagerel $LN23
	DD	imagerel $LN23+53
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 020521H
	DD	0f7405H
	DD	imagerel $LN23
	DD	imagerel $LN23+53
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 021519H
	DD	03002b206H
	DD	imagerel __GSHandlerCheck
	DD	058H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z DD 061e19H
	DD	0d640fH
	DD	0c340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ+36
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z DD 021H
	DD	imagerel $LN15
	DD	imagerel $LN15+12
	DD	imagerel $unwind$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z DD 020421H
	DD	07404H
	DD	imagerel $LN15
	DD	imagerel $LN15+12
	DD	imagerel $unwind$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD imagerel ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z+72
	DD	0ffffffffH
	DD	imagerel ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z+224
	DD	00H
	DD	imagerel ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z+268
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD 062819H
	DD	0f6419H
	DD	0e3414H
	DD	070029206H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD imagerel ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z+23
	DD	0ffffffffH
	DD	imagerel ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z+51
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD 020f11H
	DD	030027206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@0@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@0@XZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z DD imagerel ??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z+152
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z DD 091f11H
	DD	020541fH
	DD	01e341bH
	DD	01a010eH
	DD	07005e007H
	DD	06004H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DD imagerel ??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z+133
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
	DD	038H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DD 092211H
	DD	0185422H
	DD	017341eH
	DD	0120112H
	DD	07009e00bH
	DD	06008H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+118
	DD	0ffffffffH
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+163
	DD	00H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+246
	DD	02H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+357
	DD	01H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+398
	DD	04H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+418
	DD	05H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+443
	DD	0ffffffffH
	DD	imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+35
	DD	03H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$0$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	imagerel __imp___std_terminate
	DD	04H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	01H
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	08H
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 081f19H
	DD	0f341fH
	DD	0f00d7211H
	DD	0c009e00bH
	DD	060067007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@DV?$allocator@D@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z DD 041919H
	DD	09340aH
	DD	07006520aH
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z DD 021H
	DD	imagerel $LN318
	DD	imagerel $LN318+70
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z DD 060021H
	DD	04f400H
	DD	0d5400H
	DD	0c3400H
	DD	imagerel $LN318
	DD	imagerel $LN318+70
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z DD 063821H
	DD	0c3438H
	DD	04f415H
	DD	0d5405H
	DD	imagerel $LN318
	DD	imagerel $LN318+70
	DD	imagerel $unwind$??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z DD 050b01H
	DD	0e007420bH
	DD	07003c005H
	DD	06002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD imagerel ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z+48
	DD	0ffffffffH
	DD	imagerel ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z+74
	DD	00H
	DD	imagerel ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z+181
	DD	01H
	DD	imagerel ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z+210
	DD	0ffffffffH
	DD	imagerel ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z+256
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD 062719H
	DD	0106418H
	DD	0f3414H
	DD	07004b208H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	05aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z DD 021H
	DD	imagerel $LN157
	DD	imagerel $LN157+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z DD 084a21H
	DD	0e344aH
	DD	04d41aH
	DD	05640eH
	DD	065405H
	DD	imagerel $LN157
	DD	imagerel $LN157+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z DD 050c01H
	DD	0f008620cH
	DD	0c004e006H
	DD	07002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z DD 084901H
	DD	073449H
	DD	09640fH
	DD	08540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 021H
	DD	imagerel $LN119
	DD	imagerel $LN119+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 040021H
	DD	047400H
	DD	0c5400H
	DD	imagerel $LN119
	DD	imagerel $LN119+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 043c21H
	DD	04743cH
	DD	0c5405H
	DD	imagerel $LN119
	DD	imagerel $LN119+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 050b01H
	DD	0f007420bH
	DD	06003e005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD 021H
	DD	imagerel $LN133
	DD	imagerel $LN133+45
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD 084e21H
	DD	06c44eH
	DD	0e3445H
	DD	04f40eH
	DD	05e405H
	DD	imagerel $LN133
	DD	imagerel $LN133+45
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD 050a01H
	DD	0d006620aH
	DD	060037004H
	DD	05002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$_Tidy_guard@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_nonzero@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Ufill@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADPEAD_KU_Value_init_tag@2@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Change_array@?$vector@NV?$allocator@N@std@@@std@@AEAAXQEAN_K1@Z DD 081401H
	DD	096414H
	DD	085414H
	DD	073414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove_if_noexcept@?$vector@NV?$allocator@N@std@@@std@@AEAAXPEAN00@Z DD 011319H
	DD	06204H
	DD	imagerel __GSHandlerCheck
	DD	020H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Umove@?$vector@NV?$allocator@N@std@@@std@@AEAAPEANPEAN00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@N@std@@QEAAPEAN_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Buy_raw@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0???$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DD imagerel ??$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z+163
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z DD 091f11H
	DD	021541fH
	DD	020341bH
	DD	01a010eH
	DD	07005e007H
	DD	06004H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n@PEAD_KV?$allocator@D@std@@@std@@YAPEADPEAD_KAEAV?$allocator@D@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_move@PEANPEANV?$allocator@N@std@@@std@@YAPEANQEAN0PEANAEAV?$allocator@N@0@@Z DD 040a01H
	DD	09340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z DD 020601H
	DD	030025206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Uninitialized_value_construct_n1@PEAD_KV?$allocator@D@std@@@std@@YAPEADPEAD_KAEAV?$allocator@D@0@U?$integral_constant@_N$00@0@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Copy_memmove@PEANPEAN@std@@YAPEANPEAN00@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Zero_range@PEAD@std@@YAPEADQEAD0@Z DD 020601H
	DD	030023206H
; Function compile flags: /Ogtpy
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Petr\Desktop\PPR\src\utils\stats.cpp
; File C:\Users\Petr\Desktop\PPR\src\utils\timer.cpp
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\corecrt_math.h
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Users\Petr\Desktop\PPR\src\utils\timer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Users\Petr\Desktop\PPR\src\utils\timer.cpp
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp
; File C:\Users\Petr\Desktop\PPR\src\utils\stats.cpp
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp
; File C:\Users\Petr\Desktop\PPR\src\utils\stats.cpp
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp
; File C:\Users\Petr\Desktop\PPR\src\utils\timer.cpp
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp
; File C:\Users\Petr\Desktop\PPR\src\utils\timer.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp
;	COMDAT ?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 48
$T53 = 56
stats$ = 88
$T181 = 136
__$ReturnUdt$GSCopy$ = 144
filename$GSCopy$ = 152
input_file$ = 160
number$182 = 432
_X$ = 448
_Stats$183 = 448
$T65 = 448
buffer$ = 480
__$ArrayPad$ = 504
__$ReturnUdt$ = 608
filename$ = 616
?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; read_and_analyze_file, COMDAT

; 15   : {

$LN664:
	mov	rax, rsp
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	lea	rbp, QWORD PTR [rax-344]
	sub	rsp, 544				; 00000220H
	mov	QWORD PTR $T181[rbp-256], -2
	mov	QWORD PTR [rax+24], rbx
	vmovaps	XMMWORD PTR [rax-72], xmm6
	vmovaps	XMMWORD PTR [rax-88], xmm7
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-256], rax
	mov	r12, rdx
	mov	r14, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rbp-256], rcx
	mov	QWORD PTR filename$GSCopy$[rbp-256], rdx
	xor	esi, esi
	mov	DWORD PTR $T1[rsp], esi
	mov	QWORD PTR [rcx], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	QWORD PTR [rcx+8], rsi
	mov	QWORD PTR [rcx+16], rsi
	mov	QWORD PTR [rcx+24], rsi
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp

; 99   : 	return result;

	mov	DWORD PTR $T1[rsp], 1
	xor	edx, edx
	mov	r8d, 272				; 00000110H
	lea	rcx, QWORD PTR input_file$[rbp-256]
	call	memset
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2023 :         const value_type* _Result = _Bx._Buf;

	mov	rdx, r12

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [r12+24], 16

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN53@read_and_a
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rdx, QWORD PTR [r12]
$LN53@read_and_a:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 777  :         : basic_ifstream(_Str.c_str(), _Mode, _Prot) { // construct with named file and specified mode

	lea	rcx, QWORD PTR input_file$[rbp-256]
	call	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
	mov	rax, QWORD PTR input_file$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR input_file$[rbp+rcx-256], rax
	mov	rax, QWORD PTR input_file$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-176]
	mov	DWORD PTR input_file$[rbp+rcx-260], edx
	vpxor	xmm0, xmm0, xmm0
	vmovups	XMMWORD PTR buffer$[rbp-256], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	mov	ecx, 800				; 00000320H
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	mov	QWORD PTR buffer$[rbp-256], rax

; 1494 :         _My_data._Mylast  = _My_data._Myfirst;
; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	r13, QWORD PTR [rax+800]
	mov	QWORD PTR buffer$[rbp-240], r13
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	r8d, 800				; 00000320H
	mov	rcx, rax
	call	memset
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 389  :             _Mylast()      = _Ufill(_Myfirst(), _Count, _Val);

	mov	QWORD PTR buffer$[rbp-248], r13
	vxorpd	xmm0, xmm0, xmm0
; File C:\Users\Petr\Desktop\PPR\src\utils\stats.cpp

; 23   : 	m1 = 0;

	vmovupd	YMMWORD PTR stats$[rsp+8], ymm0

; 24   : 	m2 = 0;
; 25   : 	m3 = 0;
; 26   : 	m4 = 0;
; 27   : 	n = 0;

	mov	QWORD PTR stats$[rsp], rsi
	vxorpd	xmm7, xmm7, xmm7

; 28   : 	only_ints = 0;

	vmovsd	QWORD PTR stats$[rbp-216], xmm7
; File C:\Users\Petr\Desktop\PPR\src\utils\timer.cpp

; 5    : 	time = 0;

	mov	QWORD PTR ?t@@3VTimer@@A+16, rsi
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp

; 27   : 	if (!input_file)

	mov	rax, QWORD PTR input_file$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 329  :         return rdstate() & (ios_base::badbit | ios_base::failbit);

	test	BYTE PTR input_file$[rbp+rcx-240], 6
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp

; 27   : 	if (!input_file)

	je	SHORT $LN11@read_and_a

; 28   : 	{
; 29   : 		std::wcout << "File failed to open" << std::endl;

	lea	rdx, OFFSET FLAT:??_C@_0BE@KGFJJEOF@File?5failed?5to?5open@
	mov	rcx, QWORD PTR __imp_?wcout@std@@3V?$basic_ostream@_WU?$char_traits@_W@std@@@1@A
	vzeroupper
	call	??$?6_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@PEBD@Z ; std::operator<<<wchar_t,std::char_traits<wchar_t> >
	lea	rdx, OFFSET FLAT:??$endl@_WU?$char_traits@_W@std@@@std@@YAAEAV?$basic_ostream@_WU?$char_traits@_W@std@@@0@AEAV10@@Z ; std::endl<wchar_t,std::char_traits<wchar_t> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@_WU?$char_traits@_W@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
$LN11@read_and_a:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 575  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

	vzeroupper
	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 576  :             const long long _Ctr  = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 577  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 578  :             const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rbx
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 579  :             const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 580  :             return time_point(duration(_Whole + _Part));

	add	rcx, rax
	mov	QWORD PTR ?t@@3VTimer@@A, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3264 :         return _Get_data()._Mysize;

	mov	rcx, QWORD PTR [r12+16]

; 2023 :         const value_type* _Result = _Bx._Buf;

	mov	rax, r12

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [r12+24], 16

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN251@read_and_a
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rax, QWORD PTR [r12]
$LN251@read_and_a:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 199  :             return _Convert_narrow_to_wide(__std_fs_code_page(), _Input);

	mov	QWORD PTR $T65[rbp-256], rax
	mov	QWORD PTR $T65[rbp-248], rcx
	call	__std_fs_code_page
	lea	r8, QWORD PTR $T65[rbp-256]
	mov	edx, eax
	lea	rcx, QWORD PTR $T53[rsp]
	call	?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z ; std::filesystem::_Convert_narrow_to_wide

; 273  :         return _Convert_stringoid_to_wide(_Stringoid_from_Source(_Source), _Tag);

	mov	DWORD PTR $T1[rsp], 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR $T53[rsp]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR $T53[rsp+24], 8

; 2024 :         if (_Large_string_engaged()) {

	cmovae	rcx, QWORD PTR $T53[rsp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 3362 :         const auto _Error = __std_fs_get_stats(

	mov	r9d, -1					; ffffffffH
	mov	r8d, 9
	lea	rdx, QWORD PTR _Stats$183[rbp-256]
	call	__std_fs_get_stats

; 3363 :             _Path.c_str(), &_Stats, __std_fs_stats_flags::_Follow_symlinks | __std_fs_stats_flags::_File_size);
; 3364 :         if (_Error == __std_win_error::_Success) {

	test	eax, eax
	jne	$LN662@read_and_a
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T53[rsp+24]
	cmp	rdx, 8

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN322@read_and_a
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rdx*2+2]
	mov	rcx, QWORD PTR $T53[rsp]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN332@read_and_a

; 107  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN332@read_and_a
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN332@read_and_a:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN322@read_and_a:
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp

; 39   : 	for (int i = 0; i < filesize / buffer_size; i++)

	mov	eax, 1374389535				; 51eb851fH
	mul	DWORD PTR _Stats$183[rbp-248]
	shr	edx, 8
	test	edx, edx
	je	SHORT $LN3@read_and_a
	mov	r13d, edx
	npad	9
$LL4@read_and_a:

; 40   : 	{
; 41   : 		input_file.read(buffer.data(), buffer_size);

	mov	r8d, 800				; 00000320H
	mov	rdx, rdi
	lea	rcx, QWORD PTR input_file$[rbp-256]
	call	QWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z

; 42   : 		const int end = input_file.gcount() / sizeof(double);

	mov	rax, QWORD PTR input_file$[rbp-248]
	shr	rax, 3
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1260 :         return _Unfancy_maybe_null(_Myfirst());

	mov	rbx, rsi
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp

; 46   : 		for (int i = 0; i < end; i++)

	movsxd	rsi, eax
	test	eax, eax
	jle	SHORT $LN2@read_and_a
	npad	11
$LL7@read_and_a:

; 47   : 		{
; 48   : 			const double number = double_values[i];
; 49   : 			//test[i] = number * 2;
; 50   : 			//auto double_class = std::fpclassify(number);
; 51   : 			//result.doubles.push_back(number);
; 52   : 			stats.push(number);

	vmovsd	xmm1, QWORD PTR [rdi+rbx*8]
	lea	rcx, QWORD PTR stats$[rsp]
	call	?push@Stats@@QEAAXN@Z			; Stats::push

; 46   : 		for (int i = 0; i < end; i++)

	inc	rbx
	cmp	rbx, rsi
	jl	SHORT $LL7@read_and_a
$LN2@read_and_a:

; 39   : 	for (int i = 0; i < filesize / buffer_size; i++)

	sub	r13, 1
	mov	esi, 0
	jne	SHORT $LL4@read_and_a
	mov	r13, QWORD PTR buffer$[rbp-240]
$LN3@read_and_a:

; 53   : 			//result.valid_doubles++;
; 54   : 			/*if (double_class == FP_NORMAL || FP_ZERO)
; 55   : 			{
; 56   : 
; 57   : 				result.doubles.push_back(number);
; 58   : 				stats.push(number);
; 59   : 				result.valid_doubles++;
; 60   : 			}
; 61   : 			else
; 62   : 			{
; 63   : 				result.invalid++;
; 64   : 			}*/
; 65   : 		}
; 66   : 	}
; 67   : 	if (input_file.gcount() == 0)

	cmp	QWORD PTR input_file$[rbp-248], 0
	je	$LN9@read_and_a

; 68   : 	{
; 69   : 		;
; 70   : 	}
; 71   : 	else
; 72   : 	{
; 73   : 		input_file.read(buffer.data(), buffer_size);

	mov	r8d, 800				; 00000320H
	mov	rdx, rdi
	lea	rcx, QWORD PTR input_file$[rbp-256]
	call	QWORD PTR __imp_?read@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@PEAD_J@Z

; 74   : 
; 75   : 		double* double_values = (double*)buffer.data();
; 76   : 
; 77   : 		for (int i = 0; i < input_file.gcount() / sizeof(double); i++)

	test	QWORD PTR input_file$[rbp-248], -8
	jbe	$LN9@read_and_a
	mov	rbx, rdi
	npad	8
$LL10@read_and_a:

; 78   : 		{
; 79   : 			double number = double_values[i];

	vmovsd	xmm6, QWORD PTR [rbx]
	vmovsd	QWORD PTR number$182[rbp-256], xmm6

; 80   : 			auto double_class = std::fpclassify(number);

	vmovsd	QWORD PTR _X$[rbp-256], xmm6
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\corecrt_math.h

; 297  :         return _dtest(&_X);

	lea	rcx, QWORD PTR _X$[rbp-256]
	call	QWORD PTR __imp__dtest
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp

; 81   : 			if (double_class == FP_NORMAL || FP_ZERO)

	cmp	ax, -1
	je	SHORT $LN16@read_and_a

; 87   : 			}
; 88   : 			else
; 89   : 			{
; 90   : 				result.invalid++;

	inc	DWORD PTR [r14+4]
	jmp	SHORT $LN8@read_and_a
$LN16@read_and_a:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1357 :         return _Myend() != _Mylast();

	mov	rdx, QWORD PTR [r14+16]

; 637  :         if (_Has_unused_capacity()) {

	cmp	QWORD PTR [r14+24], rdx
	je	SHORT $LN399@read_and_a
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	vmovsd	QWORD PTR [rdx], xmm6
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 625  :         ++_Mylast();

	lea	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [r14+16], rax

; 638  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);

	jmp	SHORT $LN398@read_and_a
$LN399@read_and_a:

; 639  :         }
; 640  : 
; 641  :         _Ty& _Result = *_Emplace_reallocate(_Mylast(), _STD forward<_Valty>(_Val)...);

	lea	r8, QWORD PTR number$182[rbp-256]
	lea	rcx, QWORD PTR [r14+8]
	call	??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z ; std::vector<double,std::allocator<double> >::_Emplace_reallocate<double const &>
	vmovsd	xmm6, QWORD PTR number$182[rbp-256]
$LN398@read_and_a:
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp

; 85   : 				stats.push(number);

	vmovaps	xmm1, xmm6
	lea	rcx, QWORD PTR stats$[rsp]
	call	?push@Stats@@QEAAXN@Z			; Stats::push

; 86   : 				result.valid_doubles++;

	inc	DWORD PTR [r14]
$LN8@read_and_a:

; 74   : 
; 75   : 		double* double_values = (double*)buffer.data();
; 76   : 
; 77   : 		for (int i = 0; i < input_file.gcount() / sizeof(double); i++)

	inc	esi
	add	rbx, 8
	mov	rcx, QWORD PTR input_file$[rbp-248]
	shr	rcx, 3
	movsxd	rax, esi
	cmp	rax, rcx
	jb	$LL10@read_and_a
$LN9@read_and_a:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 575  :             const long long _Freq = _Query_perf_frequency(); // doesn't change after system boot

	call	QWORD PTR __imp__Query_perf_frequency
	mov	rbx, rax

; 576  :             const long long _Ctr  = _Query_perf_counter();

	call	QWORD PTR __imp__Query_perf_counter

; 577  :             static_assert(period::num == 1, "This assumes period::num == 1.");
; 578  :             const long long _Whole = (_Ctr / _Freq) * period::den;

	cdq
	idiv	rbx
	imul	rcx, rax, 1000000000			; 3b9aca00H

; 579  :             const long long _Part  = (_Ctr % _Freq) * period::den / _Freq;

	imul	rax, rdx, 1000000000			; 3b9aca00H
	cdq
	idiv	rbx

; 580  :             return time_point(duration(_Whole + _Part));

	add	rcx, rax
; File C:\Users\Petr\Desktop\PPR\src\utils\timer.cpp

; 15   : 	end_value = std::chrono::high_resolution_clock::now();

	mov	QWORD PTR ?t@@3VTimer@@A+8, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 249  :         return _CD(_CD(_Left).count() - _CD(_Right).count());

	sub	rcx, QWORD PTR ?t@@3VTimer@@A

; 372  :         return _Num_is_one && _Den_is_one

	mov	rbx, 2361183241434822607		; 20c49ba5e353f7cfH
	mov	rax, rbx
	imul	rcx
	sar	rdx, 7
	mov	rax, rdx
	shr	rax, 63					; 0000003fH
	add	rdx, rax
; File C:\Users\Petr\Desktop\PPR\src\utils\timer.cpp

; 17   : 	time = temp_time.count();

	mov	QWORD PTR ?t@@3VTimer@@A+16, rdx
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp

; 96   : 	std::cout << "stats mean " << stats.mean() << " kurtosis " << stats.kurtosis() << " only ints " << stats.only_integers()

	lea	rdx, OFFSET FLAT:??_C@_0M@FGOCKPMK@stats?5mean?5@
	mov	rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	vmovsd	xmm1, QWORD PTR stats$[rsp+8]
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_0L@LFEILHLO@?5kurtosis?5@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	rdx, rax
; File C:\Users\Petr\Desktop\PPR\src\utils\stats.cpp

; 38   : 	return static_cast<double>(n)* m4 / (m2 * m2) - 3.0;

	mov	rcx, QWORD PTR stats$[rsp]
	vxorps	xmm0, xmm0, xmm0
	test	rcx, rcx
	js	SHORT $LN657@read_and_a
	vcvtsi2sd xmm0, xmm0, rcx
	jmp	SHORT $LN658@read_and_a
$LN657@read_and_a:
	mov	rax, rcx
	shr	rax, 1
	and	ecx, 1
	or	rax, rcx
	vcvtsi2sd xmm0, xmm0, rax
	vaddsd	xmm0, xmm0, xmm0
$LN658@read_and_a:
	vmulsd	xmm2, xmm0, QWORD PTR stats$[rsp+32]
	vmovsd	xmm0, QWORD PTR stats$[rsp+16]
	vmulsd	xmm1, xmm0, xmm0
	vdivsd	xmm2, xmm2, xmm1
	vsubsd	xmm1, xmm2, QWORD PTR __real@4008000000000000
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp

; 96   : 	std::cout << "stats mean " << stats.mean() << " kurtosis " << stats.kurtosis() << " only ints " << stats.only_integers()

	mov	rcx, rdx
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_0M@HIHLCHBM@?5only?5ints?5@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
; File C:\Users\Petr\Desktop\PPR\src\utils\stats.cpp

; 43   : 	bool result = false;

	xor	dl, dl

; 44   : 	if (only_ints == 0)

	vmovsd	xmm0, QWORD PTR stats$[rbp-216]
	vucomisd xmm0, xmm7
	jp	SHORT $LN526@read_and_a
	jne	SHORT $LN526@read_and_a

; 45   : 	{
; 46   : 		result = true;

	mov	dl, 1
$LN526@read_and_a:
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp

; 96   : 	std::cout << "stats mean " << stats.mean() << " kurtosis " << stats.kurtosis() << " only ints " << stats.only_integers()

	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@_N@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_07IFFFBIED@?5time?3?5@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	edx, DWORD PTR ?t@@3VTimer@@A+16
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
	mov	rcx, rax
	lea	rdx, OFFSET FLAT:??_C@_09BCDLOFHA@?5us?5time?5@
	call	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
	mov	r8, rax
; File C:\Users\Petr\Desktop\PPR\src\utils\timer.cpp

; 27   : 	return time / 1000;

	mov	rax, rbx
	imul	QWORD PTR ?t@@3VTimer@@A+16
	sar	rdx, 7
	mov	rcx, rdx
	shr	rcx, 63					; 0000003fH
	add	rdx, rcx
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp

; 96   : 	std::cout << "stats mean " << stats.mean() << " kurtosis " << stats.kurtosis() << " only ints " << stats.only_integers()

	mov	rcx, r8
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
	lea	rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
	mov	rcx, rax
	call	QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
; File C:\Users\Petr\Desktop\PPR\src\utils\timer.cpp

; 5    : 	time = 0;

	xor	ebx, ebx
	mov	QWORD PTR ?t@@3VTimer@@A+16, rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1526 :         if (_First != pointer()) { // destroy and deallocate old array

	test	rdi, rdi
	je	SHORT $LN537@read_and_a

; 1527 :             _Destroy(_First, _My_data._Mylast);
; 1528 :             _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));

	sub	r13, rdi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	r13, 4096				; 00001000H
	jb	SHORT $LN577@read_and_a

; 107  :     _Bytes += _Non_user_size;

	add	r13, 39					; 00000027H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdi-8]

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rdi, rcx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rdi-8]
	cmp	rax, 31
	ja	$LN574@read_and_a

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rdi, rcx
$LN577@read_and_a:

; 195  :     ::operator delete(_Ptr, _Bytes);

	mov	rdx, r13
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN537@read_and_a:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 906  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept { // destroy the object

	mov	rax, QWORD PTR input_file$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR input_file$[rbp+rcx-256], rax
	mov	rax, QWORD PTR input_file$[rbp-256]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-176]
	mov	DWORD PTR input_file$[rbp+rcx-260], edx

; 907  :     }

	lea	rcx, QWORD PTR input_file$[rbp-240]
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	rcx, QWORD PTR input_file$[rbp-232]
	call	QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	lea	rcx, QWORD PTR input_file$[rbp-80]
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
	npad	1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [r12+24]
	cmp	rdx, 16

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN619@read_and_a

; 3872 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 3873 :             auto& _Al          = _Getal();
; 3874 :             _Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [r12]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN629@read_and_a

; 107  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN626@read_and_a

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN629@read_and_a:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN619@read_and_a:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	mov	QWORD PTR [r12+16], rbx

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [r12+24], 15

; 343  :         _Left = _Right;

	mov	BYTE PTR [r12], 0
; File C:\Users\Petr\Desktop\PPR\src\naive\naive.cpp

; 99   : 	return result;

	mov	rax, r14

; 100  : }

	mov	rcx, QWORD PTR __$ArrayPad$[rbp-256]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+544]
	mov	rbx, QWORD PTR [r11+80]
	vmovaps	xmm6, XMMWORD PTR [r11-16]
	vmovaps	xmm7, XMMWORD PTR [r11-32]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN574@read_and_a:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN626@read_and_a:
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN662@read_and_a:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 3377 :             _Throw_fs_error("file_size", _Error, _Path);

	lea	r8, QWORD PTR $T53[rsp]
	mov	edx, eax
	call	?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z ; std::filesystem::_Throw_fs_error
	int	3
$LN660@read_and_a:
?read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; read_and_analyze_file
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T53 = 56
stats$ = 88
$T181 = 136
__$ReturnUdt$GSCopy$ = 144
filename$GSCopy$ = 152
input_file$ = 160
number$182 = 432
_X$ = 448
_Stats$183 = 448
$T65 = 448
buffer$ = 480
__$ArrayPad$ = 504
__$ReturnUdt$ = 608
filename$ = 616
?dtor$0@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `read_and_analyze_file'::`1'::dtor$0
	mov	rcx, QWORD PTR filename$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `read_and_analyze_file'::`1'::dtor$0
$T1 = 48
$T53 = 56
stats$ = 88
$T181 = 136
__$ReturnUdt$GSCopy$ = 144
filename$GSCopy$ = 152
input_file$ = 160
number$182 = 432
_X$ = 448
_Stats$183 = 448
$T65 = 448
buffer$ = 480
__$ArrayPad$ = 504
__$ReturnUdt$ = 608
filename$ = 616
?dtor$1@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `read_and_analyze_file'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN20@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1Numbers@@QEAA@XZ
$LN20@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `read_and_analyze_file'::`1'::dtor$1
$T1 = 48
$T53 = 56
stats$ = 88
$T181 = 136
__$ReturnUdt$GSCopy$ = 144
filename$GSCopy$ = 152
input_file$ = 160
number$182 = 432
_X$ = 448
_Stats$183 = 448
$T65 = 448
buffer$ = 480
__$ArrayPad$ = 504
__$ReturnUdt$ = 608
filename$ = 616
?dtor$2@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `read_and_analyze_file'::`1'::dtor$2
	lea	rcx, QWORD PTR input_file$[rdx]
	jmp	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$2@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `read_and_analyze_file'::`1'::dtor$2
$T1 = 48
$T53 = 56
stats$ = 88
$T181 = 136
__$ReturnUdt$GSCopy$ = 144
filename$GSCopy$ = 152
input_file$ = 160
number$182 = 432
_X$ = 448
_Stats$183 = 448
$T65 = 448
buffer$ = 480
__$ArrayPad$ = 504
__$ReturnUdt$ = 608
filename$ = 616
?dtor$3@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `read_and_analyze_file'::`1'::dtor$3
	lea	rcx, QWORD PTR buffer$[rdx]
	jmp	??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
?dtor$3@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `read_and_analyze_file'::`1'::dtor$3
$T1 = 48
$T53 = 56
stats$ = 88
$T181 = 136
__$ReturnUdt$GSCopy$ = 144
filename$GSCopy$ = 152
input_file$ = 160
number$182 = 432
_X$ = 448
_Stats$183 = 448
$T65 = 448
buffer$ = 480
__$ArrayPad$ = 504
__$ReturnUdt$ = 608
filename$ = 616
?dtor$4@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `read_and_analyze_file'::`1'::dtor$4
	lea	rcx, QWORD PTR $T53[rdx]
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$4@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `read_and_analyze_file'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T53 = 56
stats$ = 88
$T181 = 136
__$ReturnUdt$GSCopy$ = 144
filename$GSCopy$ = 152
input_file$ = 160
number$182 = 432
_X$ = 448
_Stats$183 = 448
$T65 = 448
buffer$ = 480
__$ArrayPad$ = 504
__$ReturnUdt$ = 608
filename$ = 616
?dtor$0@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `read_and_analyze_file'::`1'::dtor$0
	mov	rcx, QWORD PTR filename$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `read_and_analyze_file'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T53 = 56
stats$ = 88
$T181 = 136
__$ReturnUdt$GSCopy$ = 144
filename$GSCopy$ = 152
input_file$ = 160
number$182 = 432
_X$ = 448
_Stats$183 = 448
$T65 = 448
buffer$ = 480
__$ArrayPad$ = 504
__$ReturnUdt$ = 608
filename$ = 616
?dtor$1@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `read_and_analyze_file'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN20@dtor$1
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1Numbers@@QEAA@XZ
$LN20@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `read_and_analyze_file'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T53 = 56
stats$ = 88
$T181 = 136
__$ReturnUdt$GSCopy$ = 144
filename$GSCopy$ = 152
input_file$ = 160
number$182 = 432
_X$ = 448
_Stats$183 = 448
$T65 = 448
buffer$ = 480
__$ArrayPad$ = 504
__$ReturnUdt$ = 608
filename$ = 616
?dtor$2@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `read_and_analyze_file'::`1'::dtor$2
	lea	rcx, QWORD PTR input_file$[rdx]
	jmp	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$2@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `read_and_analyze_file'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T53 = 56
stats$ = 88
$T181 = 136
__$ReturnUdt$GSCopy$ = 144
filename$GSCopy$ = 152
input_file$ = 160
number$182 = 432
_X$ = 448
_Stats$183 = 448
$T65 = 448
buffer$ = 480
__$ArrayPad$ = 504
__$ReturnUdt$ = 608
filename$ = 616
?dtor$3@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `read_and_analyze_file'::`1'::dtor$3
	lea	rcx, QWORD PTR buffer$[rdx]
	jmp	??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ ; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
?dtor$3@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `read_and_analyze_file'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T53 = 56
stats$ = 88
$T181 = 136
__$ReturnUdt$GSCopy$ = 144
filename$GSCopy$ = 152
input_file$ = 160
number$182 = 432
_X$ = 448
_Stats$183 = 448
$T65 = 448
buffer$ = 480
__$ArrayPad$ = 504
__$ReturnUdt$ = 608
filename$ = 616
?dtor$4@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `read_and_analyze_file'::`1'::dtor$4
	lea	rcx, QWORD PTR $T53[rdx]
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$4@?0??read_and_analyze_file@@YA?AUNumbers@@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `read_and_analyze_file'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
;	COMDAT wmemcpy
_TEXT	SEGMENT
_S1$ = 48
_S2$ = 56
_N$ = 64
wmemcpy	PROC						; COMDAT

; 230  :     {

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 231  :         #pragma warning(push)
; 232  :         #pragma warning(disable : 4995 4996 6386)
; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	add	r8, r8
	mov	rbx, rcx
	call	memcpy
	mov	rax, rbx

; 234  :         #pragma warning(pop)
; 235  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
wmemcpy	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
;	COMDAT wmemset
_TEXT	SEGMENT
_S$ = 16
_C$dead$ = 24
_N$ = 32
wmemset	PROC						; COMDAT

; 257  :     {

$LN12:
	sub	rsp, 8
	mov	rdx, rcx

; 258  :         wchar_t *_Su = _S;
; 259  :         for (; 0 < _N; ++_Su, --_N)

	test	r8, r8
	je	SHORT $LN10@wmemset
	mov	QWORD PTR [rsp], rdi
	xor	eax, eax
	mov	rdi, rcx
	movzx	eax, ax
	mov	rcx, r8
	rep stosw

; 260  :         {
; 261  :             *_Su = _C;
; 262  :         }
; 263  :         return _S;

	mov	rdi, QWORD PTR [rsp]
$LN10@wmemset:

; 264  :     }

	mov	rax, rdx
	add	rsp, 8
	ret	0
wmemset	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\corecrt_math.h
;	COMDAT ?fpclassify@@YAHN@Z
_TEXT	SEGMENT
_X$GSCopy$ = 32
__$ArrayPad$ = 40
_X$ = 64
?fpclassify@@YAHN@Z PROC				; fpclassify, COMDAT

; 296  :     {

$LN5:
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 297  :         return _dtest(&_X);

	lea	rcx, QWORD PTR _X$GSCopy$[rsp]
	vmovsd	QWORD PTR _X$GSCopy$[rsp], xmm0
	call	QWORD PTR __imp__dtest
	cwde

; 298  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
?fpclassify@@YAHN@Z ENDP				; fpclassify
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
_InitData$ = 32
__$ArrayPad$ = 48
this$ = 80
_Message$ = 88
??0exception@std@@QEAA@QEBD@Z PROC			; std::exception::exception, COMDAT

; 55   :     {

$LN5:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	r8, rdx

; 56   :         __std_exception_data _InitData = { _Message, true };

	mov	BYTE PTR _InitData$[rsp+8], 1
	lea	rdx, QWORD PTR [rcx+8]
	mov	QWORD PTR _InitData$[rsp], r8
	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rbx, rcx
	mov	QWORD PTR [rcx], rax

; 57   :         __std_exception_copy(&_InitData, &_Data);

	lea	rcx, QWORD PTR _InitData$[rsp]
	vpxor	xmm0, xmm0, xmm0
	vmovups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy

; 58   :     }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
??0exception@std@@QEAA@QEBD@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 1248 :     }

	ret	0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z PROC ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl, COMDAT

; 1448 :     _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept {}

	mov	rax, rcx
	ret	0
??0_Fake_proxy_ptr_impl@std@@QEAA@AEBU_Fake_allocator@1@AEBU_Container_base0@1@@Z ENDP ; std::_Fake_proxy_ptr_impl::_Fake_proxy_ptr_impl
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ PROC	; std::_Fake_proxy_ptr_impl::_Release, COMDAT

; 1451 :     void _Release() noexcept {}

	ret	0
?_Release@_Fake_proxy_ptr_impl@std@@QEAAXXZ ENDP	; std::_Fake_proxy_ptr_impl::_Release
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Ch$dead$ = 64
?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z PROC	; std::char_traits<char>::assign, COMDAT

; 337  :         _Out_writes_all_(_Count) char* const _First, const size_t _Count, const char _Ch) noexcept { // strengthened

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H

; 338  :         // assign _Count * _Ch to [_First, ...)
; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8, rdx
	mov	rbx, rcx
	xor	edx, edx
	call	memset
	mov	rax, rbx

; 340  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z ENDP	; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHAEBH@Z
_TEXT	SEGMENT
_Meta$ = 8
?not_eof@?$char_traits@D@std@@SAHAEBH@Z PROC		; std::char_traits<char>::not_eof, COMDAT

; 369  :     _NODISCARD static constexpr int_type not_eof(const int_type& _Meta) noexcept { // return anything but EOF

	mov	eax, DWORD PTR [rcx]

; 370  :         return _Meta != eof() ? _Meta : !eof();

	xor	ecx, ecx
	cmp	eax, -1
	cmove	eax, ecx

; 371  :     }

	ret	0
?not_eof@?$char_traits@D@std@@SAHAEBH@Z ENDP		; std::char_traits<char>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@3@PEBD_K@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Str$ = 16
_Len$ = 24
??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@3@PEBD_K@Z PROC ; std::literals::string_view_literals::operator "" sv, COMDAT

; 1140 :         : _Mydata(_Cts),

	mov	QWORD PTR [rcx], rdx

; 1671 :             return string_view(_Str, _Len);

	mov	rax, rcx

; 1141 :           _Mysize(_Count) { // construct basic_string_view around a character-type sequence with explicit size

	mov	QWORD PTR [rcx+8], r8

; 1672 :         }

	ret	0
??__Ksv@string_view_literals@literals@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@3@PEBD_K@Z ENDP ; std::literals::string_view_literals::operator "" sv
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept
;	COMDAT ??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
_InitData$4 = 32
__$ArrayPad$ = 48
this$ = 80
_Message$ = 88
??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::runtime_error::runtime_error, COMDAT

; 126  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string

$LN20:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept

; 126  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string

	mov	r8, rdx
	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN10@runtime_er
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	r8, QWORD PTR [rdx]
$LN10@runtime_er:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 54   :         : _Data()

	lea	rdx, QWORD PTR [rcx+8]

; 55   :     {
; 56   :         __std_exception_data _InitData = { _Message, true };

	mov	QWORD PTR _InitData$4[rsp], r8
	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	BYTE PTR _InitData$4[rsp+8], 1
	mov	QWORD PTR [rcx], rax

; 57   :         __std_exception_copy(&_InitData, &_Data);

	lea	rcx, QWORD PTR _InitData$4[rsp]
	vpxor	xmm0, xmm0, xmm0

; 54   :         : _Data()

	vmovups	XMMWORD PTR [rdx], xmm0

; 57   :         __std_exception_copy(&_InitData, &_Data);

	call	QWORD PTR __imp___std_exception_copy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept

; 126  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string

	lea	rax, OFFSET FLAT:??_7runtime_error@std@@6B@
	mov	QWORD PTR [rbx], rax

; 127  :     }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
??0runtime_error@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??_Gruntime_error@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gruntime_error@std@@UEAAPEAXI@Z PROC			; std::runtime_error::`scalar deleting destructor', COMDAT
$LN12:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 85   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 86   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN9@scalar
	mov	edx, 24
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN9@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gruntime_error@std@@UEAAPEAXI@Z ENDP			; std::runtime_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??1runtime_error@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1runtime_error@std@@UEAA@XZ PROC			; std::runtime_error::~runtime_error, COMDAT

; 85   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 86   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1runtime_error@std@@UEAA@XZ ENDP			; std::runtime_error::~runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0error_category@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0error_category@std@@QEAA@XZ PROC			; std::error_category::error_category, COMDAT

; 66   :         // default constructor
; 67   :         _Addr = reinterpret_cast<uintptr_t>(this);

	mov	QWORD PTR [rcx+8], rcx

; 68   :     }

	mov	rax, rcx
	ret	0
??0error_category@std@@QEAA@XZ ENDP			; std::error_category::error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??1error_category@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1error_category@std@@UEAA@XZ PROC			; std::error_category::~error_category, COMDAT

; 70   :     virtual ~error_category() noexcept {}

	ret	0
??1error_category@std@@UEAA@XZ ENDP			; std::error_category::~error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??8error_category@std@@QEBA_NAEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??8error_category@std@@QEBA_NAEBV01@@Z PROC		; std::error_category::operator==, COMDAT

; 83   :         return _Addr == _Right._Addr;

	mov	rax, QWORD PTR [rdx+8]
	cmp	QWORD PTR [rcx+8], rax
	sete	al

; 84   :     }

	ret	0
??8error_category@std@@QEBA_NAEBV01@@Z ENDP		; std::error_category::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0error_code@std@@QEAA@HAEBVerror_category@1@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
_Cat$ = 24
??0error_code@std@@QEAA@HAEBVerror_category@1@@Z PROC	; std::error_code::error_code, COMDAT

; 115  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	DWORD PTR [rcx], edx

; 116  :     }

	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0error_code@std@@QEAA@HAEBVerror_category@1@@Z ENDP	; std::error_code::error_code
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?value@error_code@std@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?value@error_code@std@@QEBAHXZ PROC			; std::error_code::value, COMDAT

; 141  :         return _Myval;

	mov	eax, DWORD PTR [rcx]

; 142  :     }

	ret	0
?value@error_code@std@@QEBAHXZ ENDP			; std::error_code::value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?category@error_code@std@@QEBAAEBVerror_category@2@XZ
_TEXT	SEGMENT
this$ = 8
?category@error_code@std@@QEBAAEBVerror_category@2@XZ PROC ; std::error_code::category, COMDAT

; 145  :         return *_Mycat;

	mov	rax, QWORD PTR [rcx+8]

; 146  :     }

	ret	0
?category@error_code@std@@QEBAAEBVerror_category@2@XZ ENDP ; std::error_code::category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::error_code::message, COMDAT

; 150  :     _NODISCARD string message() const { // get name of error code

$LN11:
	push	rbx
	sub	rsp, 32					; 00000020H

; 145  :         return *_Mycat;

	mov	rax, QWORD PTR [rcx+8]

; 150  :     _NODISCARD string message() const { // get name of error code

	mov	rbx, rdx

; 151  :         return category().message(value());

	mov	r8d, DWORD PTR [rcx]
	mov	rcx, rax
	mov	r9, QWORD PTR [rax]
	call	QWORD PTR [r9+16]
	mov	rax, rbx

; 152  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?message@error_code@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::error_code::message
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
_Cat$ = 24
??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z PROC ; std::error_condition::error_condition, COMDAT

; 170  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	DWORD PTR [rcx], edx

; 171  :     }

	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0error_condition@std@@QEAA@HAEBVerror_category@1@@Z ENDP ; std::error_condition::error_condition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?value@error_condition@std@@QEBAHXZ
_TEXT	SEGMENT
this$ = 8
?value@error_condition@std@@QEBAHXZ PROC		; std::error_condition::value, COMDAT

; 196  :         return _Myval;

	mov	eax, DWORD PTR [rcx]

; 197  :     }

	ret	0
?value@error_condition@std@@QEBAHXZ ENDP		; std::error_condition::value
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?category@error_condition@std@@QEBAAEBVerror_category@2@XZ
_TEXT	SEGMENT
this$ = 8
?category@error_condition@std@@QEBAAEBVerror_category@2@XZ PROC ; std::error_condition::category, COMDAT

; 200  :         return *_Mycat;

	mov	rax, QWORD PTR [rcx+8]

; 201  :     }

	ret	0
?category@error_condition@std@@QEBAAEBVerror_category@2@XZ ENDP ; std::error_condition::category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??8std@@YA_NAEBVerror_condition@0@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??8std@@YA_NAEBVerror_condition@0@0@Z PROC		; std::operator==, COMDAT

; 83   :         return _Addr == _Right._Addr;

	mov	rax, QWORD PTR [rdx+8]
	mov	r9, QWORD PTR [rcx+8]
	mov	r8, QWORD PTR [rax+8]
	cmp	QWORD PTR [r9+8], r8

; 234  :     return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR [rdx]
	cmp	DWORD PTR [rcx], eax
	jne	SHORT $LN3@operator
	mov	al, 1

; 235  : }

	ret	0
$LN3@operator:

; 234  :     return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	xor	al, al

; 235  : }

	ret	0
??8std@@YA_NAEBVerror_condition@0@0@Z ENDP		; std::operator==
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
_Errval$ = 24
?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z PROC ; std::error_category::default_error_condition, COMDAT

; 170  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	DWORD PTR [rdx], r8d

; 273  :     return error_condition(_Errval, *this);

	mov	rax, rdx

; 170  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	QWORD PTR [rdx+8], rcx

; 274  : }

	ret	0
?default_error_condition@error_category@std@@UEBA?AVerror_condition@2@H@Z ENDP ; std::error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Errval$ = 72
_Cond$ = 80
?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z PROC ; std::error_category::equivalent, COMDAT

; 277  :     noexcept { // test if error code same condition

$LN19:
	push	rbx
	sub	rsp, 48					; 00000030H

; 278  :     return default_error_condition(_Errval) == _Cond;

	mov	rax, QWORD PTR [rcx]
	mov	rbx, r8
	mov	r8d, edx
	lea	rdx, QWORD PTR $T1[rsp]
	call	QWORD PTR [rax+24]

; 83   :         return _Addr == _Right._Addr;

	mov	rcx, QWORD PTR [rbx+8]
	mov	r9, QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [r9+8], rdx

; 234  :     return _Left.category() == _Right.category() && _Left.value() == _Right.value();

	jne	SHORT $LN5@equivalent
	mov	ecx, DWORD PTR [rbx]
	cmp	DWORD PTR [rax], ecx
	jne	SHORT $LN5@equivalent

; 278  :     return default_error_condition(_Errval) == _Cond;

	mov	al, 1

; 279  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
$LN5@equivalent:

; 278  :     return default_error_condition(_Errval) == _Cond;

	xor	al, al

; 279  : }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
?equivalent@error_category@std@@UEBA_NHAEBVerror_condition@2@@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z
_TEXT	SEGMENT
this$ = 8
_Code$ = 16
_Errval$ = 24
?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z PROC ; std::error_category::equivalent, COMDAT

; 83   :         return _Addr == _Right._Addr;

	mov	rax, QWORD PTR [rdx+8]
	mov	r9, QWORD PTR [rax+8]
	cmp	QWORD PTR [rcx+8], r9

; 283  :     return *this == _Code.category() && _Code.value() == _Errval;

	jne	SHORT $LN3@equivalent
	cmp	DWORD PTR [rdx], r8d
	jne	SHORT $LN3@equivalent
	mov	al, 1

; 284  : }

	ret	0
$LN3@equivalent:

; 283  :     return *this == _Code.category() && _Code.value() == _Errval;

	xor	al, al

; 284  : }

	ret	0
?equivalent@error_category@std@@UEBA_NAEBVerror_code@2@H@Z ENDP ; std::error_category::equivalent
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_Errno$dead$ = 56
?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z PROC ; std::make_error_code, COMDAT

; 293  : _NODISCARD inline error_code make_error_code(errc _Errno) noexcept { // make an error_code

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 507  :         == 0) { // _Execute_once should never fail if the callback never fails

	lea	rdi, OFFSET FLAT:?_Storage@?1???$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A ; `std::_Immortalize<std::_Generic_error_category>'::`2'::_Storage
	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??$_Immortalize_impl@V_Generic_error_category@std@@@std@@YAHPEAX0PEAPEAX@Z ; std::_Immortalize_impl<std::_Generic_error_category>
	lea	rcx, OFFSET FLAT:?_Flag@?1???$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@1@XZ@4PEAXEA ; `std::_Immortalize<std::_Generic_error_category>'::`2'::_Flag
	call	QWORD PTR __imp_?_Execute_once@std@@YAHAEAUonce_flag@1@P6AHPEAX1PEAPEAX@Z1@Z
	test	eax, eax
	jne	SHORT $LN6@make_error

; 508  :         _STD terminate();

	call	QWORD PTR __imp_terminate
	int	3
$LN6@make_error:

; 115  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	DWORD PTR [rbx], 22

; 294  :     return error_code((int) _Errno, generic_category());

	mov	rax, rbx

; 115  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	QWORD PTR [rbx+8], rdi

; 295  : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN12@make_error:
?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z ENDP ; std::make_error_code
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z
_TEXT	SEGMENT
$T10 = 32
$T39 = 64
_Message$GSCopy$ = 72
__$ReturnUdt$GSCopy$ = 72
__$ArrayPad$ = 80
__$ReturnUdt$ = 128
_Errcode$ = 136
_Message$ = 144
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z PROC ; std::_System_error::_Makestr, COMDAT

; 336  :     static string _Makestr(error_code _Errcode, string _Message) { // compose error message

$LN204:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	QWORD PTR $T39[rsp], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, r8
	mov	rsi, rdx
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	QWORD PTR _Message$GSCopy$[rsp], rbx

; 337  :         if (!_Message.empty()) {

	cmp	QWORD PTR [r8+16], 0
	je	SHORT $LN2@Makestr
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2627 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5@
	mov	rcx, rbx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2@Makestr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 145  :         return *_Mycat;

	mov	rcx, QWORD PTR [rsi+8]

; 151  :         return category().message(value());

	mov	rax, QWORD PTR [rcx]
	mov	r8d, DWORD PTR [rsi]
	lea	rdx, QWORD PTR $T10[rsp]
	call	QWORD PTR [rax+16]
	npad	1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR $T10[rsp]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR $T10[rsp+24], 16

; 2024 :         if (_Large_string_engaged()) {

	cmovae	rdx, QWORD PTR $T10[rsp]

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	mov	r8, QWORD PTR $T10[rsp+16]
	mov	rcx, rbx
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T10[rsp+24]
	cmp	rdx, 16

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN75@Makestr

; 3872 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 3873 :             auto& _Al          = _Getal();
; 3874 :             _Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T10[rsp]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN85@Makestr

; 107  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN85@Makestr
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN85@Makestr:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN75@Makestr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	xor	eax, eax
	mov	QWORD PTR [rdi+16], rax
	mov	QWORD PTR [rdi+24], rax

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [rbx]
	vmovups	YMMWORD PTR [rdi], ymm0

; 3878 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], rax

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 343  :         _Left = _Right;

	mov	BYTE PTR [rbx], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 342  :         return _Message;

	mov	rax, rdi
	vzeroupper

; 343  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN201@Makestr:
?_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z ENDP ; std::_System_error::_Makestr
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T10 = 32
$T39 = 64
_Message$GSCopy$ = 72
__$ReturnUdt$GSCopy$ = 72
__$ArrayPad$ = 80
__$ReturnUdt$ = 128
_Errcode$ = 136
_Message$ = 144
?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA PROC ; `std::_System_error::_Makestr'::`1'::dtor$0
	mov	rcx, QWORD PTR _Message$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA ENDP ; `std::_System_error::_Makestr'::`1'::dtor$0
$T10 = 32
$T39 = 64
_Message$GSCopy$ = 72
__$ReturnUdt$GSCopy$ = 72
__$ArrayPad$ = 80
__$ReturnUdt$ = 128
_Errcode$ = 136
_Message$ = 144
?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA PROC ; `std::_System_error::_Makestr'::`1'::dtor$1
	lea	rcx, QWORD PTR $T10[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA ENDP ; `std::_System_error::_Makestr'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T10 = 32
$T39 = 64
_Message$GSCopy$ = 72
__$ReturnUdt$GSCopy$ = 72
__$ArrayPad$ = 80
__$ReturnUdt$ = 128
_Errcode$ = 136
_Message$ = 144
?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA PROC ; `std::_System_error::_Makestr'::`1'::dtor$0
	mov	rcx, QWORD PTR _Message$GSCopy$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA ENDP ; `std::_System_error::_Makestr'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T10 = 32
$T39 = 64
_Message$GSCopy$ = 72
__$ReturnUdt$GSCopy$ = 72
__$ArrayPad$ = 80
__$ReturnUdt$ = 128
_Errcode$ = 136
_Message$ = 144
?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA PROC ; `std::_System_error::_Makestr'::`1'::dtor$1
	lea	rcx, QWORD PTR $T10[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??_Makestr@_System_error@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@Verror_code@2@V32@@Z@4HA ENDP ; `std::_System_error::_Makestr'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T4 = 32
this$GSCopy$ = 32
$T24 = 40
$T56 = 72
$T2 = 80
_InitData$57 = 112
$T15 = 112
$T6 = 112
__$ArrayPad$ = 144
this$ = 192
_Errcode$ = 200
_Message$ = 208
??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::_System_error::_System_error, COMDAT

; 348  :           _Mycode(_Errcode) { // construct from error code and message string

$LN284:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 160				; 000000a0H
	mov	QWORD PTR $T56[rsp], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, rdx
	mov	rbx, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx

; 338  :             _Message.append(": ");
; 339  :         }
; 340  : 
; 341  :         _Message.append(_Errcode.message());
; 342  :         return _Message;
; 343  :     }
; 344  : 
; 345  : protected:
; 346  :     _System_error(error_code _Errcode, const string& _Message)
; 347  :         : runtime_error(_Makestr(_Errcode, _Message)),

	mov	rdx, r8
	lea	rcx, QWORD PTR $T2[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	mov	rdi, rax
	mov	QWORD PTR $T4[rsp], rax
	vmovups	xmm0, XMMWORD PTR [rsi]
	vmovups	XMMWORD PTR $T6[rsp], xmm0

; 337  :         if (!_Message.empty()) {

	cmp	QWORD PTR [rax+16], 0
	je	SHORT $LN7@System_err
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2627 :         return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 2
	lea	rdx, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5@
	mov	rcx, rax
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN7@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 151  :         return category().message(value());

	mov	rcx, QWORD PTR $T6[rsp+8]
	mov	rax, QWORD PTR [rcx]
	mov	r8d, DWORD PTR $T6[rsp]
	lea	rdx, QWORD PTR $T15[rsp]
	call	QWORD PTR [rax+16]
	npad	1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR $T15[rsp]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR $T15[rsp+24], 16

; 2024 :         if (_Large_string_engaged()) {

	cmovae	rdx, QWORD PTR $T15[rsp]

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	mov	r8, QWORD PTR $T15[rsp+16]
	mov	rcx, rdi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	npad	1

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T15[rsp+24]
	cmp	rdx, 16

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN80@System_err

; 3872 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 3873 :             auto& _Al          = _Getal();
; 3874 :             _Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T15[rsp]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN90@System_err

; 107  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN90@System_err
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN90@System_err:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN80@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [rdi]
	vmovups	YMMWORD PTR $T24[rsp], ymm0

; 3878 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], 0

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 343  :         _Left = _Right;

	mov	BYTE PTR [rdi], 0

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR $T24[rsp]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR $T24[rsp+24], 16

; 2024 :         if (_Large_string_engaged()) {

	cmovae	rax, QWORD PTR $T24[rsp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 55   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rbx], rcx

; 54   :         : _Data()

	lea	rdx, QWORD PTR [rbx+8]
	vpxor	xmm0, xmm0, xmm0
	vmovups	XMMWORD PTR [rdx], xmm0

; 56   :         __std_exception_data _InitData = { _Message, true };

	mov	QWORD PTR _InitData$57[rsp], rax
	mov	BYTE PTR _InitData$57[rsp+8], 1

; 57   :         __std_exception_copy(&_InitData, &_Data);

	lea	rcx, QWORD PTR _InitData$57[rsp]
	vzeroupper
	call	QWORD PTR __imp___std_exception_copy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\stdexcept

; 126  :     explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str()) { // construct from message string

	lea	rax, OFFSET FLAT:??_7runtime_error@std@@6B@
	mov	QWORD PTR [rbx], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T24[rsp+24]
	cmp	rdx, 16

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN256@System_err

; 3872 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 3873 :             auto& _Al          = _Getal();
; 3874 :             _Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T24[rsp]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN266@System_err

; 107  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN266@System_err
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN266@System_err:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN256@System_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 348  :           _Mycode(_Errcode) { // construct from error code and message string

	lea	rax, OFFSET FLAT:??_7_System_error@std@@6B@
	mov	QWORD PTR [rbx], rax
	vmovups	xmm0, XMMWORD PTR [rsi]
	vmovups	XMMWORD PTR [rbx+24], xmm0

; 349  :     }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 160				; 000000a0H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN281@System_err:
??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::_System_error::_System_error
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
this$GSCopy$ = 32
$T24 = 40
$T56 = 72
$T2 = 80
_InitData$57 = 112
$T15 = 112
$T6 = 112
__$ArrayPad$ = 144
this$ = 192
_Errcode$ = 200
_Message$ = 208
?dtor$3@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::_System_error::_System_error'::`1'::dtor$3
	mov	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::_System_error::_System_error'::`1'::dtor$3
$T4 = 32
this$GSCopy$ = 32
$T24 = 40
$T56 = 72
$T2 = 80
_InitData$57 = 112
$T15 = 112
$T6 = 112
__$ArrayPad$ = 144
this$ = 192
_Errcode$ = 200
_Message$ = 208
?dtor$4@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::_System_error::_System_error'::`1'::dtor$4
	lea	rcx, QWORD PTR $T15[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::_System_error::_System_error'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
this$GSCopy$ = 32
$T24 = 40
$T56 = 72
$T2 = 80
_InitData$57 = 112
$T15 = 112
$T6 = 112
__$ArrayPad$ = 144
this$ = 192
_Errcode$ = 200
_Message$ = 208
?dtor$3@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::_System_error::_System_error'::`1'::dtor$3
	mov	rcx, QWORD PTR $T4[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::_System_error::_System_error'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
this$GSCopy$ = 32
$T24 = 40
$T56 = 72
$T2 = 80
_InitData$57 = 112
$T15 = 112
$T6 = 112
__$ArrayPad$ = 144
this$ = 192
_Errcode$ = 200
_Message$ = 208
?dtor$4@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA PROC ; `std::_System_error::_System_error'::`1'::dtor$4
	lea	rcx, QWORD PTR $T15[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0???0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z@4HA ENDP ; `std::_System_error::_System_error'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??_G_System_error@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_System_error@std@@UEAAPEAXI@Z PROC			; std::_System_error::`scalar deleting destructor', COMDAT
$LN15:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 85   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 86   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN12@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN12@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_G_System_error@std@@UEAAPEAXI@Z ENDP			; std::_System_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??1_System_error@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1_System_error@std@@UEAA@XZ PROC			; std::_System_error::~_System_error, COMDAT

; 85   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 86   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1_System_error@std@@UEAA@XZ ENDP			; std::_System_error::~_System_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0system_error@std@@QEAA@Verror_code@1@@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
$T10 = 32
$T1 = 48
this$ = 112
_Errcode$ = 120
??0system_error@std@@QEAA@Verror_code@1@@Z PROC		; std::system_error::system_error, COMDAT

; 359  :     system_error(error_code _Errcode) : _Mybase(_Errcode, "") { // construct from error code

$LN96:
	mov	rax, rsp
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	QWORD PTR [rax-24], -2
	mov	QWORD PTR [rax+24], rbx
	mov	rbx, rdx
	mov	rdi, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	vmovdqu	xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
	vmovdqu	XMMWORD PTR [rax-40], xmm0

; 343  :         _Left = _Right;

	mov	BYTE PTR [rax-56], 0

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	xor	r8d, r8d
	lea	rdx, OFFSET FLAT:??_C@_00CNPNBAHC@@
	lea	rcx, QWORD PTR [rax-56]
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
	npad	1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 359  :     system_error(error_code _Errcode) : _Mybase(_Errcode, "") { // construct from error code

	vmovups	xmm0, XMMWORD PTR [rbx]
	vmovups	XMMWORD PTR $T10[rsp], xmm0
	lea	r8, QWORD PTR $T1[rsp]
	lea	rdx, QWORD PTR $T10[rsp]
	mov	rcx, rdi
	call	??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
	npad	1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T1[rsp+24]
	cmp	rdx, 16

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN67@system_err

; 3872 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 3873 :             auto& _Al          = _Getal();
; 3874 :             _Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR $T1[rsp]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN77@system_err

; 107  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN77@system_err
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN77@system_err:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN67@system_err:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 359  :     system_error(error_code _Errcode) : _Mybase(_Errcode, "") { // construct from error code

	lea	rax, OFFSET FLAT:??_7system_error@std@@6B@
	mov	QWORD PTR [rdi], rax

; 360  :     }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN93@system_err:
??0system_error@std@@QEAA@Verror_code@1@@Z ENDP		; std::system_error::system_error
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
$T10 = 32
$T1 = 48
this$ = 112
_Errcode$ = 120
?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@@Z@4HA PROC ; `std::system_error::system_error'::`1'::dtor$0
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@@Z@4HA ENDP ; `std::system_error::system_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
this$GSCopy$ = 32
$T10 = 32
$T1 = 48
this$ = 112
_Errcode$ = 120
?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@@Z@4HA PROC ; `std::system_error::system_error'::`1'::dtor$0
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0???0system_error@std@@QEAA@Verror_code@1@@Z@4HA ENDP ; `std::system_error::system_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0system_error@std@@QEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
_Errcode$ = 72
_Message$ = 80
??0system_error@std@@QEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::system_error::system_error, COMDAT

; 362  :     system_error(error_code _Errcode, const string& _Message)

$LN6:
	push	rbx
	sub	rsp, 48					; 00000030H

; 363  :         : _Mybase(_Errcode, _Message) { // construct from error code and message string

	vmovups	xmm0, XMMWORD PTR [rdx]
	lea	rdx, QWORD PTR $T1[rsp]
	mov	rbx, rcx
	vmovups	XMMWORD PTR $T1[rsp], xmm0
	call	??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
	lea	rax, OFFSET FLAT:??_7system_error@std@@6B@
	mov	QWORD PTR [rbx], rax

; 364  :     }

	mov	rax, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??0system_error@std@@QEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??_Gsystem_error@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gsystem_error@std@@UEAAPEAXI@Z PROC			; std::system_error::`scalar deleting destructor', COMDAT
$LN18:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 85   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	rdi, rcx
	mov	QWORD PTR [rcx], rax
	mov	ebx, edx

; 86   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	call	QWORD PTR __imp___std_exception_destroy
	test	bl, 1
	je	SHORT $LN15@scalar
	mov	edx, 40					; 00000028H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN15@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_Gsystem_error@std@@UEAAPEAXI@Z ENDP			; std::system_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??1system_error@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1system_error@std@@UEAA@XZ PROC			; std::system_error::~system_error, COMDAT

; 85   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 86   :         __std_exception_destroy(&_Data);

	add	rcx, 8
	rex_jmp	QWORD PTR __imp___std_exception_destroy
??1system_error@std@@UEAA@XZ ENDP			; std::system_error::~system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0_Generic_error_category@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Generic_error_category@std@@QEAA@XZ PROC		; std::_Generic_error_category::_Generic_error_category, COMDAT

; 404  :     _Generic_error_category() noexcept { // default constructor

	lea	rax, OFFSET FLAT:??_7_Generic_error_category@std@@6B@

; 405  :         _Addr = _Generic_addr;

	mov	QWORD PTR [rcx+8], 3
	mov	QWORD PTR [rcx], rax

; 406  :     }

	mov	rax, rcx
	ret	0
??0_Generic_error_category@std@@QEAA@XZ ENDP		; std::_Generic_error_category::_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?name@_Generic_error_category@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?name@_Generic_error_category@std@@UEBAPEBDXZ PROC	; std::_Generic_error_category::name, COMDAT

; 409  :         return "generic";

	lea	rax, OFFSET FLAT:??_C@_07DCLBNMLN@generic@

; 410  :     }

	ret	0
?name@_Generic_error_category@std@@UEBAPEBDXZ ENDP	; std::_Generic_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
this$ = 48
__$ReturnUdt$ = 56
_Errcode$ = 64
?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_Generic_error_category::message, COMDAT

; 412  :     _NODISCARD virtual string message(int _Errcode) const override { // convert to name of error

$LN38:
	push	rbx
	sub	rsp, 32					; 00000020H

; 413  :         return _Syserror_map(_Errcode);

	mov	ecx, r8d
	mov	rbx, rdx
	call	QWORD PTR __imp_?_Syserror_map@std@@YAPEBDH@Z
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+16], 0

; 301  :         return __builtin_strlen(_First);

	mov	r8, -1

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 343  :         _Left = _Right;

	mov	BYTE PTR [rbx], 0
	npad	4
$LL35@message:

; 301  :         return __builtin_strlen(_First);

	inc	r8
	cmp	BYTE PTR [rax+r8], 0
	jne	SHORT $LL35@message

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	rdx, rax
	mov	rcx, rbx
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 413  :         return _Syserror_map(_Errcode);

	mov	rax, rbx

; 414  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?message@_Generic_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_Generic_error_category::message
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G_Generic_error_category@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_Generic_error_category@std@@UEAAPEAXI@Z PROC	; std::_Generic_error_category::`scalar deleting destructor', COMDAT
$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	test	dl, 1
	je	SHORT $LN9@scalar
	mov	edx, 16
	call	??3@YAXPEAX_K@Z				; operator delete
$LN9@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G_Generic_error_category@std@@UEAAPEAXI@Z ENDP	; std::_Generic_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1_Generic_error_category@std@@UEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1_Generic_error_category@std@@UEAA@XZ PROC		; std::_Generic_error_category::~_Generic_error_category, COMDAT
	ret	0
??1_Generic_error_category@std@@UEAA@XZ ENDP		; std::_Generic_error_category::~_Generic_error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??0_System_error_category@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_System_error_category@std@@QEAA@XZ PROC		; std::_System_error_category::_System_error_category, COMDAT

; 440  :     _System_error_category() noexcept { // default constructor

	lea	rax, OFFSET FLAT:??_7_System_error_category@std@@6B@

; 441  :         _Addr = _System_addr;

	mov	QWORD PTR [rcx+8], 7
	mov	QWORD PTR [rcx], rax

; 442  :     }

	mov	rax, rcx
	ret	0
??0_System_error_category@std@@QEAA@XZ ENDP		; std::_System_error_category::_System_error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?name@_System_error_category@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?name@_System_error_category@std@@UEBAPEBDXZ PROC	; std::_System_error_category::name, COMDAT

; 445  :         return "system";

	lea	rax, OFFSET FLAT:??_C@_06FHFOAHML@system@

; 446  :     }

	ret	0
?name@_System_error_category@std@@UEBAPEBDXZ ENDP	; std::_System_error_category::name
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z
_TEXT	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 48
this$ = 128
__$ReturnUdt$ = 136
_Errcode$ = 144
?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z PROC ; std::_System_error_category::message, COMDAT

; 448  :     _NODISCARD virtual string message(int _Errcode) const override { // convert to name of error

$LN316:
	mov	rax, rsp
	push	rbp
	push	rsi
	push	rdi
	push	r12
	push	r13
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR [rax-80], -2
	mov	QWORD PTR [rax+8], rbx
	mov	r15d, r8d
	mov	rbx, rdx
	mov	QWORD PTR [rax-72], rdx
	xor	edi, edi
	mov	DWORD PTR [rax-88], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rdi

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 15

; 343  :         _Left = _Right;

	mov	BYTE PTR [rdx], dil

; 2709 :         if (_Count <= _My_data._Myres) {

	mov	r14, QWORD PTR [rdx+24]

; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, r14
	shr	rcx, 1
	mov	r12, 9223372036854775807		; 7fffffffffffffffH
	mov	rax, r12
	sub	rax, rcx
	cmp	r14, rax
	jbe	SHORT $LN72@message

; 3775 :             return _Max;

	mov	rbp, r12
	jmp	SHORT $LN70@message
$LN72@message:

; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rcx+r14]
	mov	ebp, 32767				; 00007fffH
	cmp	rax, rbp
	cmova	rbp, rax
$LN70@message:

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, rbp
	add	rax, 1
	mov	r13, -1
	cmovb	rax, r13
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN103@message

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	cmp	rcx, rax
	cmovbe	rcx, r13

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN305@message

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rsi, QWORD PTR [rax+39]
	and	rsi, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rsi-8], rax

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN102@message
$LN103@message:

; 175  :     }
; 176  : #endif // defined(_M_IX86) || defined(_M_X64)
; 177  : 
; 178  :     if (_Bytes != 0) {

	test	rax, rax
	je	SHORT $LN104@message

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rsi, rax

; 179  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN102@message
$LN104@message:

; 180  :     }
; 181  : 
; 182  :     return nullptr;

	mov	rsi, rdi
$LN102@message:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3795 :         _My_data._Mysize = _New_size;

	mov	QWORD PTR [rbx+16], 32767		; 00007fffH

; 3796 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rbx+24], rbp

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	xor	edx, edx
	mov	r8d, 32767				; 00007fffH
	mov	rcx, rsi
	call	memset

; 343  :         _Left = _Right;

	mov	BYTE PTR [rsi+32767], dil

; 3798 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	r14, 16
	jb	SHORT $LN49@message

; 3799 :             _Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	mov	rcx, QWORD PTR [rbx]
	lea	rdx, QWORD PTR [r14+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN148@message

; 107  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN305@message

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN148@message:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN49@message:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 460  :         return _Narrow;

	mov	QWORD PTR [rbx], rsi
	mov	DWORD PTR $T1[rsp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	rdx, rbx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rbx+24], 16

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN312@message
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rdx, rsi
$LN312@message:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 452  :         const unsigned long _Val = _Winerror_message(static_cast<unsigned long>(_Errcode), &_Narrow[0], _Size);

	mov	r8d, 32767				; 00007fffH
	mov	ecx, r15d
	call	QWORD PTR __imp_?_Winerror_message@std@@YAKKPEADK@Z

; 453  :         if (_Val == 0) {

	mov	rcx, rbx
	test	eax, eax
	jne	SHORT $LN2@message
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	lea	r8d, QWORD PTR [rax+13]
	lea	rdx, OFFSET FLAT:??_C@_0O@BFJCFAAK@unknown?5error@
	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 455  :         } else {

	jmp	SHORT $LN3@message
$LN2@message:

; 456  :             _Narrow.resize(_Val);

	mov	edx, eax
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
$LN3@message:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rax, QWORD PTR [rbx+24]
	cmp	rax, 16

; 3143 :         if (!_My_data._Large_string_engaged()) { // can't shrink from small mode

	jb	$LN188@message

; 3144 :             return;
; 3145 :         }
; 3146 : 
; 3147 :         if (_My_data._Mysize < _BUF_SIZE) {

	mov	rsi, QWORD PTR [rbx+16]
	cmp	rsi, 16
	jae	SHORT $LN187@message

; 3846 :         const pointer _Ptr = _My_data._Bx._Ptr;

	mov	rdi, QWORD PTR [rbx]

; 3847 :         auto& _Al          = _Getal();
; 3848 :         _Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3849 :         _Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

	lea	r8, QWORD PTR [rsi+1]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, rdi
	mov	rcx, rbx
	call	memcpy

; 3850 :         _Al.deallocate(_Ptr, _My_data._Myres + 1);

	mov	rdx, QWORD PTR [rbx+24]
	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN230@message

; 107  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdi-8]

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rdi, rcx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rdi-8]
	cmp	rax, 31
	ja	$LN305@message

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rdi, rcx
$LN230@message:

; 195  :     ::operator delete(_Ptr, _Bytes);

	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3851 :         _My_data._Myres = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 3149 :             return;

	jmp	$LN188@message
$LN187@message:

; 3150 :         }
; 3151 : 
; 3152 :         const size_type _Target_capacity = _Min_value(_My_data._Mysize | _ALLOC_MASK, max_size());

	or	rsi, 15
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmp	rsi, r12
	cmova	rsi, r12
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3153 :         if (_Target_capacity < _My_data._Myres) { // worth shrinking, do it

	cmp	rsi, rax
	jae	$LN188@message

; 3154 :             auto& _Al              = _Getal();
; 3155 :             const pointer _New_ptr = _Al.allocate(_Target_capacity + 1); // throws

	lea	rax, QWORD PTR [rsi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN260@message

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	cmp	rcx, rax
	cmovbe	rcx, r13

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN305@message

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN259@message
$LN260@message:

; 175  :     }
; 176  : #endif // defined(_M_IX86) || defined(_M_X64)
; 177  : 
; 178  :     if (_Bytes != 0) {

	test	rax, rax
	je	SHORT $LN259@message

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax
$LN259@message:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3157 :             _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);

	mov	r8, QWORD PTR [rbx+16]
	inc	r8

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, QWORD PTR [rbx]
	mov	rcx, rdi
	call	memcpy

; 3158 :             _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);

	mov	rdx, QWORD PTR [rbx+24]
	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN308@message

; 107  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN305@message

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN308@message:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3159 :             _My_data._Bx._Ptr = _New_ptr;

	mov	QWORD PTR [rbx], rdi

; 3160 :             _My_data._Myres   = _Target_capacity;

	mov	QWORD PTR [rbx+24], rsi
$LN188@message:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 460  :         return _Narrow;

	mov	rax, rbx

; 461  :     }

	mov	rbx, QWORD PTR [rsp+128]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r13
	pop	r12
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN305@message:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN313@message:
?message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z ENDP ; std::_System_error_category::message
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 48
this$ = 128
__$ReturnUdt$ = 136
_Errcode$ = 144
?dtor$0@?0??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA PROC ; `std::_System_error_category::message'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA ENDP ; `std::_System_error_category::message'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
__$ReturnUdt$GSCopy$ = 48
this$ = 128
__$ReturnUdt$ = 136
_Errcode$ = 144
?dtor$0@?0??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA PROC ; `std::_System_error_category::message'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??message@_System_error_category@std@@UEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@H@Z@4HA ENDP ; `std::_System_error_category::message'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z
_TEXT	SEGMENT
$T5 = 32
this$ = 64
__$ReturnUdt$ = 72
_Errval$ = 80
?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z PROC ; std::_System_error_category::default_error_condition, COMDAT

; 464  :         noexcept override { // make error_condition for error code (generic if possible)

$LN27:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T5[rsp], -2
	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [rsp+72], rsi
	mov	edi, r8d
	mov	rbx, rdx

; 465  :         const int _Posv = _Winerror_map(_Errval);

	mov	ecx, r8d
	call	QWORD PTR __imp_?_Winerror_map@std@@YAHH@Z
	npad	1
	mov	esi, eax

; 466  :         if (_Posv == 0) {

	test	eax, eax
	jne	SHORT $LN2@default_er

; 507  :         == 0) { // _Execute_once should never fail if the callback never fails

	lea	rsi, OFFSET FLAT:?_Storage@?1???$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A ; `std::_Immortalize<std::_System_error_category>'::`2'::_Storage
	mov	r8, rsi
	lea	rdx, OFFSET FLAT:??$_Immortalize_impl@V_System_error_category@std@@@std@@YAHPEAX0PEAPEAX@Z ; std::_Immortalize_impl<std::_System_error_category>
	lea	rcx, OFFSET FLAT:?_Flag@?1???$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@1@XZ@4PEAXEA ; `std::_Immortalize<std::_System_error_category>'::`2'::_Flag
	call	QWORD PTR __imp_?_Execute_once@std@@YAHAEAUonce_flag@1@P6AHPEAX1PEAPEAX@Z1@Z
	npad	1
	test	eax, eax
	je	SHORT $LN22@default_er

; 170  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	DWORD PTR [rbx], edi
	mov	QWORD PTR [rbx+8], rsi

; 467  :             return error_condition(_Errval, system_category());
; 468  :         } else {
; 469  :             return error_condition(_Posv, generic_category());
; 470  :         }
; 471  :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN2@default_er:

; 507  :         == 0) { // _Execute_once should never fail if the callback never fails

	lea	rdi, OFFSET FLAT:?_Storage@?1???$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A ; `std::_Immortalize<std::_Generic_error_category>'::`2'::_Storage
	mov	r8, rdi
	lea	rdx, OFFSET FLAT:??$_Immortalize_impl@V_Generic_error_category@std@@@std@@YAHPEAX0PEAPEAX@Z ; std::_Immortalize_impl<std::_Generic_error_category>
	lea	rcx, OFFSET FLAT:?_Flag@?1???$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@1@XZ@4PEAXEA ; `std::_Immortalize<std::_Generic_error_category>'::`2'::_Flag
	call	QWORD PTR __imp_?_Execute_once@std@@YAHAEAUonce_flag@1@P6AHPEAX1PEAPEAX@Z1@Z
	npad	1
	test	eax, eax
	jne	SHORT $LN17@default_er
$LN22@default_er:

; 508  :         _STD terminate();

	call	QWORD PTR __imp_terminate
	npad	1
$LN17@default_er:

; 170  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	DWORD PTR [rbx], esi
	mov	QWORD PTR [rbx+8], rdi

; 467  :             return error_condition(_Errval, system_category());
; 468  :         } else {
; 469  :             return error_condition(_Posv, generic_category());
; 470  :         }
; 471  :     }

	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN23@default_er:
?default_error_condition@_System_error_category@std@@UEBA?AVerror_condition@2@H@Z ENDP ; std::_System_error_category::default_error_condition
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G_System_error_category@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G_System_error_category@std@@UEAAPEAXI@Z PROC	; std::_System_error_category::`scalar deleting destructor', COMDAT
$LN12:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	test	dl, 1
	je	SHORT $LN9@scalar
	mov	edx, 16
	call	??3@YAXPEAX_K@Z				; operator delete
$LN9@scalar:
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??_G_System_error_category@std@@UEAAPEAXI@Z ENDP	; std::_System_error_category::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1_System_error_category@std@@UEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1_System_error_category@std@@UEAA@XZ PROC		; std::_System_error_category::~_System_error_category, COMDAT
	ret	0
??1_System_error_category@std@@UEAA@XZ ENDP		; std::_System_error_category::~_System_error_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?generic_category@std@@YAAEBVerror_category@1@XZ
_TEXT	SEGMENT
?generic_category@std@@YAAEBVerror_category@1@XZ PROC	; std::generic_category, COMDAT

; 515  : _NODISCARD inline const error_category& generic_category() noexcept { // get generic_category

$LN10:
	sub	rsp, 40					; 00000028H

; 507  :         == 0) { // _Execute_once should never fail if the callback never fails

	lea	r8, OFFSET FLAT:?_Storage@?1???$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A ; `std::_Immortalize<std::_Generic_error_category>'::`2'::_Storage
	lea	rdx, OFFSET FLAT:??$_Immortalize_impl@V_Generic_error_category@std@@@std@@YAHPEAX0PEAPEAX@Z ; std::_Immortalize_impl<std::_Generic_error_category>
	lea	rcx, OFFSET FLAT:?_Flag@?1???$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@1@XZ@4PEAXEA ; `std::_Immortalize<std::_Generic_error_category>'::`2'::_Flag
	call	QWORD PTR __imp_?_Execute_once@std@@YAHAEAUonce_flag@1@P6AHPEAX1PEAPEAX@Z1@Z
	test	eax, eax
	jne	SHORT $LN4@generic_ca

; 508  :         _STD terminate();

	call	QWORD PTR __imp_terminate
	int	3
$LN4@generic_ca:

; 516  :     return _Immortalize<_Generic_error_category>();

	lea	rax, OFFSET FLAT:?_Storage@?1???$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A ; `std::_Immortalize<std::_Generic_error_category>'::`2'::_Storage

; 517  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@generic_ca:
?generic_category@std@@YAAEBVerror_category@1@XZ ENDP	; std::generic_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ?system_category@std@@YAAEBVerror_category@1@XZ
_TEXT	SEGMENT
?system_category@std@@YAAEBVerror_category@1@XZ PROC	; std::system_category, COMDAT

; 523  : _NODISCARD inline const error_category& system_category() noexcept { // get system_category

$LN10:
	sub	rsp, 40					; 00000028H

; 507  :         == 0) { // _Execute_once should never fail if the callback never fails

	lea	r8, OFFSET FLAT:?_Storage@?1???$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A ; `std::_Immortalize<std::_System_error_category>'::`2'::_Storage
	lea	rdx, OFFSET FLAT:??$_Immortalize_impl@V_System_error_category@std@@@std@@YAHPEAX0PEAPEAX@Z ; std::_Immortalize_impl<std::_System_error_category>
	lea	rcx, OFFSET FLAT:?_Flag@?1???$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@1@XZ@4PEAXEA ; `std::_Immortalize<std::_System_error_category>'::`2'::_Flag
	call	QWORD PTR __imp_?_Execute_once@std@@YAHAEAUonce_flag@1@P6AHPEAX1PEAPEAX@Z1@Z
	test	eax, eax
	jne	SHORT $LN4@system_cat

; 508  :         _STD terminate();

	call	QWORD PTR __imp_terminate
	int	3
$LN4@system_cat:

; 524  :     return _Immortalize<_System_error_category>();

	lea	rax, OFFSET FLAT:?_Storage@?1???$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A ; `std::_Immortalize<std::_System_error_category>'::`2'::_Storage

; 525  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN7@system_cat:
?system_category@std@@YAAEBVerror_category@1@XZ ENDP	; std::system_category
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0system_error@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0system_error@std@@QEAA@AEBV01@@Z PROC		; std::system_error::system_error, COMDAT
$LN13:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 68   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax
	lea	rdx, QWORD PTR [rcx+8]
	mov	rdi, rcx
	vpxor	xmm0, xmm0, xmm0

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rbx+8]
	vmovups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7_System_error@std@@6B@
	mov	QWORD PTR [rdi], rax
	lea	rax, OFFSET FLAT:??_7system_error@std@@6B@
	vmovups	xmm0, XMMWORD PTR [rbx+24]
	mov	rbx, QWORD PTR [rsp+48]
	mov	QWORD PTR [rdi], rax
	mov	rax, rdi
	vmovups	XMMWORD PTR [rdi+24], xmm0
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0system_error@std@@QEAA@AEBV01@@Z ENDP		; std::system_error::system_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0_System_error@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0_System_error@std@@QEAA@AEBV01@@Z PROC		; std::_System_error::_System_error, COMDAT
$LN10:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 68   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax
	lea	rdx, QWORD PTR [rcx+8]
	mov	rdi, rcx
	vpxor	xmm0, xmm0, xmm0

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rbx+8]
	vmovups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7_System_error@std@@6B@
	mov	QWORD PTR [rdi], rax
	mov	rax, rdi
	vmovups	xmm0, XMMWORD PTR [rbx+24]
	mov	rbx, QWORD PTR [rsp+48]
	vmovups	XMMWORD PTR [rdi+24], xmm0
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0_System_error@std@@QEAA@AEBV01@@Z ENDP		; std::_System_error::_System_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0runtime_error@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0runtime_error@std@@QEAA@AEBV01@@Z PROC		; std::runtime_error::runtime_error, COMDAT
$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rax, rdx

; 68   :     {

	lea	rcx, OFFSET FLAT:??_7exception@std@@6B@
	vpxor	xmm0, xmm0, xmm0
	mov	QWORD PTR [rbx], rcx
	lea	rdx, QWORD PTR [rbx+8]

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rax+8]
	vmovups	XMMWORD PTR [rdx], xmm0
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7runtime_error@std@@6B@
	mov	QWORD PTR [rbx], rax
	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0runtime_error@std@@QEAA@AEBV01@@Z ENDP		; std::runtime_error::runtime_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Byte$ = 48
_File$ = 56
??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z PROC		; std::_Fgetc<char>, COMDAT

; 48   : inline bool _Fgetc(char& _Byte, FILE* _File) { // get a char element from a C stream

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 49   :     int _Meta;
; 50   :     if ((_Meta = _CSTD fgetc(_File)) == EOF) {

	mov	rcx, rdx
	call	QWORD PTR __imp_fgetc
	cmp	eax, -1
	jne	SHORT $LN2@Fgetc

; 51   :         return false;

	xor	al, al

; 55   :     }
; 56   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@Fgetc:

; 52   :     } else { // got one, convert to char
; 53   :         _Byte = (char) _Meta;

	mov	BYTE PTR [rbx], al

; 54   :         return true;

	mov	al, 1

; 55   :     }
; 56   : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Byte$ = 48
_File$ = 56
??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT

; 89   : inline bool _Fputc(char _Byte, FILE* _File) { // put a char element to a C stream

$LN4:
	sub	rsp, 40					; 00000028H

; 90   :     return _CSTD fputc(_Byte, _File) != EOF;

	movsx	ecx, cl
	call	QWORD PTR __imp_fputc
	cmp	eax, -1
	setne	al

; 91   : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z ENDP		; std::_Fputc<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Byte$ = 48
_File$ = 56
??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z PROC		; std::_Ungetc<char>, COMDAT

; 112  : inline bool _Ungetc(const char& _Byte, FILE* _File) { // put back a char element to a C stream

$LN4:
	sub	rsp, 40					; 00000028H

; 113  :     return _CSTD ungetc((unsigned char) _Byte, _File) != EOF;

	movzx	ecx, BYTE PTR [rcx]
	call	QWORD PTR __imp_ungetc
	cmp	eax, -1
	setne	al

; 114  : }

	add	rsp, 40					; 00000028H
	ret	0
??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>, COMDAT

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 77   :         }

	mov	rax, rcx
	ret	0
??$?0_JX@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@QEAA@AEB_J@Z ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::duration<__int64,std::ratio<1,1000000000> ><__int64,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xfilesystem_abi.h
;	COMDAT ??U@YA?AW4__std_fs_stats_flags@@W40@0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??U@YA?AW4__std_fs_stats_flags@@W40@0@Z PROC		; operator|, COMDAT

; 101  : _BITMASK_OPS(__std_fs_stats_flags)

	or	ecx, edx
	mov	eax, ecx
	ret	0
??U@YA?AW4__std_fs_stats_flags@@W40@0@Z ENDP		; operator|
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ?_Xsystem_error_invalid_argument@filesystem@std@@YAXXZ
_TEXT	SEGMENT
$T2 = 32
$T1 = 48
$T3 = 64
?_Xsystem_error_invalid_argument@filesystem@std@@YAXXZ PROC ; std::filesystem::_Xsystem_error_invalid_argument, COMDAT

; 33   :     [[noreturn]] inline void _Xsystem_error_invalid_argument() {

$LN4:
	sub	rsp, 120				; 00000078H

; 34   :         _THROW(system_error(_STD make_error_code(errc::invalid_argument)));

	lea	rcx, QWORD PTR $T1[rsp]
	call	?make_error_code@std@@YA?AVerror_code@1@W4errc@1@@Z ; std::make_error_code
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	vmovups	xmm0, XMMWORD PTR [rax]
	vmovups	XMMWORD PTR $T2[rsp], xmm0
	call	??0system_error@std@@QEAA@Verror_code@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T3[rsp]
	call	_CxxThrowException
	int	3
$LN3@Xsystem_er:
?_Xsystem_error_invalid_argument@filesystem@std@@YAXXZ ENDP ; std::filesystem::_Xsystem_error_invalid_argument
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_Errno$ = 56
?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z PROC ; std::filesystem::_Make_ec, COMDAT

; 44   :     _NODISCARD inline error_code _Make_ec(__std_win_error _Errno) noexcept { // make an error_code

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 507  :         == 0) { // _Execute_once should never fail if the callback never fails

	lea	rsi, OFFSET FLAT:?_Storage@?1???$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A ; `std::_Immortalize<std::_System_error_category>'::`2'::_Storage
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 44   :     _NODISCARD inline error_code _Make_ec(__std_win_error _Errno) noexcept { // make an error_code

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 507  :         == 0) { // _Execute_once should never fail if the callback never fails

	lea	rdx, OFFSET FLAT:??$_Immortalize_impl@V_System_error_category@std@@@std@@YAHPEAX0PEAPEAX@Z ; std::_Immortalize_impl<std::_System_error_category>
	mov	r8, rsi
	lea	rcx, OFFSET FLAT:?_Flag@?1???$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@1@XZ@4PEAXEA ; `std::_Immortalize<std::_System_error_category>'::`2'::_Flag
	call	QWORD PTR __imp_?_Execute_once@std@@YAHAEAUonce_flag@1@P6AHPEAX1PEAPEAX@Z1@Z
	test	eax, eax
	jne	SHORT $LN6@Make_ec

; 508  :         _STD terminate();

	call	QWORD PTR __imp_terminate
	int	3
$LN6@Make_ec:

; 115  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	QWORD PTR [rbx+8], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 45   :         return {static_cast<int>(_Errno), _STD system_category()};

	mov	rax, rbx

; 46   :     }

	mov	rsi, QWORD PTR [rsp+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 115  :         : _Myval(_Val), _Mycat(&_Cat) { // construct from error code and category

	mov	DWORD PTR [rbx], edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 46   :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN12@Make_ec:
?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z ENDP ; std::filesystem::_Make_ec
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ?_Check_convert_result@filesystem@std@@YAHU__std_fs_convert_result@@@Z
_TEXT	SEGMENT
$T2 = 32
$T1 = 48
$T3 = 64
_Result$ = 128
?_Check_convert_result@filesystem@std@@YAHU__std_fs_convert_result@@@Z PROC ; std::filesystem::_Check_convert_result, COMDAT

; 48   :     _NODISCARD inline int _Check_convert_result(const __std_fs_convert_result _Result) {

$LN7:
	sub	rsp, 120				; 00000078H

; 49   :         if (_Result._Err != __std_win_error::_Success) {

	mov	rax, rcx
	shr	rax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN6@Check_conv

; 51   :         }
; 52   : 
; 53   :         return _Result._Len;

	mov	eax, ecx

; 54   :     }

	add	rsp, 120				; 00000078H
	ret	0
$LN6@Check_conv:

; 50   :             _THROW(system_error(_Make_ec(_Result._Err)));

	mov	edx, eax
	lea	rcx, QWORD PTR $T1[rsp]
	call	?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z ; std::filesystem::_Make_ec
	lea	rdx, QWORD PTR $T2[rsp]
	lea	rcx, QWORD PTR $T3[rsp]
	vmovups	xmm0, XMMWORD PTR [rax]
	vmovups	XMMWORD PTR $T2[rsp], xmm0
	call	??0system_error@std@@QEAA@Verror_code@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T3[rsp]
	call	_CxxThrowException
	int	3
$LN4@Check_conv:
?_Check_convert_result@filesystem@std@@YAHU__std_fs_convert_result@@@Z ENDP ; std::filesystem::_Check_convert_result
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z
_TEXT	SEGMENT
$T1 = 48
$T29 = 64
$T13 = 64
$T28 = 80
$T12 = 80
$T30 = 96
$T14 = 96
__$ReturnUdt$ = 192
_Code_page$ = 200
_Input$ = 208
?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z PROC ; std::filesystem::_Convert_narrow_to_wide, COMDAT

; 56   :     _NODISCARD inline wstring _Convert_narrow_to_wide(const __std_code_page _Code_page, const string_view _Input) {

$LN122:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rcx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 144				; 00000090H
	mov	QWORD PTR [rax-128], -2
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rbp
	mov	r14d, edx
	mov	rsi, rcx
	xor	r12d, r12d
	mov	DWORD PTR $T1[rsp], r12d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], r12

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7

; 211  :         _Left = _Right;

	mov	WORD PTR [rcx], r12w
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 73   :         return _Output;

	mov	DWORD PTR $T1[rsp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 1204 :         return _Mysize == 0;

	mov	rbp, QWORD PTR [r8+8]
	test	rbp, rbp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 59   :         if (!_Input.empty()) {

	je	$LN108@Convert_na

; 60   :             if (_Input.size() > static_cast<size_t>(INT_MAX)) {

	cmp	rbp, 2147483647				; 7fffffffH
	ja	$LN118@Convert_na

; 62   :             }
; 63   : 
; 64   :             const int _Len = _Check_convert_result(__std_fs_convert_narrow_to_wide(

	mov	r15, QWORD PTR [r8]
	mov	DWORD PTR [rsp+32], r12d
	xor	r9d, r9d
	mov	r8d, ebp
	mov	rdx, r15
	mov	ecx, r14d
	call	__std_fs_convert_narrow_to_wide
	mov	rbx, rax

; 49   :         if (_Result._Err != __std_win_error::_Success) {

	shr	rax, 32					; 00000020H
	test	eax, eax
	jne	$LN119@Convert_na

; 65   :                 _Code_page, _Input.data(), static_cast<int>(_Input.size()), nullptr, 0));
; 66   : 
; 67   :             _Output.resize(static_cast<size_t>(_Len));

	movsxd	rcx, ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3264 :         return _Get_data()._Mysize;

	mov	r8, QWORD PTR [rsi+16]
	mov	rdi, QWORD PTR [rsi+24]

; 3279 :         if (_Newsize <= _Old_size) {

	cmp	rcx, r8
	ja	SHORT $LN43@Convert_na

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	rax, rsi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	rdi, 8

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN114@Convert_na
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rax, QWORD PTR [rsi]
$LN114@Convert_na:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3856 :         _Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rsi+16], rcx

; 211  :         _Left = _Right;

	mov	WORD PTR [rax+rcx*2], r12w

; 3281 :         } else {

	jmp	SHORT $LN67@Convert_na
$LN43@Convert_na:

; 3282 :             append(_Newsize - _Old_size, _Ch);

	mov	rdx, rcx
	sub	rdx, r8

; 2633 :         if (_Count <= _My_data._Myres - _Old_size) {

	mov	rax, rdi
	sub	rax, r8
	cmp	rdx, rax
	ja	SHORT $LN68@Convert_na

; 2634 :             _My_data._Mysize      = _Old_size + _Count;

	mov	QWORD PTR [rsi+16], rcx

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	r9, rsi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	rdi, 8

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN113@Convert_na
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	r9, QWORD PTR [rsi]
$LN113@Convert_na:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2636 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	lea	rdi, QWORD PTR [r9+r8*2]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	test	rdx, rdx
	je	SHORT $LN85@Convert_na
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 207  :         return reinterpret_cast<_Elem*>(_CSTD wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));

	movzx	eax, r12w
	mov	rcx, rdx
	rep stosw
$LN85@Convert_na:

; 2637 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	lea	rax, QWORD PTR [r8+rdx]

; 211  :         _Left = _Right;

	mov	WORD PTR [r9+rax*2], r12w

; 2638 :             return *this;

	jmp	SHORT $LN67@Convert_na
$LN68@Convert_na:

; 2639 :         }
; 2640 : 
; 2641 :         return _Reallocate_grow_by(_Count,

	mov	r9, rdx
	mov	rcx, rsi
	call	??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_a3050a43f3157934f354774ab3dd2e02>,unsigned __int64,wchar_t>
$LN67@Convert_na:

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	r9, rsi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rsi+24], 8

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN97@Convert_na
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	r9, QWORD PTR [rsi]
$LN97@Convert_na:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 69   :             (void) _Check_convert_result(__std_fs_convert_narrow_to_wide(

	mov	DWORD PTR [rsp+32], ebx
	mov	r8d, ebp
	mov	rdx, r15
	mov	ecx, r14d
	call	__std_fs_convert_narrow_to_wide

; 49   :         if (_Result._Err != __std_win_error::_Success) {

	shr	rax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN120@Convert_na
$LN108@Convert_na:

; 73   :         return _Output;

	mov	rax, rsi

; 74   :     }

	lea	r11, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [r11+56]
	mov	rbp, QWORD PTR [r11+64]
	mov	rsp, r11
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN120@Convert_na:

; 50   :             _THROW(system_error(_Make_ec(_Result._Err)));

	mov	edx, eax
	lea	rcx, QWORD PTR $T28[rsp]
	call	?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z ; std::filesystem::_Make_ec
	vmovups	xmm0, XMMWORD PTR [rax]
	vmovups	XMMWORD PTR $T29[rsp], xmm0
	lea	rdx, QWORD PTR $T29[rsp]
	lea	rcx, QWORD PTR $T30[rsp]
	call	??0system_error@std@@QEAA@Verror_code@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T30[rsp]
	call	_CxxThrowException
	int	3
$LN118@Convert_na:

; 61   :                 _Xsystem_error_invalid_argument();

	call	?_Xsystem_error_invalid_argument@filesystem@std@@YAXXZ ; std::filesystem::_Xsystem_error_invalid_argument
	int	3
$LN119@Convert_na:

; 50   :             _THROW(system_error(_Make_ec(_Result._Err)));

	mov	edx, eax
	lea	rcx, QWORD PTR $T12[rsp]
	call	?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z ; std::filesystem::_Make_ec
	vmovups	xmm0, XMMWORD PTR [rax]
	vmovups	XMMWORD PTR $T13[rsp], xmm0
	lea	rdx, QWORD PTR $T13[rsp]
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0system_error@std@@QEAA@Verror_code@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T14[rsp]
	call	_CxxThrowException
	int	3
$LN116@Convert_na:
?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z ENDP ; std::filesystem::_Convert_narrow_to_wide
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T29 = 64
$T13 = 64
$T28 = 80
$T12 = 80
$T30 = 96
$T14 = 96
__$ReturnUdt$ = 192
_Code_page$ = 200
_Input$ = 208
?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA PROC ; `std::filesystem::_Convert_narrow_to_wide'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN6@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA ENDP ; `std::filesystem::_Convert_narrow_to_wide'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T29 = 64
$T13 = 64
$T28 = 80
$T12 = 80
$T30 = 96
$T14 = 96
__$ReturnUdt$ = 192
_Code_page$ = 200
_Input$ = 208
?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA PROC ; `std::filesystem::_Convert_narrow_to_wide'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
$LN6@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z@4HA ENDP ; `std::filesystem::_Convert_narrow_to_wide'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?data@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBAPEBDXZ PROC ; std::basic_string_view<char,std::char_traits<char> >::data, COMDAT

; 1208 :         return _Mydata;

	mov	rax, QWORD PTR [rcx]

; 1209 :     }

	ret	0
?data@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBAPEBDXZ ENDP ; std::basic_string_view<char,std::char_traits<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
this$ = 8
?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBAPEB_WXZ PROC ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data, COMDAT

; 1208 :         return _Mydata;

	mov	rax, QWORD PTR [rcx]

; 1209 :     }

	ret	0
?data@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBAPEB_WXZ ENDP ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ?c_str@path@filesystem@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
this$ = 8
?c_str@path@filesystem@std@@QEBAPEB_WXZ PROC		; std::filesystem::path::c_str, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN16@c_str
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 933  :             return _Text.c_str();

	mov	rax, QWORD PTR [rcx]

; 934  :         }

	ret	0
$LN16@c_str:

; 933  :             return _Text.c_str();

	mov	rax, rcx

; 934  :         }

	ret	0
?c_str@path@filesystem@std@@QEBAPEB_WXZ ENDP		; std::filesystem::path::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ
_TEXT	SEGMENT
$T1 = 48
$T32 = 64
$T23 = 64
$T37 = 80
__$ReturnUdt$GSCopy$ = 88
$T22 = 96
$T31 = 112
$T24 = 128
$T33 = 168
this$ = 240
__$ReturnUdt$ = 248
?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ PROC ; std::filesystem::path::string, COMDAT

; 947  :         _NODISCARD _STD string string() const { // convert the native path from this instance into a string

$LN100:
	mov	rax, rsp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 208				; 000000d0H
	mov	QWORD PTR $T37[rsp], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+24], rbp
	mov	rdi, rdx
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	xor	ebx, ebx
	mov	DWORD PTR $T1[rsp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3196 :         return basic_string_view<_Elem, _Traits>(_My_data._Myptr(), _My_data._Mysize);

	mov	rbp, QWORD PTR [rcx+16]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN18@string
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rsi, QWORD PTR [rcx]
$LN18@string:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 164  :             return _Convert_wide_to_narrow<_Traits>(__std_fs_code_page(), _Input, _Al);

	call	__std_fs_code_page
	mov	r14d, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], rbx

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 343  :         _Left = _Right;

	mov	BYTE PTR [rdi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 95   :         return _Output;

	mov	DWORD PTR $T1[rsp], 8

; 51   :         }
; 52   : 
; 53   :         return _Result._Len;
; 54   :     }
; 55   : 
; 56   :     _NODISCARD inline wstring _Convert_narrow_to_wide(const __std_code_page _Code_page, const string_view _Input) {
; 57   :         wstring _Output;
; 58   : 
; 59   :         if (!_Input.empty()) {
; 60   :             if (_Input.size() > static_cast<size_t>(INT_MAX)) {
; 61   :                 _Xsystem_error_invalid_argument();
; 62   :             }
; 63   : 
; 64   :             const int _Len = _Check_convert_result(__std_fs_convert_narrow_to_wide(
; 65   :                 _Code_page, _Input.data(), static_cast<int>(_Input.size()), nullptr, 0));
; 66   : 
; 67   :             _Output.resize(static_cast<size_t>(_Len));
; 68   : 
; 69   :             (void) _Check_convert_result(__std_fs_convert_narrow_to_wide(
; 70   :                 _Code_page, _Input.data(), static_cast<int>(_Input.size()), _Output.data(), _Len));
; 71   :         }
; 72   : 
; 73   :         return _Output;
; 74   :     }
; 75   : 
; 76   :     template <class _Traits, class _Alloc>
; 77   :     _NODISCARD inline basic_string<char, _Traits, _Alloc> _Convert_wide_to_narrow(
; 78   :         const __std_code_page _Code_page, const wstring_view _Input, const _Alloc& _Al) {
; 79   :         basic_string<char, _Traits, _Alloc> _Output(_Al);
; 80   : 
; 81   :         if (!_Input.empty()) {

	test	rbp, rbp
	je	SHORT $LN89@string

; 82   :             if (_Input.size() > static_cast<size_t>(INT_MAX)) {

	cmp	rbp, 2147483647				; 7fffffffH
	ja	$LN96@string

; 84   :             }
; 85   : 
; 86   :             const int _Len = _Check_convert_result(__std_fs_convert_wide_to_narrow(

	mov	DWORD PTR [rsp+32], ebx
	xor	r9d, r9d
	mov	r8d, ebp
	mov	rdx, rsi
	mov	ecx, eax
	call	__std_fs_convert_wide_to_narrow
	mov	rbx, rax

; 49   :         if (_Result._Err != __std_win_error::_Success) {

	shr	rax, 32					; 00000020H
	test	eax, eax
	jne	$LN97@string

; 89   :             _Output.resize(static_cast<size_t>(_Len));

	movsxd	rdx, ebx
	mov	rcx, rdi
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	r9, rdi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi+24], 16

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN78@string
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	r9, QWORD PTR [rdi]
$LN78@string:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 91   :             (void) _Check_convert_result(__std_fs_convert_wide_to_narrow(

	mov	DWORD PTR [rsp+32], ebx
	mov	r8d, ebp
	mov	rdx, rsi
	mov	ecx, r14d
	call	__std_fs_convert_wide_to_narrow

; 49   :         if (_Result._Err != __std_win_error::_Success) {

	shr	rax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN98@string
$LN89@string:

; 948  :             return string<char>();

	mov	rax, rdi

; 949  :         }

	lea	r11, QWORD PTR [rsp+208]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN98@string:

; 50   :             _THROW(system_error(_Make_ec(_Result._Err)));

	mov	edx, eax
	lea	rcx, QWORD PTR $T31[rsp]
	call	?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z ; std::filesystem::_Make_ec
	vmovups	xmm0, XMMWORD PTR [rax]
	vmovups	XMMWORD PTR $T32[rsp], xmm0
	lea	rdx, QWORD PTR $T32[rsp]
	lea	rcx, QWORD PTR $T33[rsp]
	call	??0system_error@std@@QEAA@Verror_code@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T33[rsp]
	call	_CxxThrowException
	int	3
$LN96@string:

; 83   :                 _Xsystem_error_invalid_argument();

	call	?_Xsystem_error_invalid_argument@filesystem@std@@YAXXZ ; std::filesystem::_Xsystem_error_invalid_argument
	int	3
$LN97@string:

; 50   :             _THROW(system_error(_Make_ec(_Result._Err)));

	mov	edx, eax
	lea	rcx, QWORD PTR $T22[rsp]
	call	?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z ; std::filesystem::_Make_ec
	vmovups	xmm0, XMMWORD PTR [rax]
	vmovups	XMMWORD PTR $T23[rsp], xmm0
	lea	rdx, QWORD PTR $T23[rsp]
	lea	rcx, QWORD PTR $T24[rsp]
	call	??0system_error@std@@QEAA@Verror_code@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T24[rsp]
	call	_CxxThrowException
	int	3
$LN94@string:
?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ ENDP ; std::filesystem::path::string
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T32 = 64
$T23 = 64
$T37 = 80
__$ReturnUdt$GSCopy$ = 88
$T22 = 96
$T31 = 112
$T24 = 128
$T33 = 168
this$ = 240
__$ReturnUdt$ = 248
?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA PROC ; `std::filesystem::path::string'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN35@dtor$3
	and	DWORD PTR $T1[rbp], -9
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN35@dtor$3:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA ENDP ; `std::filesystem::path::string'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T32 = 64
$T23 = 64
$T37 = 80
__$ReturnUdt$GSCopy$ = 88
$T22 = 96
$T31 = 112
$T24 = 128
$T33 = 168
this$ = 240
__$ReturnUdt$ = 248
?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA PROC ; `std::filesystem::path::string'::`1'::dtor$3
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 8
	test	eax, eax
	je	SHORT $LN35@dtor$3
	and	DWORD PTR $T1[rbp], -9
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN35@dtor$3:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$3@?0??string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ@4HA ENDP ; `std::filesystem::path::string'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEAA@QEB_W_K@Z
_TEXT	SEGMENT
this$ = 8
_Cts$ = 16
_Count$ = 24
??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEAA@QEB_W_K@Z PROC ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 1140 :         : _Mydata(_Cts),

	mov	QWORD PTR [rcx], rdx

; 1142 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1143 :         _STL_VERIFY(_Count == 0 || _Cts, "non-zero size null string_view");
; 1144 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1145 :     }

	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEAA@QEB_W_K@Z ENDP ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::basic_string_view<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ??1path@filesystem@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1path@filesystem@std@@QEAA@XZ PROC			; std::filesystem::path::~path, COMDAT

; 1381 :     };

$LN64:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rcx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 1381 :     };

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 8

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN35@path
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN45@path

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN42@path

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN45@path:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN35@path:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	xor	eax, eax

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7
	mov	QWORD PTR [rbx+16], rax

; 211  :         _Left = _Right;

	mov	WORD PTR [rbx], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 1381 :     };

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN42@path:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN61@path:
??1path@filesystem@std@@QEAA@XZ ENDP			; std::filesystem::path::~path
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ??0path@filesystem@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0path@filesystem@std@@QEAA@XZ PROC			; std::filesystem::path::path, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	xor	eax, eax

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7
	mov	QWORD PTR [rcx+16], rax

; 211  :         _Left = _Right;

	mov	WORD PTR [rcx], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 1381 :     };

	mov	rax, rcx
	ret	0
??0path@filesystem@std@@QEAA@XZ ENDP			; std::filesystem::path::path
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ??0path@filesystem@std@@QEAA@AEBV012@@Z
_TEXT	SEGMENT
this$GSCopy$ = 32
this$ = 80
__that$ = 88
??0path@filesystem@std@@QEAA@AEBV012@@Z PROC		; std::filesystem::path::path, COMDAT

; 1381 :     };

$LN115:
	push	rbx
	push	rbp
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rbx, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	xor	ecx, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 1381 :     };

	mov	rdi, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	QWORD PTR [rbx+16], rcx
	mov	QWORD PTR [rbx+24], rcx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 8

; 2441 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	rbp, QWORD PTR [rdx+16]

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN36@path
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rdi, QWORD PTR [rdx]
$LN36@path:
	mov	QWORD PTR [rsp+96], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2443 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

	cmp	rbp, 8
	jae	SHORT $LN25@path
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	vmovups	xmm0, XMMWORD PTR [rdi]
	vmovups	XMMWORD PTR [rbx], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2446 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	esi, 7

; 2447 :             return;

	jmp	$LN24@path
$LN25@path:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	mov	rax, 9223372036854775806		; 7ffffffffffffffeH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	mov	rsi, rbp
	or	rsi, 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	mov	r8, 9223372036854775807			; 7fffffffffffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmp	rsi, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	mov	r9, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmova	rsi, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2452 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	lea	rax, QWORD PTR [rsi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 25   :     size_t _Result                 = _Count * _Ty_size;

	lea	rdx, QWORD PTR [rax+rax]

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	cmp	rax, r8
	jbe	SHORT $LN69@path

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);

	mov	rdx, r9

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	jmp	SHORT $LN111@path
$LN69@path:
	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN72@path
$LN111@path:

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	cmp	rcx, rdx
	cmovbe	rcx, r9

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN81@path

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN73@path
$LN81@path:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN72@path:

; 178  :     if (_Bytes != 0) {

	test	rdx, rdx
	je	SHORT $LN73@path

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rdx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax
$LN73@path:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	r8, QWORD PTR [rbp*2+2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	QWORD PTR [rbx], rcx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	rdx, rdi
	call	memcpy
$LN24@path:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 1381 :     };

	mov	QWORD PTR [rbx+16], rbp
	mov	rax, rbx
	mov	QWORD PTR [rbx+24], rsi
	mov	rsi, QWORD PTR [rsp+96]
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN112@path:
??0path@filesystem@std@@QEAA@AEBV012@@Z ENDP		; std::filesystem::path::path
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z
_TEXT	SEGMENT
$T2 = 32
$T18 = 32
$T14 = 32
$T8 = 48
$T25 = 80
this$GSCopy$ = 96
this$ = 144
_Message$ = 152
_Path1_arg$ = 160
_Errcode$ = 168
??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z PROC ; std::filesystem::filesystem_error::filesystem_error, COMDAT

; 1747 :                   runtime_error::what(), _Path1_arg)) { // construct from message string, path, and error code

$LN137:
	push	rbx
	push	rdi
	sub	rsp, 120				; 00000078H
	mov	QWORD PTR $T25[rsp], -2
	mov	rdi, r8
	mov	rbx, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error

; 363  :         : _Mybase(_Errcode, _Message) { // construct from error code and message string

	vmovups	xmm0, XMMWORD PTR [r9]
	vmovups	XMMWORD PTR $T2[rsp], xmm0
	mov	r8, rdx
	lea	rdx, QWORD PTR $T2[rsp]
	call	??0_System_error@std@@IEAA@Verror_code@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::_System_error::_System_error
	npad	1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 1747 :                   runtime_error::what(), _Path1_arg)) { // construct from message string, path, and error code

	lea	rax, OFFSET FLAT:??_7filesystem_error@filesystem@std@@6B@
	mov	QWORD PTR [rbx], rax

; 1745 :             : system_error(_Errcode, _Message), _Path1(_Path1_arg), _Path2(),

	lea	rcx, QWORD PTR [rbx+40]
	mov	rdx, rdi
	call	??0path@filesystem@std@@QEAA@AEBV012@@Z	; std::filesystem::path::path
	npad	1
	vpxor	xmm0, xmm0, xmm0
	vmovups	YMMWORD PTR [rbx+72], ymm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	xor	eax, eax
	mov	QWORD PTR [rbx+88], rax

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+96], 7

; 211  :         _Left = _Right;

	mov	WORD PTR [rbx+72], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 1746 :               _What(_Pretty_message(

	vmovups	YMMWORD PTR $T8[rsp], ymm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	vmovdqu	xmm1, XMMWORD PTR __xmm@00000000000000070000000000000000
	vmovdqu	XMMWORD PTR $T8[rsp+16], xmm1

; 211  :         _Left = _Right;

	mov	WORD PTR $T8[rsp], ax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 91   :         return _Data._What ? _Data._What : "Unknown exception";

	mov	rax, QWORD PTR [rbx+8]
	lea	rcx, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception@
	test	rax, rax
	cmovne	rcx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 1133 :         : _Mydata(_Ntcts),

	mov	QWORD PTR $T14[rsp], rcx

; 301  :         return __builtin_strlen(_First);

	mov	rax, -1
	npad	3
$LL133@filesystem:
	inc	rax
	cmp	BYTE PTR [rcx+rax], 0
	jne	SHORT $LL133@filesystem
	mov	QWORD PTR $T14[rsp+8], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 1746 :               _What(_Pretty_message(

	vmovups	xmm0, XMMWORD PTR $T14[rsp]
	vmovdqa	XMMWORD PTR $T18[rsp], xmm0
	lea	rcx, QWORD PTR [rbx+104]
	lea	r9, QWORD PTR $T8[rsp]
	mov	r8, rdi
	lea	rdx, QWORD PTR $T18[rsp]
	vzeroupper
	call	?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z ; std::filesystem::filesystem_error::_Pretty_message
	npad	1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR $T8[rsp+24]
	cmp	rdx, 8

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN106@filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rdx*2+2]
	mov	rcx, QWORD PTR $T8[rsp]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN116@filesystem

; 107  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN116@filesystem
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN116@filesystem:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
	npad	1
$LN106@filesystem:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 1748 :         }

	mov	rax, rbx
	add	rsp, 120				; 00000078H
	pop	rdi
	pop	rbx
	ret	0
$LN134@filesystem:
??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z ENDP ; std::filesystem::filesystem_error::filesystem_error
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
$T18 = 32
$T14 = 32
$T8 = 48
$T25 = 80
this$GSCopy$ = 96
this$ = 144
_Message$ = 152
_Path1_arg$ = 160
_Errcode$ = 168
?dtor$0@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1system_error@std@@UEAA@XZ
?dtor$0@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$0
$T2 = 32
$T18 = 32
$T14 = 32
$T8 = 48
$T25 = 80
this$GSCopy$ = 96
this$ = 144
_Message$ = 152
_Path1_arg$ = 160
_Errcode$ = 168
?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$1
$T2 = 32
$T18 = 32
$T14 = 32
$T8 = 48
$T25 = 80
this$GSCopy$ = 96
this$ = 144
_Message$ = 152
_Path1_arg$ = 160
_Errcode$ = 168
?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 72					; 00000048H
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$2
$T2 = 32
$T18 = 32
$T14 = 32
$T8 = 48
$T25 = 80
this$GSCopy$ = 96
this$ = 144
_Message$ = 152
_Path1_arg$ = 160
_Errcode$ = 168
?dtor$3@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$3
	lea	rcx, QWORD PTR $T8[rdx]
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$3@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
$T18 = 32
$T14 = 32
$T8 = 48
$T25 = 80
this$GSCopy$ = 96
this$ = 144
_Message$ = 152
_Path1_arg$ = 160
_Errcode$ = 168
?dtor$0@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	jmp	??1system_error@std@@UEAA@XZ
?dtor$0@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
$T18 = 32
$T14 = 32
$T8 = 48
$T25 = 80
this$GSCopy$ = 96
this$ = 144
_Message$ = 152
_Path1_arg$ = 160
_Errcode$ = 168
?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
$T18 = 32
$T14 = 32
$T8 = 48
$T25 = 80
this$GSCopy$ = 96
this$ = 144
_Message$ = 152
_Path1_arg$ = 160
_Errcode$ = 168
?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 72					; 00000048H
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T2 = 32
$T18 = 32
$T14 = 32
$T8 = 48
$T25 = 80
this$GSCopy$ = 96
this$ = 144
_Message$ = 152
_Path1_arg$ = 160
_Errcode$ = 168
?dtor$3@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$3
	lea	rcx, QWORD PTR $T8[rdx]
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$3@?0???0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ?what@filesystem_error@filesystem@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?what@filesystem_error@filesystem@std@@UEBAPEBDXZ PROC	; std::filesystem::filesystem_error::what, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1549 :         return _Myval2;

	lea	rax, QWORD PTR [rcx+104]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rax+24], 16

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN16@what
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 1766 :             return _What.c_str();

	mov	rax, QWORD PTR [rax]
$LN16@what:

; 1767 :         }

	ret	0
?what@filesystem_error@filesystem@std@@UEBAPEBDXZ ENDP	; std::filesystem::filesystem_error::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z
_TEXT	SEGMENT
$T1 = 32
$T52 = 40
__$ReturnUdt$GSCopy$ = 48
_Path2_str$ = 56
_Path1_str$ = 88
__$ArrayPad$ = 120
__$ReturnUdt$ = 160
_Op$ = 168
_Path1$ = 176
_Path2$ = 184
?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z PROC ; std::filesystem::filesystem_error::_Pretty_message, COMDAT

; 1770 :         static string _Pretty_message(const string_view _Op, const path& _Path1, const path& _Path2 = {}) {

$LN273:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	QWORD PTR $T52[rsp], -2
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, r9
	mov	rdi, rdx
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	mov	DWORD PTR $T1[rsp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 343  :         _Left = _Right;

	mov	BYTE PTR [rcx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 1784 :             return _Result;

	mov	DWORD PTR $T1[rsp], 1

; 1771 :             using namespace _STD string_view_literals; // TRANSITION, VSO#571749
; 1772 :             string _Result;
; 1773 :             const string _Path1_str = _Path1.string();

	lea	rdx, QWORD PTR _Path1_str$[rsp]
	mov	rcx, r8
	call	?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ ; std::filesystem::path::string
	npad	1

; 1774 :             const string _Path2_str = _Path2.string();

	lea	rdx, QWORD PTR _Path2_str$[rsp]
	mov	rcx, rbx
	call	?string@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@XZ ; std::filesystem::path::string
	npad	1

; 1775 :             _Result.reserve(_Op.size() + (_Path2_str.empty() ? 4 : 8) + _Path1_str.size() + _Path2_str.size());

	mov	edx, 8
	mov	ebx, 4
	mov	rax, QWORD PTR _Path2_str$[rsp+16]
	test	rax, rax
	cmove	edx, ebx
	add	rdx, QWORD PTR _Path1_str$[rsp+16]
	add	rdx, rax
	add	rdx, QWORD PTR [rdi+8]
	mov	rcx, rsi
	call	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2592 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;

	vmovups	xmm0, XMMWORD PTR [rdi]

; 2593 :         return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));

	vpextrq	r8, xmm0, 1
	vmovq	rdx, xmm0
	mov	rcx, rsi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
	lea	r8d, QWORD PTR [rbx-1]
	lea	rdx, OFFSET FLAT:??_C@_03NONCDIOG@?3?5?$CC@
	mov	rcx, rsi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR _Path1_str$[rsp]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR _Path1_str$[rsp+24], 16

; 2024 :         if (_Large_string_engaged()) {

	cmovae	rdx, QWORD PTR _Path1_str$[rsp]

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	mov	r8, QWORD PTR _Path1_str$[rsp+16]
	mov	rcx, rsi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 1779 :             if (!_Path2_str.empty()) {

	cmp	QWORD PTR _Path2_str$[rsp+16], 0
	je	SHORT $LN2@Pretty_mes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2593 :         return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));

	mov	r8d, ebx
	lea	rdx, OFFSET FLAT:??_C@_04PHMHGEMA@?$CC?0?5?$CC@
	mov	rcx, rsi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2023 :         const value_type* _Result = _Bx._Buf;

	lea	rdx, QWORD PTR _Path2_str$[rsp]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR _Path2_str$[rsp+24], 16

; 2024 :         if (_Large_string_engaged()) {

	cmovae	rdx, QWORD PTR _Path2_str$[rsp]

; 2578 :         return append(_Right_data._Myptr(), _Right_data._Mysize);

	mov	r8, QWORD PTR _Path2_str$[rsp+16]
	mov	rcx, rsi
	call	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2@Pretty_mes:

; 3202 :         const size_type _Old_size = _My_data._Mysize;

	mov	rcx, QWORD PTR [rsi+16]

; 3203 :         if (_Old_size < _My_data._Myres) {

	mov	rdx, QWORD PTR [rsi+24]
	cmp	rcx, rdx
	jae	SHORT $LN138@Pretty_mes

; 3204 :             _My_data._Mysize  = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR [rsi+16], rax

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	rax, rsi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 16

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN145@Pretty_mes
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rax, QWORD PTR [rsi]
$LN145@Pretty_mes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 343  :         _Left = _Right;

	mov	WORD PTR [rax+rcx], 34			; 00000022H

; 3208 :             return;

	jmp	SHORT $LN137@Pretty_mes
$LN138@Pretty_mes:

; 3209 :         }
; 3210 : 
; 3211 :         _Reallocate_grow_by(1,

	mov	r9b, 34					; 00000022H
	mov	rcx, rsi
	call	??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
	npad	1
$LN137@Pretty_mes:

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR _Path2_str$[rsp+24]
	cmp	rdx, 16

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN187@Pretty_mes

; 3872 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 3873 :             auto& _Al          = _Getal();
; 3874 :             _Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR _Path2_str$[rsp]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN197@Pretty_mes

; 107  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN197@Pretty_mes
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN197@Pretty_mes:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN187@Pretty_mes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	mov	QWORD PTR _Path2_str$[rsp+16], 0

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR _Path2_str$[rsp+24], 15

; 343  :         _Left = _Right;

	mov	BYTE PTR _Path2_str$[rsp], 0

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR _Path1_str$[rsp+24]
	cmp	rdx, 16

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN245@Pretty_mes

; 3872 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 3873 :             auto& _Al          = _Getal();
; 3874 :             _Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR _Path1_str$[rsp]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN255@Pretty_mes

; 107  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN255@Pretty_mes
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN255@Pretty_mes:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN245@Pretty_mes:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 1784 :             return _Result;

	mov	rax, rsi

; 1785 :         }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 128				; 00000080H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
	int	3
$LN270@Pretty_mes:
?_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z ENDP ; std::filesystem::filesystem_error::_Pretty_message
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T52 = 40
__$ReturnUdt$GSCopy$ = 48
_Path2_str$ = 56
_Path1_str$ = 88
__$ArrayPad$ = 120
__$ReturnUdt$ = 160
_Op$ = 168
_Path1$ = 176
_Path2$ = 184
?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA PROC ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN5@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA ENDP ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$0
$T1 = 32
$T52 = 40
__$ReturnUdt$GSCopy$ = 48
_Path2_str$ = 56
_Path1_str$ = 88
__$ArrayPad$ = 120
__$ReturnUdt$ = 160
_Op$ = 168
_Path1$ = 176
_Path2$ = 184
?dtor$1@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA PROC ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$1
	lea	rcx, QWORD PTR _Path1_str$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA ENDP ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$1
$T1 = 32
$T52 = 40
__$ReturnUdt$GSCopy$ = 48
_Path2_str$ = 56
_Path1_str$ = 88
__$ArrayPad$ = 120
__$ReturnUdt$ = 160
_Op$ = 168
_Path1$ = 176
_Path2$ = 184
?dtor$2@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA PROC ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$2
	lea	rcx, QWORD PTR _Path2_str$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA ENDP ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T52 = 40
__$ReturnUdt$GSCopy$ = 48
_Path2_str$ = 56
_Path1_str$ = 88
__$ArrayPad$ = 120
__$ReturnUdt$ = 160
_Op$ = 168
_Path1$ = 176
_Path2$ = 184
?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA PROC ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN5@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN5@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA ENDP ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T52 = 40
__$ReturnUdt$GSCopy$ = 48
_Path2_str$ = 56
_Path1_str$ = 88
__$ArrayPad$ = 120
__$ReturnUdt$ = 160
_Op$ = 168
_Path1$ = 176
_Path2$ = 184
?dtor$1@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA PROC ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$1
	lea	rcx, QWORD PTR _Path1_str$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA ENDP ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T52 = 40
__$ReturnUdt$GSCopy$ = 48
_Path2_str$ = 56
_Path1_str$ = 88
__$ArrayPad$ = 120
__$ReturnUdt$ = 160
_Op$ = 168
_Path1$ = 176
_Path2$ = 184
?dtor$2@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA PROC ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$2
	lea	rcx, QWORD PTR _Path2_str$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??_Pretty_message@filesystem_error@filesystem@std@@CA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@3@V?$basic_string_view@DU?$char_traits@D@std@@@3@AEBVpath@23@1@Z@4HA ENDP ; `std::filesystem::filesystem_error::_Pretty_message'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??_Gfilesystem_error@filesystem@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gfilesystem_error@filesystem@std@@UEAAPEAXI@Z PROC	; std::filesystem::filesystem_error::`scalar deleting destructor', COMDAT
$LN202:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	edi, edx
	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rcx+128]
	cmp	rdx, 16

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN39@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx+104]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN49@scalar

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN168@scalar

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN49@scalar:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN39@scalar:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	xor	esi, esi

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+128], 15
	mov	QWORD PTR [rbx+120], rsi

; 343  :         _Left = _Right;

	mov	BYTE PTR [rbx+104], sil

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rbx+96]
	cmp	rdx, 8

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN100@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+72]
	lea	rdx, QWORD PTR [rdx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN110@scalar

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN168@scalar

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN110@scalar:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN100@scalar:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+88], rsi

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+96], 7

; 211  :         _Left = _Right;

	mov	WORD PTR [rbx+72], si

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rbx+64]
	cmp	rdx, 8

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN161@scalar
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+40]
	lea	rdx, QWORD PTR [rdx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN171@scalar

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN168@scalar

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN171@scalar:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN161@scalar:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 85   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+56], rsi

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+64], 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 86   :         __std_exception_destroy(&_Data);

	lea	rcx, QWORD PTR [rbx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 211  :         _Left = _Right;

	mov	WORD PTR [rbx+40], si
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 85   :     {

	mov	QWORD PTR [rbx], rax

; 86   :         __std_exception_destroy(&_Data);

	call	QWORD PTR __imp___std_exception_destroy
	test	dil, 1
	je	SHORT $LN2@scalar
	mov	edx, 136				; 00000088H
	mov	rcx, rbx
	call	??3@YAXPEAX_K@Z				; operator delete
$LN2@scalar:
	mov	rsi, QWORD PTR [rsp+64]
	mov	rax, rbx
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN168@scalar:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN199@scalar:
??_Gfilesystem_error@filesystem@std@@UEAAPEAXI@Z ENDP	; std::filesystem::filesystem_error::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??1filesystem_error@filesystem@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1filesystem_error@filesystem@std@@UEAA@XZ PROC	; std::filesystem::filesystem_error::~filesystem_error, COMDAT
$LN197:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rcx+128]
	mov	rbx, rcx
	cmp	rdx, 16

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN35@filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx+104]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN45@filesystem

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN164@filesystem

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN45@filesystem:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN35@filesystem:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	xor	edi, edi

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+128], 15
	mov	QWORD PTR [rbx+120], rdi

; 343  :         _Left = _Right;

	mov	BYTE PTR [rbx+104], dil

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rbx+96]
	cmp	rdx, 8

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN96@filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+72]
	lea	rdx, QWORD PTR [rdx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN106@filesystem

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	$LN164@filesystem

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN106@filesystem:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN96@filesystem:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+88], rdi

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+96], 7

; 211  :         _Left = _Right;

	mov	WORD PTR [rbx+72], di

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rbx+64]
	cmp	rdx, 8

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN157@filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx+40]
	lea	rdx, QWORD PTR [rdx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN167@filesystem

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN164@filesystem

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN167@filesystem:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN157@filesystem:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 85   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rbx+56], rdi

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+64], 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 86   :         __std_exception_destroy(&_Data);

	lea	rcx, QWORD PTR [rbx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 211  :         _Left = _Right;

	mov	WORD PTR [rbx+40], di
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h

; 85   :     {

	mov	QWORD PTR [rbx], rax
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi

; 86   :         __std_exception_destroy(&_Data);

	rex_jmp	QWORD PTR __imp___std_exception_destroy
$LN164@filesystem:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN194@filesystem:
??1filesystem_error@filesystem@std@@UEAA@XZ ENDP	; std::filesystem::filesystem_error::~filesystem_error
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vcruntime_exception.h
;	COMDAT ??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z
_TEXT	SEGMENT
$T1 = 32
this$ = 64
__that$ = 72
??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z PROC ; std::filesystem::filesystem_error::filesystem_error, COMDAT
$LN20:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T1[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	rbx, rdx
	mov	rdi, rcx

; 68   :     {

	lea	rax, OFFSET FLAT:??_7exception@std@@6B@
	mov	QWORD PTR [rcx], rax

; 67   :         : _Data()

	lea	rdx, QWORD PTR [rcx+8]
	vpxor	xmm0, xmm0, xmm0
	vmovups	XMMWORD PTR [rdx], xmm0

; 69   :         __std_exception_copy(&_Other._Data, &_Data);

	lea	rcx, QWORD PTR [rbx+8]
	call	QWORD PTR __imp___std_exception_copy
	lea	rax, OFFSET FLAT:??_7_System_error@std@@6B@
	mov	QWORD PTR [rdi], rax
	vmovups	xmm0, XMMWORD PTR [rbx+24]
	vmovups	XMMWORD PTR [rdi+24], xmm0
	lea	rax, OFFSET FLAT:??_7filesystem_error@filesystem@std@@6B@
	mov	QWORD PTR [rdi], rax
	lea	rcx, QWORD PTR [rdi+40]
	lea	rdx, QWORD PTR [rbx+40]
	call	??0path@filesystem@std@@QEAA@AEBV012@@Z	; std::filesystem::path::path
	npad	1
	lea	rcx, QWORD PTR [rdi+72]
	lea	rdx, QWORD PTR [rbx+72]
	call	??0path@filesystem@std@@QEAA@AEBV012@@Z	; std::filesystem::path::path
	npad	1
	lea	rcx, QWORD PTR [rdi+104]
	lea	rdx, QWORD PTR [rbx+104]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z ENDP ; std::filesystem::filesystem_error::filesystem_error
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__that$ = 72
?dtor$0@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1system_error@std@@UEAA@XZ
?dtor$0@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$0
$T1 = 32
this$ = 64
__that$ = 72
?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$1
$T1 = 32
this$ = 64
__that$ = 72
?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 72					; 00000048H
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__that$ = 72
?dtor$0@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1system_error@std@@UEAA@XZ
?dtor$0@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__that$ = 72
?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$1
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 40					; 00000028H
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$1@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$ = 64
__that$ = 72
?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA PROC ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$2
	mov	rcx, QWORD PTR this$[rdx]
	add	rcx, 72					; 00000048H
	jmp	??1path@filesystem@std@@QEAA@XZ		; std::filesystem::path::~path
?dtor$2@?0???0filesystem_error@filesystem@std@@QEAA@AEBV012@@Z@4HA ENDP ; `std::filesystem::filesystem_error::filesystem_error'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z
_TEXT	SEGMENT
$T12 = 32
$T4 = 32
$T13 = 48
$T1 = 56
$T3 = 72
$T5 = 112
_Op$dead$ = 272
_Error$ = 280
_Path1$ = 288
?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z PROC ; std::filesystem::_Throw_fs_error, COMDAT

; 1805 :     [[noreturn]] inline void _Throw_fs_error(const char* _Op, __std_win_error _Error, const path& _Path1) {

$LN63:
	push	rbx
	sub	rsp, 256				; 00000100H
	mov	QWORD PTR $T13[rsp], -2
	mov	rbx, r8

; 1806 :         _THROW(filesystem_error(_Op, _Path1, _Make_ec(_Error)));

	lea	rcx, QWORD PTR $T1[rsp]
	call	?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z ; std::filesystem::_Make_ec
	vmovups	xmm0, XMMWORD PTR [rax]
	vmovups	XMMWORD PTR $T12[rsp], xmm0
	lea	rdx, OFFSET FLAT:??_C@_09CKOOOICH@file_size@
	lea	rcx, QWORD PTR $T3[rsp]
	call	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
	npad	1
	vmovups	xmm0, XMMWORD PTR $T12[rsp]
	vmovups	XMMWORD PTR $T4[rsp], xmm0
	lea	r9, QWORD PTR $T4[rsp]
	mov	r8, rbx
	lea	rdx, QWORD PTR $T3[rsp]
	lea	rcx, QWORD PTR $T5[rsp]
	call	??0filesystem_error@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBVpath@12@Verror_code@2@@Z ; std::filesystem::filesystem_error::filesystem_error
	lea	rdx, OFFSET FLAT:_TI5?AVfilesystem_error@filesystem@std@@
	lea	rcx, QWORD PTR $T5[rsp]
	call	_CxxThrowException
	int	3
$LN62@Throw_fs_e:
?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z ENDP ; std::filesystem::_Throw_fs_error
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T12 = 32
$T4 = 32
$T13 = 48
$T1 = 56
$T3 = 72
$T5 = 112
_Op$dead$ = 272
_Error$ = 280
_Path1$ = 288
?dtor$0@?0??_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z@4HA PROC ; `std::filesystem::_Throw_fs_error'::`1'::dtor$0
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z@4HA ENDP ; `std::filesystem::_Throw_fs_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T12 = 32
$T4 = 32
$T13 = 48
$T1 = 56
$T3 = 72
$T5 = 112
_Op$dead$ = 272
_Error$ = 280
_Path1$ = 288
?dtor$0@?0??_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z@4HA PROC ; `std::filesystem::_Throw_fs_error'::`1'::dtor$0
	lea	rcx, QWORD PTR $T3[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z@4HA ENDP ; `std::filesystem::_Throw_fs_error'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ?_File_size@filesystem@std@@YA?AW4__std_win_error@@AEBVpath@12@AEA_K@Z
_TEXT	SEGMENT
_Stats$ = 32
__$ArrayPad$ = 64
_Path$ = 96
_Result$ = 104
?_File_size@filesystem@std@@YA?AW4__std_win_error@@AEBVpath@12@AEA_K@Z PROC ; std::filesystem::_File_size, COMDAT

; 3360 :     _NODISCARD inline __std_win_error _File_size(const path& _Path, uintmax_t& _Result) noexcept {

$LN24:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 3360 :     _NODISCARD inline __std_win_error _File_size(const path& _Path, uintmax_t& _Result) noexcept {

	mov	rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN16@File_size
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rcx, QWORD PTR [rcx]
$LN16@File_size:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 3362 :         const auto _Error = __std_fs_get_stats(

	mov	r9d, -1					; ffffffffH
	lea	rdx, QWORD PTR _Stats$[rsp]
	mov	r8d, 9
	call	__std_fs_get_stats

; 3363 :             _Path.c_str(), &_Stats, __std_fs_stats_flags::_Follow_symlinks | __std_fs_stats_flags::_File_size);
; 3364 :         if (_Error == __std_win_error::_Success) {

	test	eax, eax
	mov	rcx, -1
	cmove	rcx, QWORD PTR _Stats$[rsp+8]
	mov	QWORD PTR [rbx], rcx

; 3365 :             _Result = _Stats._File_size;
; 3366 :         } else {
; 3367 :             _Result = static_cast<uintmax_t>(-1);
; 3368 :         }
; 3369 : 
; 3370 :         return _Error;
; 3371 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
?_File_size@filesystem@std@@YA?AW4__std_win_error@@AEBVpath@12@AEA_K@Z ENDP ; std::filesystem::_File_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ?file_size@filesystem@std@@YA_KAEBVpath@12@@Z
_TEXT	SEGMENT
_Stats$6 = 32
__$ArrayPad$ = 64
_Path$ = 96
?file_size@filesystem@std@@YA_KAEBVpath@12@@Z PROC	; std::filesystem::file_size, COMDAT

; 3373 :     _NODISCARD inline uintmax_t file_size(const path& _Path) {

$LN29:
	push	rbx
	sub	rsp, 80					; 00000050H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 3373 :     _NODISCARD inline uintmax_t file_size(const path& _Path) {

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN19@file_size
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rcx, QWORD PTR [rcx]
$LN19@file_size:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 3362 :         const auto _Error = __std_fs_get_stats(

	mov	r9d, -1					; ffffffffH
	lea	rdx, QWORD PTR _Stats$6[rsp]
	mov	r8d, 9
	call	__std_fs_get_stats

; 3363 :             _Path.c_str(), &_Stats, __std_fs_stats_flags::_Follow_symlinks | __std_fs_stats_flags::_File_size);
; 3364 :         if (_Error == __std_win_error::_Success) {

	test	eax, eax
	jne	SHORT $LN27@file_size

; 3378 :         }
; 3379 : 
; 3380 :         return _Result;

	mov	rax, QWORD PTR _Stats$6[rsp+8]

; 3381 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 80					; 00000050H
	pop	rbx
	ret	0
$LN27@file_size:

; 3374 :         uintmax_t _Result;
; 3375 :         const auto _Error = _File_size(_Path, _Result);
; 3376 :         if (_Error != __std_win_error::_Success) {
; 3377 :             _Throw_fs_error("file_size", _Error, _Path);

	mov	r8, rbx
	mov	edx, eax
	call	?_Throw_fs_error@filesystem@std@@YAXPEBDW4__std_win_error@@AEBVpath@12@@Z ; std::filesystem::_Throw_fs_error
	int	3
$LN25@file_size:
?file_size@filesystem@std@@YA_KAEBVpath@12@@Z ENDP	; std::filesystem::file_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ??0Timer@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0Timer@@QEAA@XZ PROC					; Timer::Timer, COMDAT

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
	mov	rax, rcx
	ret	0
??0Timer@@QEAA@XZ ENDP					; Timer::Timer
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Users\Petr\Desktop\PPR\src\utils\timer.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
; File C:\Users\Petr\Desktop\PPR\src\utils\timer.h
;	COMDAT ??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@XZ PROC ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	mov	QWORD PTR [rcx], 0
; File C:\Users\Petr\Desktop\PPR\src\utils\timer.h

; 19   : static Timer t;

	mov	rax, rcx
	ret	0
??0?$time_point@Usteady_clock@chrono@std@@V?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@23@@chrono@std@@QEAA@XZ ENDP ; std::chrono::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >::time_point<std::chrono::steady_clock,std::chrono::duration<__int64,std::ratio<1,1000000000> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 906  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept { // destroy the object

	mov	rax, QWORD PTR [rcx]
	lea	rbx, QWORD PTR [rcx+176]

; 907  :     }

	lea	rcx, QWORD PTR [rbx-160]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rdx+rbx-176], rax
	mov	rax, QWORD PTR [rbx-176]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	r8d, DWORD PTR [rdx-176]
	mov	DWORD PTR [rdx+rbx-180], r8d
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	rcx, QWORD PTR [rbx-152]
	call	QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	mov	rcx, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	rex_jmp	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
	xor	edx, edx
	mov	r8d, 272				; 00000110H
	jmp	memset
?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$vector@DV?$allocator@D@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$vector@DV?$allocator@D@std@@@std@@QEAAX_K@Z PROC ; std::vector<char,std::allocator<char> >::__autoclassinit2, COMDAT
	vpxor	xmm0, xmm0, xmm0
	xor	eax, eax
	vmovups	XMMWORD PTR [rcx], xmm0
	mov	QWORD PTR [rcx+16], rax
	ret	0
?__autoclassinit2@?$vector@DV?$allocator@D@std@@@std@@QEAAX_K@Z ENDP ; std::vector<char,std::allocator<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??0Numbers@@QEAA@$$QEAU0@@Z
_TEXT	SEGMENT
this$ = 8
__that$ = 16
??0Numbers@@QEAA@$$QEAU0@@Z PROC			; Numbers::Numbers, COMDAT
	mov	eax, DWORD PTR [rdx]

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	xor	r8d, r8d
	mov	DWORD PTR [rcx], eax
	mov	eax, DWORD PTR [rdx+4]
	mov	DWORD PTR [rcx+4], eax
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r8
	mov	QWORD PTR [rcx+24], r8

; 491  :         _My_data._Myfirst = _Right_data._Myfirst;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 492  :         _My_data._Mylast  = _Right_data._Mylast;

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax

; 493  :         _My_data._Myend   = _Right_data._Myend;

	mov	rax, QWORD PTR [rdx+24]
	mov	QWORD PTR [rcx+24], rax
	mov	rax, rcx

; 494  : 
; 495  :         _Right_data._Myfirst = pointer();

	mov	QWORD PTR [rdx+8], r8

; 496  :         _Right_data._Mylast  = pointer();

	mov	QWORD PTR [rdx+16], r8

; 497  :         _Right_data._Myend   = pointer();

	mov	QWORD PTR [rdx+24], r8
	ret	0
??0Numbers@@QEAA@$$QEAU0@@Z ENDP			; Numbers::Numbers
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?data@?$vector@DV?$allocator@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?data@?$vector@DV?$allocator@D@std@@@std@@QEAAPEADXZ PROC ; std::vector<char,std::allocator<char> >::data, COMDAT

; 1260 :         return _Unfancy_maybe_null(_Myfirst());

	mov	rax, QWORD PTR [rcx]

; 1261 :     }

	ret	0
?data@?$vector@DV?$allocator@D@std@@@std@@QEAAPEADXZ ENDP ; std::vector<char,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ PROC	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >, COMDAT

; 609  :     ~vector() noexcept { // destroy the object

$LN52:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1525 :         const auto _First = _My_data._Myfirst;

	mov	rcx, QWORD PTR [rcx]

; 1526 :         if (_First != pointer()) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN4@vector

; 1527 :             _Destroy(_First, _My_data._Mylast);
; 1528 :             _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN44@vector

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN41@vector

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN44@vector:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1530 :             _My_data._Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1531 :             _My_data._Mylast  = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1532 :             _My_data._Myend   = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN4@vector:

; 615  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN41@vector:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN49@vector:
??1?$vector@DV?$allocator@D@std@@@std@@QEAA@XZ ENDP	; std::vector<char,std::allocator<char> >::~vector<char,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??0?$vector@DV?$allocator@D@std@@@std@@QEAA@_KAEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
_Al$dead$ = 64
??0?$vector@DV?$allocator@D@std@@@std@@QEAA@_KAEBV?$allocator@D@1@@Z PROC ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >, COMDAT

; 397  :     explicit vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al = _Alloc())

$LN151:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 32					; 00000020H

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	xor	eax, eax

; 397  :     explicit vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Alloc& _Al = _Alloc())

	mov	rdi, rcx

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	mov	ecx, 800				; 00000320H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	mov	QWORD PTR [rdi], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8d, 800				; 00000320H
	mov	rcx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	rbx, QWORD PTR [rax+800]
	mov	QWORD PTR [rdi+16], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	call	memset
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 389  :             _Mylast()      = _Ufill(_Myfirst(), _Count, _Val);

	mov	QWORD PTR [rdi+8], rbx

; 398  :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct from _Count * _Ty(), optional allocator
; 399  :         _Construct_n_copies_of_ty(_Count, _Value_init_tag{});
; 400  :     }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??0?$vector@DV?$allocator@D@std@@@std@@QEAA@_KAEBV?$allocator@D@1@@Z ENDP ; std::vector<char,std::allocator<char> >::vector<char,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?push_back@?$vector@NV?$allocator@N@std@@@std@@QEAAXAEBN@Z
_TEXT	SEGMENT
this$ = 8
_Val$ = 16
?push_back@?$vector@NV?$allocator@N@std@@@std@@QEAAXAEBN@Z PROC ; std::vector<double,std::allocator<double> >::push_back, COMDAT

; 649  :     void push_back(const _Ty& _Val) { // insert element at end, provide strong guarantee

	mov	r8, rdx

; 1357 :         return _Myend() != _Mylast();

	mov	rdx, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx+16], rdx

; 637  :         if (_Has_unused_capacity()) {

	je	SHORT $LN4@push_back
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 625  :         ++_Mylast();

	lea	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 650  :         emplace_back(_Val);
; 651  :     }

	ret	0
$LN4@push_back:

; 641  :         _Ty& _Result = *_Emplace_reallocate(_Mylast(), _STD forward<_Valty>(_Val)...);

	jmp	??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z ; std::vector<double,std::allocator<double> >::_Emplace_reallocate<double const &>
?push_back@?$vector@NV?$allocator@N@std@@@std@@QEAAXAEBN@Z ENDP ; std::vector<double,std::allocator<double> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??$emplace_back@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAAEANAEBN@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$emplace_back@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAAEANAEBN@Z PROC ; std::vector<double,std::allocator<double> >::emplace_back<double const &>, COMDAT

; 1357 :         return _Myend() != _Mylast();

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx+16], rax

; 637  :         if (_Has_unused_capacity()) {

	je	SHORT $LN2@emplace_ba
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	rdx, QWORD PTR [rdx]
	mov	QWORD PTR [rax], rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 625  :         ++_Mylast();

	lea	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+8], rdx

; 642  : #if _HAS_CXX17
; 643  :         return _Result;
; 644  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 645  :         (void) _Result;
; 646  : #endif // _HAS_CXX17
; 647  :     }

	ret	0
$LN2@emplace_ba:

; 638  :             return _Emplace_back_with_unused_capacity(_STD forward<_Valty>(_Val)...);
; 639  :         }
; 640  : 
; 641  :         _Ty& _Result = *_Emplace_reallocate(_Mylast(), _STD forward<_Valty>(_Val)...);

	mov	r8, rdx
	mov	rdx, rax
	jmp	??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z ; std::vector<double,std::allocator<double> >::_Emplace_reallocate<double const &>
??$emplace_back@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAAEANAEBN@Z ENDP ; std::vector<double,std::allocator<double> >::emplace_back<double const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??$_Emplace_back_with_unused_capacity@AEBN@?$vector@NV?$allocator@N@std@@@std@@AEAAAEANAEBN@Z
_TEXT	SEGMENT
this$ = 8
<_Val_0>$ = 16
??$_Emplace_back_with_unused_capacity@AEBN@?$vector@NV?$allocator@N@std@@@std@@AEAAAEANAEBN@Z PROC ; std::vector<double,std::allocator<double> >::_Emplace_back_with_unused_capacity<double const &>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rax, QWORD PTR [rcx+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	rdx, QWORD PTR [rdx]
	mov	QWORD PTR [rax], rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 625  :         ++_Mylast();

	lea	rdx, QWORD PTR [rax+8]
	mov	QWORD PTR [rcx+8], rdx

; 626  : #if _HAS_CXX17
; 627  :         return _Result;
; 628  : #else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
; 629  :         (void) _Result;
; 630  : #endif // _HAS_CXX17
; 631  :     }

	ret	0
??$_Emplace_back_with_unused_capacity@AEBN@?$vector@NV?$allocator@N@std@@@std@@AEAAAEANAEBN@Z ENDP ; std::vector<double,std::allocator<double> >::_Emplace_back_with_unused_capacity<double const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??0?$vector@NV?$allocator@N@std@@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$vector@NV?$allocator@N@std@@@std@@QEAA@$$QEAV01@@Z PROC ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >, COMDAT

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	xor	r8d, r8d
	mov	QWORD PTR [rcx], r8
	mov	QWORD PTR [rcx+8], r8
	mov	QWORD PTR [rcx+16], r8

; 491  :         _My_data._Myfirst = _Right_data._Myfirst;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 492  :         _My_data._Mylast  = _Right_data._Mylast;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 493  :         _My_data._Myend   = _Right_data._Myend;

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax

; 524  :         : _Mypair(_One_then_variadic_args_t(), _STD move(_Right._Getal())) { // construct by moving _Right
; 525  :         _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 526  :         _Move_construct(_Right, true_type{});
; 527  :     }

	mov	rax, rcx

; 495  :         _Right_data._Myfirst = pointer();

	mov	QWORD PTR [rdx], r8

; 496  :         _Right_data._Mylast  = pointer();

	mov	QWORD PTR [rdx+8], r8

; 497  :         _Right_data._Myend   = pointer();

	mov	QWORD PTR [rdx+16], r8

; 524  :         : _Mypair(_One_then_variadic_args_t(), _STD move(_Right._Getal())) { // construct by moving _Right
; 525  :         _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 526  :         _Move_construct(_Right, true_type{});
; 527  :     }

	ret	0
??0?$vector@NV?$allocator@N@std@@@std@@QEAA@$$QEAV01@@Z ENDP ; std::vector<double,std::allocator<double> >::vector<double,std::allocator<double> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ
_TEXT	SEGMENT
__$ReturnUdt$ = 8
?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ PROC ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::zero, COMDAT

; 76   :             : _MyRep(static_cast<_Rep>(_Val)) { // construct from representation

	mov	QWORD PTR [rcx], 0

; 148  :             // get zero value
; 149  :             return duration(duration_values<_Rep>::zero());

	mov	rax, rcx

; 150  :         }

	ret	0
?zero@?$duration@_JU?$ratio@$00$0DLJKMKAA@@std@@@chrono@std@@SA?AV123@XZ ENDP ; std::chrono::duration<__int64,std::ratio<1,1000000000> >::zero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Orphan_all@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Orphan_all, COMDAT

; 3891 :         _Get_data()._Orphan_all();
; 3892 :     }

	ret	0
?_Orphan_all@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
_Ch$dead$ = 80
?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize, COMDAT

; 3276 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Elem _Ch = _Elem()) {

$LN55:
	push	rdi
	sub	rsp, 48					; 00000030H

; 3264 :         return _Get_data()._Mysize;

	mov	r10, QWORD PTR [rcx+16]
	lea	r9, QWORD PTR [rcx+16]

; 3276 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Elem _Ch = _Elem()) {

	mov	r8, rcx

; 3264 :         return _Get_data()._Mysize;

	mov	rcx, QWORD PTR [rcx+24]

; 3276 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Elem _Ch = _Elem()) {

	mov	rdi, rdx

; 3277 :         // determine new length, padding with _Ch elements as needed
; 3278 :         const size_type _Old_size = size();
; 3279 :         if (_Newsize <= _Old_size) {

	cmp	rdx, r10
	ja	SHORT $LN2@resize

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	rcx, 8

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN18@resize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	r8, QWORD PTR [r8]
$LN18@resize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3856 :         _Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [r9], rdi

; 211  :         _Left = _Right;

	xor	r9d, r9d
	mov	WORD PTR [r8+rdx*2], r9w

; 3283 :         }
; 3284 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN2@resize:

; 2633 :         if (_Count <= _My_data._Myres - _Old_size) {

	mov	rax, rcx

; 3280 :             _Eos(_Newsize);
; 3281 :         } else {
; 3282 :             append(_Newsize - _Old_size, _Ch);

	sub	rdx, r10

; 2633 :         if (_Count <= _My_data._Myres - _Old_size) {

	sub	rax, r10
	cmp	rdx, rax
	ja	SHORT $LN27@resize

; 2634 :             _My_data._Mysize      = _Old_size + _Count;

	mov	QWORD PTR [r9], rdi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	rcx, 8

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN34@resize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	r8, QWORD PTR [r8]
$LN34@resize:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	xor	r9d, r9d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2636 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	lea	rdi, QWORD PTR [r8+r10*2]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	test	rdx, rdx
	je	SHORT $LN45@resize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 207  :         return reinterpret_cast<_Elem*>(_CSTD wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));

	movzx	eax, r9w
	mov	rcx, rdx
	rep stosw
$LN45@resize:

; 2637 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());

	lea	rax, QWORD PTR [r10+rdx]

; 211  :         _Left = _Right;

	mov	WORD PTR [r8+rax*2], r9w

; 3283 :         }
; 3284 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN27@resize:

; 2641 :         return _Reallocate_grow_by(_Count,

	mov	r9, rdx
	mov	rcx, r8
	call	??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_a3050a43f3157934f354774ab3dd2e02>,unsigned __int64,wchar_t>

; 3283 :         }
; 3284 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?resize@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAX_K_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size, COMDAT

; 3268 :         const size_type _Alloc_max   = _Alty_traits::max_size(_Getal());
; 3269 :         const size_type _Storage_max = // can always store small string
; 3270 :             _Max_value(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
; 3271 :         return _Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()),

	mov	rax, 9223372036854775806		; 7ffffffffffffffeH

; 3272 :             _Storage_max - 1 // -1 is for null terminator and/or npos
; 3273 :         );
; 3274 :     }

	ret	0
?max_size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size, COMDAT

; 3264 :         return _Get_data()._Mysize;

	mov	rax, QWORD PTR [rcx+16]

; 3265 :     }

	ret	0
?size@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA_KXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEA_WXZ
_TEXT	SEGMENT
this$ = 8
?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEA_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data, COMDAT

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN14@data

; 3255 :         return _Get_data()._Myptr();

	mov	rax, QWORD PTR [rcx]

; 3256 :     }

	ret	0
$LN14@data:

; 3255 :         return _Get_data()._Myptr();

	mov	rax, rcx

; 3256 :     }

	ret	0
?data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAPEA_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
this$ = 8
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str, COMDAT

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN14@c_str

; 3246 :         return _Get_data()._Myptr();

	mov	rax, QWORD PTR [rcx]

; 3247 :     }

	ret	0
$LN14@c_str:

; 3246 :         return _Get_data()._Myptr();

	mov	rax, rcx

; 3247 :     }

	ret	0
?c_str@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBAPEB_WXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator std::basic_string_view<wchar_t,std::char_traits<wchar_t> >, COMDAT

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 3195 :         auto& _My_data = _Get_data();
; 3196 :         return basic_string_view<_Elem, _Traits>(_My_data._Myptr(), _My_data._Mysize);

	mov	rax, QWORD PTR [rcx+16]

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rcx, QWORD PTR [rcx]
$LN8@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 1141 :           _Mysize(_Count) { // construct basic_string_view around a character-type sequence with explicit size

	mov	QWORD PTR [rdx+8], rax

; 3195 :         auto& _My_data = _Get_data();
; 3196 :         return basic_string_view<_Elem, _Traits>(_My_data._Myptr(), _My_data._Mysize);

	mov	rax, rdx

; 1140 :         : _Mydata(_Cts),

	mov	QWORD PTR [rdx], rcx

; 3197 :     }

	ret	0
??B?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEBA?AV?$basic_string_view@_WU?$char_traits@_W@std@@@1@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::operator std::basic_string_view<wchar_t,std::char_traits<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2497 :     ~basic_string() noexcept { // destroy the string

$LN60:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rcx+24]

; 2497 :     ~basic_string() noexcept { // destroy the string

	mov	rbx, rcx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 8

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN32@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN42@basic_stri

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN39@basic_stri

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN42@basic_stri:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN32@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	xor	eax, eax

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7
	mov	QWORD PTR [rbx+16], rax

; 211  :         _Left = _Right;

	mov	WORD PTR [rbx], ax

; 2503 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN39@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN57@basic_stri:
??1?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::~basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [rdx]
	vmovups	YMMWORD PTR [rcx], ymm0

; 3861 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdx+16], rax

; 211  :         _Left = _Right;

	mov	WORD PTR [rdx], ax

; 2297 :         : _Mypair(_One_then_variadic_args_t(), _STD move(_Right._Getal())) { // construct by moving _Right
; 2298 :         _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2299 :         _Take_contents(_Right, _Use_memcpy_move{});
; 2300 :     }

	mov	rax, rcx

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 7
	vzeroupper

; 2297 :         : _Mypair(_One_then_variadic_args_t(), _STD move(_Right._Getal())) { // construct by moving _Right
; 2298 :         _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2299 :         _Take_contents(_Right, _Use_memcpy_move{});
; 2300 :     }

	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 3861 :         _My_data._Mysize = 0;

	xor	eax, eax

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7
	mov	QWORD PTR [rcx+16], rax

; 211  :         _Left = _Right;

	mov	WORD PTR [rcx], ax

; 2161 :         : _Mypair(_Zero_then_variadic_args_t()) { // construct empty string
; 2162 :         _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2163 :         _Tidy_init();
; 2164 :     }

	mov	rax, rcx
	ret	0
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >, COMDAT

; 2145 :               _Alty_traits::select_on_container_copy_construction(_Right._Getal())) { // construct by copying _Right

$LN111:
	push	rbx
	push	rbp
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rdi, rdx

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	xor	ecx, ecx
	mov	QWORD PTR [rbx+16], rcx
	mov	QWORD PTR [rbx+24], rcx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 8

; 2441 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	rbp, QWORD PTR [rdx+16]

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN33@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rdi, QWORD PTR [rdx]
$LN33@basic_stri:
	mov	QWORD PTR [rsp+80], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2443 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

	cmp	rbp, 8
	jae	SHORT $LN22@basic_stri
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	vmovups	xmm0, XMMWORD PTR [rdi]
	vmovups	XMMWORD PTR [rbx], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2446 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	esi, 7

; 2447 :             return;

	jmp	$LN21@basic_stri
$LN22@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	mov	rax, 9223372036854775806		; 7ffffffffffffffeH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	mov	rsi, rbp
	or	rsi, 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	mov	r8, 9223372036854775807			; 7fffffffffffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmp	rsi, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	mov	r9, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmova	rsi, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2452 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	lea	rax, QWORD PTR [rsi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 25   :     size_t _Result                 = _Count * _Ty_size;

	lea	rdx, QWORD PTR [rax+rax]

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	cmp	rax, r8
	jbe	SHORT $LN66@basic_stri

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);

	mov	rdx, r9

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	jmp	SHORT $LN107@basic_stri
$LN66@basic_stri:
	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN69@basic_stri
$LN107@basic_stri:

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	cmp	rcx, rdx
	cmovbe	rcx, r9

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN78@basic_stri

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rcx, QWORD PTR [rax+39]
	and	rcx, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rcx-8], rax

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN70@basic_stri
$LN78@basic_stri:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN69@basic_stri:

; 178  :     if (_Bytes != 0) {

	test	rdx, rdx
	je	SHORT $LN70@basic_stri

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rdx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax
$LN70@basic_stri:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	r8, QWORD PTR [rbp*2+2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	QWORD PTR [rbx], rcx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	rdx, rdi
	call	memcpy
$LN21@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2150 :     }

	mov	QWORD PTR [rbx+16], rbp
	mov	rax, rbx
	mov	QWORD PTR [rbx+24], rsi
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN108@basic_stri:
??0?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty, COMDAT

; 3321 :         return size() == 0;

	cmp	QWORD PTR [rcx+16], 0
	sete	al

; 3322 :     }

	ret	0
?empty@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z
_TEXT	SEGMENT
this$ = 64
_Newsize$ = 72
_Ch$dead$ = 80
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize, COMDAT

; 3276 :     void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Elem _Ch = _Elem()) {

$LN47:
	sub	rsp, 56					; 00000038H

; 3264 :         return _Get_data()._Mysize;

	mov	r10, QWORD PTR [rcx+16]
	lea	r8, QWORD PTR [rcx+16]
	mov	r9, QWORD PTR [rcx+24]

; 3277 :         // determine new length, padding with _Ch elements as needed
; 3278 :         const size_type _Old_size = size();
; 3279 :         if (_Newsize <= _Old_size) {

	cmp	rdx, r10
	ja	SHORT $LN2@resize

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	r9, 16

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN18@resize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rcx, QWORD PTR [rcx]
$LN18@resize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3856 :         _Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [r8], rdx

; 343  :         _Left = _Right;

	mov	BYTE PTR [rcx+rdx], 0

; 3283 :         }
; 3284 :     }

	add	rsp, 56					; 00000038H
	ret	0
$LN2@resize:
	mov	QWORD PTR [rsp+48], rdi

; 2633 :         if (_Count <= _My_data._Myres - _Old_size) {

	mov	rax, r9

; 3280 :             _Eos(_Newsize);
; 3281 :         } else {
; 3282 :             append(_Newsize - _Old_size, _Ch);

	mov	rdi, rdx

; 2633 :         if (_Count <= _My_data._Myres - _Old_size) {

	sub	rax, r10

; 3280 :             _Eos(_Newsize);
; 3281 :         } else {
; 3282 :             append(_Newsize - _Old_size, _Ch);

	sub	rdi, r10

; 2633 :         if (_Count <= _My_data._Myres - _Old_size) {

	cmp	rdi, rax
	ja	SHORT $LN27@resize

; 2634 :             _My_data._Mysize      = _Old_size + _Count;

	mov	QWORD PTR [rsp+64], rbx
	mov	QWORD PTR [r8], rdx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	r9, 16

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN34@resize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rcx, QWORD PTR [rcx]
$LN34@resize:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2636 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	lea	rbx, QWORD PTR [rcx+r10]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8, rdi
	mov	rcx, rbx
	xor	edx, edx
	call	memset

; 343  :         _Left = _Right;

	mov	BYTE PTR [rbx+rdi], 0
	mov	rbx, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+48]

; 3283 :         }
; 3284 :     }

	add	rsp, 56					; 00000038H
	ret	0
$LN27@resize:

; 2641 :         return _Reallocate_grow_by(_Count,

	mov	r9, rdi
	mov	rdx, rdi
	call	??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
	mov	rdi, QWORD PTR [rsp+48]

; 3283 :         }
; 3284 :     }

	add	rsp, 56					; 00000038H
	ret	0
?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN14@c_str

; 3246 :         return _Get_data()._Myptr();

	mov	rax, QWORD PTR [rcx]

; 3247 :     }

	ret	0
$LN14@c_str:

; 3246 :         return _Get_data()._Myptr();

	mov	rax, rcx

; 3247 :     }

	ret	0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN14@operator

; 3177 :         auto& _My_data = _Get_data();
; 3178 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 3179 :         _STL_VERIFY(_Off <= _My_data._Mysize, "string subscript out of range");
; 3180 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 3181 :         return _My_data._Myptr()[_Off];

	mov	rax, QWORD PTR [rcx]

; 3182 :     }

	ret	0
$LN14@operator:

; 3177 :         auto& _My_data = _Get_data();
; 3178 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 3179 :         _STL_VERIFY(_Off <= _My_data._Mysize, "string subscript out of range");
; 3180 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 3181 :         return _My_data._Myptr()[_Off];

	mov	rax, rcx

; 3182 :     }

	ret	0
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::shrink_to_fit, COMDAT

; 3141 :     void shrink_to_fit() { // reduce capacity

$LN132:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rax, QWORD PTR [rcx+24]

; 3141 :     void shrink_to_fit() { // reduce capacity

	mov	rbx, rcx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	rax, 16

; 3142 :         auto& _My_data = _Get_data();
; 3143 :         if (!_My_data._Large_string_engaged()) { // can't shrink from small mode

	jb	$LN4@shrink_to_

; 3144 :             return;
; 3145 :         }
; 3146 : 
; 3147 :         if (_My_data._Mysize < _BUF_SIZE) {

	mov	QWORD PTR [rsp+56], rsi
	mov	rsi, QWORD PTR [rcx+16]
	mov	QWORD PTR [rsp+64], rdi
	cmp	rsi, 16
	jae	SHORT $LN3@shrink_to_

; 3846 :         const pointer _Ptr = _My_data._Bx._Ptr;

	mov	rdi, QWORD PTR [rcx]

; 3847 :         auto& _Al          = _Getal();
; 3848 :         _Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3849 :         _Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

	lea	r8, QWORD PTR [rsi+1]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, rdi
	call	memcpy

; 3850 :         _Al.deallocate(_Ptr, _My_data._Myres + 1);

	mov	rdx, QWORD PTR [rbx+24]
	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN46@shrink_to_

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdi-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rdi, rcx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rdi-8]
	cmp	rax, 31
	ja	$LN121@shrink_to_

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rdi, rcx
$LN46@shrink_to_:

; 195  :     ::operator delete(_Ptr, _Bytes);

	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3851 :         _My_data._Myres = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 15

; 3162 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@shrink_to_:

; 3148 :             _Become_small();
; 3149 :             return;
; 3150 :         }
; 3151 : 
; 3152 :         const size_type _Target_capacity = _Min_value(_My_data._Mysize | _ALLOC_MASK, max_size());

	or	rsi, 15
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	cmp	rsi, rcx
	cmova	rsi, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3153 :         if (_Target_capacity < _My_data._Myres) { // worth shrinking, do it

	cmp	rsi, rax
	jae	$LN128@shrink_to_

; 3154 :             auto& _Al              = _Getal();
; 3155 :             const pointer _New_ptr = _Al.allocate(_Target_capacity + 1); // throws

	lea	rax, QWORD PTR [rsi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN76@shrink_to_

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	mov	rdx, -1
	cmp	rcx, rax
	cmovbe	rcx, rdx

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN121@shrink_to_

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN75@shrink_to_
$LN76@shrink_to_:

; 175  :     }
; 176  : #endif // defined(_M_IX86) || defined(_M_X64)
; 177  : 
; 178  :     if (_Bytes != 0) {

	test	rax, rax
	je	SHORT $LN77@shrink_to_

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 179  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN75@shrink_to_
$LN77@shrink_to_:

; 180  :     }
; 181  : 
; 182  :     return nullptr;

	xor	edi, edi
$LN75@shrink_to_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3157 :             _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);

	mov	r8, QWORD PTR [rbx+16]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rcx, rdi
	mov	rdx, QWORD PTR [rbx]

; 3157 :             _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);

	inc	r8

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	call	memcpy

; 3158 :             _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);

	mov	rdx, QWORD PTR [rbx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3158 :             _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN124@shrink_to_

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN121@shrink_to_

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN124@shrink_to_:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3159 :             _My_data._Bx._Ptr = _New_ptr;

	mov	QWORD PTR [rbx], rdi

; 3160 :             _My_data._Myres   = _Target_capacity;

	mov	QWORD PTR [rbx+24], rsi
$LN128@shrink_to_:
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+64]
$LN4@shrink_to_:

; 3162 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN121@shrink_to_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN129@shrink_to_:
?shrink_to_fit@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::shrink_to_fit
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN24@begin
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rax, QWORD PTR [rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 1707 :         : _Ptr(_Parg) { // construct with pointer _Parg

	mov	QWORD PTR [rdx], rax

; 3068 :         auto _My_data = _STD addressof(_Get_data());
; 3069 :         return iterator(_Refancy<pointer>(_My_data->_Myptr()), _My_data);
; 3070 :     }

	mov	rax, rdx
	ret	0
$LN24@begin:

; 1707 :         : _Ptr(_Parg) { // construct with pointer _Parg

	mov	QWORD PTR [rdx], rcx

; 3068 :         auto _My_data = _STD addressof(_Get_data());
; 3069 :         return iterator(_Refancy<pointer>(_My_data->_Myptr()), _My_data);
; 3070 :     }

	mov	rax, rdx
	ret	0
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$dead$ = 16
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	mov	r8d, 13
	lea	rdx, OFFSET FLAT:??_C@_0O@BFJCFAAK@unknown?5error@
	jmp	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
_Ch$dead$ = 64
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2231 :     basic_string(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch)

$LN160:
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rdi, rcx

; 3861 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 343  :         _Left = _Right;

	mov	BYTE PTR [rcx], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	mov	ecx, 32807				; 00008027H
	call	??2@YAPEAX_K@Z				; operator new

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN106@basic_stri

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	mov	QWORD PTR [rsp+56], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	xor	edx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8d, 32767				; 00007fffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	and	rbx, -32				; ffffffffffffffe0H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	rcx, rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3795 :         _My_data._Mysize = _New_size;

	mov	QWORD PTR [rdi+16], 32767		; 00007fffH

; 3796 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rdi+24], 32767		; 00007fffH

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	call	memset

; 343  :         _Left = _Right;

	mov	BYTE PTR [rbx+32767], 0

; 2238 :     }

	mov	rax, rdi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	QWORD PTR [rdi], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2238 :     }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN106@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN157@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2210 :     basic_string(_In_z_ const _Elem* const _Ptr)

$LN34:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 3861 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 301  :         return __builtin_strlen(_First);

	mov	r8, -1

; 343  :         _Left = _Right;

	mov	BYTE PTR [rcx], 0
$LL31@basic_stri:

; 301  :         return __builtin_strlen(_First);

	inc	r8
	cmp	BYTE PTR [rdx+r8], 0
	jne	SHORT $LL31@basic_stri

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	call	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 2211 :         : _Mypair(_Zero_then_variadic_args_t()) { // construct from [_Ptr, <null>)
; 2212 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2213 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
; 2214 :         _Tidy_init();
; 2215 :         assign(_Ptr);
; 2216 :         _Proxy._Release();
; 2217 :     }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2145 :               _Alty_traits::select_on_container_copy_construction(_Right._Getal())) { // construct by copying _Right

$LN105:
	push	rbx
	push	rbp
	push	rdi
	sub	rsp, 32					; 00000020H

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	xor	eax, eax

; 2145 :               _Alty_traits::select_on_container_copy_construction(_Right._Getal())) { // construct by copying _Right

	mov	rdi, rdx

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	QWORD PTR [rcx+16], rax

; 2145 :               _Alty_traits::select_on_container_copy_construction(_Right._Getal())) { // construct by copying _Right

	mov	rbx, rcx

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	mov	QWORD PTR [rcx+24], rax

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2441 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	rbp, QWORD PTR [rdx+16]

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN33@basic_stri
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rdi, QWORD PTR [rdx]
$LN33@basic_stri:
	mov	QWORD PTR [rsp+80], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2443 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

	cmp	rbp, 16
	jae	SHORT $LN22@basic_stri

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	vmovups	xmm0, XMMWORD PTR [rdi]
	vmovups	XMMWORD PTR [rcx], xmm0

; 2446 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	esi, 15

; 2447 :             return;

	jmp	SHORT $LN21@basic_stri
$LN22@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	mov	rsi, rbp
	or	rsi, 15
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmp	rsi, rcx
	cmova	rsi, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2452 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	lea	rdx, QWORD PTR [rsi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN66@basic_stri

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	mov	rax, -1
	cmp	rcx, rdx
	cmovbe	rcx, rax

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN75@basic_stri

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN67@basic_stri
$LN75@basic_stri:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN66@basic_stri:

; 178  :     if (_Bytes != 0) {

	test	rdx, rdx
	je	SHORT $LN67@basic_stri

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rdx
	call	??2@YAPEAX_K@Z				; operator new
$LN67@basic_stri:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2454 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

	lea	r8, QWORD PTR [rbp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	QWORD PTR [rbx], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, rdi
	mov	rcx, rax
	call	memcpy
$LN21@basic_stri:

; 2146 :         auto&& _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
; 2147 :         _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Get_data());
; 2148 :         _Construct_lv_contents(_Right);
; 2149 :         _Proxy._Release();
; 2150 :     }

	mov	QWORD PTR [rbx+16], rbp
	mov	rax, rbx
	mov	QWORD PTR [rbx+24], rsi
	mov	rsi, QWORD PTR [rsp+80]
	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rbp
	pop	rbx
	ret	0
$LN102@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?empty@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBA_NXZ PROC ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::empty, COMDAT

; 1204 :         return _Mysize == 0;

	cmp	QWORD PTR [rcx+8], 0
	sete	al

; 1205 :     }

	ret	0
?empty@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBA_NXZ ENDP ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBA_KXZ PROC ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size, COMDAT

; 1196 :         return _Mysize;

	mov	rax, QWORD PTR [rcx+8]

; 1197 :     }

	ret	0
?size@?$basic_string_view@_WU?$char_traits@_W@std@@@std@@QEBA_KXZ ENDP ; std::basic_string_view<wchar_t,std::char_traits<wchar_t> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?empty@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?empty@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_string_view<char,std::char_traits<char> >::empty, COMDAT

; 1204 :         return _Mysize == 0;

	cmp	QWORD PTR [rcx+8], 0
	sete	al

; 1205 :     }

	ret	0
?empty@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_string_view<char,std::char_traits<char> >::empty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_KXZ PROC ; std::basic_string_view<char,std::char_traits<char> >::size, COMDAT

; 1196 :         return _Mysize;

	mov	rax, QWORD PTR [rcx+8]

; 1197 :     }

	ret	0
?size@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEBA_KXZ ENDP ; std::basic_string_view<char,std::char_traits<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAA@QEBD_K@Z
_TEXT	SEGMENT
this$ = 8
_Cts$ = 16
_Count$ = 24
??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAA@QEBD_K@Z PROC ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >, COMDAT

; 1140 :         : _Mydata(_Cts),

	mov	QWORD PTR [rcx], rdx

; 1142 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1143 :         _STL_VERIFY(_Count == 0 || _Cts, "non-zero size null string_view");
; 1144 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1145 :     }

	mov	rax, rcx
	mov	QWORD PTR [rcx+8], r8
	ret	0
??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAA@QEBD_K@Z ENDP ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Ntcts$ = 16
??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAA@QEBD@Z PROC ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >, COMDAT

; 302  : #else // _HAS_CXX17
; 303  :         return _CSTD strlen(_First);
; 304  : #endif // _HAS_CXX17
; 305  :     }
; 306  : 
; 307  :     static char* copy(_Out_writes_(_Count) char* const _First1, _In_reads_(_Count) const char* const _First2,
; 308  :         const size_t _Count) noexcept { // strengthened
; 309  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));
; 311  :     }
; 312  : 
; 313  :     _Pre_satisfies_(_Size_in_bytes >= _Count) static char* _Copy_s(_Out_writes_all_(_Size_in_bytes) char* const _First1,
; 314  :         const size_t _Size_in_bytes, _In_reads_(_Count) const char* const _First2,
; 315  :         const size_t _Count) noexcept { // copy [_First2, _First2 + _Count) to [_First1, ...)
; 316  :         _STL_VERIFY(_Count <= _Size_in_bytes, "invalid argument");
; 317  :         return copy(_First1, _First2, _Count);
; 318  :     }
; 319  : 
; 320  :     _NODISCARD static _CONSTEXPR17 const char* find(
; 321  :         _In_reads_(_Count) const char* const _First, const size_t _Count, const char& _Ch) noexcept { // strengthened
; 322  :         // look for _Ch in [_First, _First + _Count)
; 323  : #if _HAS_CXX17
; 324  :         return __builtin_char_memchr(_First, _Ch, _Count);
; 325  : #else // _HAS_CXX17
; 326  :         return static_cast<const char*>(_CSTD memchr(_First, _Ch, _Count));
; 327  : #endif // _HAS_CXX17
; 328  :     }
; 329  : 
; 330  :     static char* move(_Out_writes_all_(_Count) char* const _First1, _In_reads_(_Count) const char* const _First2,
; 331  :         const size_t _Count) noexcept { // strengthened
; 332  :         // copy [_First2, _First2 + _Count) to [_First1, ...)
; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));
; 334  :     }
; 335  : 
; 336  :     static char* assign(
; 337  :         _Out_writes_all_(_Count) char* const _First, const size_t _Count, const char _Ch) noexcept { // strengthened
; 338  :         // assign _Count * _Ch to [_First, ...)
; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));
; 340  :     }
; 341  : 
; 342  :     static _CONSTEXPR17 void assign(char& _Left, const char& _Right) noexcept { // assign an element
; 343  :         _Left = _Right;
; 344  :     }
; 345  : 
; 346  :     _NODISCARD static constexpr bool eq(const char& _Left, const char& _Right) noexcept { // test for element equality
; 347  :         return _Left == _Right;
; 348  :     }
; 349  : 
; 350  :     _NODISCARD static constexpr bool lt(
; 351  :         const char& _Left, const char& _Right) noexcept { // test if _Left precedes _Right
; 352  :         return static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right);
; 353  :     }
; 354  : 
; 355  :     _NODISCARD static constexpr char to_char_type(
; 356  :         const int_type& _Meta) noexcept { // convert metacharacter to character
; 357  :         return static_cast<char>(_Meta);
; 358  :     }
; 359  : 
; 360  :     _NODISCARD static constexpr int_type to_int_type(const char& _Ch) noexcept { // convert character to metacharacter
; 361  :         return static_cast<unsigned char>(_Ch);
; 362  :     }
; 363  : 
; 364  :     _NODISCARD static constexpr bool eq_int_type(
; 365  :         const int_type& _Left, const int_type& _Right) noexcept { // test for metacharacter equality
; 366  :         return _Left == _Right;
; 367  :     }
; 368  : 
; 369  :     _NODISCARD static constexpr int_type not_eof(const int_type& _Meta) noexcept { // return anything but EOF
; 370  :         return _Meta != eof() ? _Meta : !eof();
; 371  :     }
; 372  : 
; 373  :     _NODISCARD static constexpr int_type eof() noexcept { // return end-of-file metacharacter
; 374  :         return EOF;
; 375  :     }
; 376  : };
; 377  : 
; 378  : template <class _Elem, class _Traits, class _SizeT>
; 379  : inline basic_ostream<_Elem, _Traits>& _Insert_string(basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data,
; 380  :     const _SizeT _Size) { // insert a character-type sequence into _Ostr as if through a basic_string copy
; 381  :     using _Ostr_t                    = basic_ostream<_Elem, _Traits>;
; 382  :     typename _Ostr_t::iostate _State = _Ostr_t::goodbit;
; 383  :     _SizeT _Pad                      = _Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size
; 384  :                       ? 0
; 385  :                       : static_cast<_SizeT>(_Ostr.width()) - _Size;
; 386  :     const typename _Ostr_t::sentry _Ok(_Ostr);
; 387  : 
; 388  :     if (!_Ok) {
; 389  :         _State |= _Ostr_t::badbit;
; 390  :     } else { // state okay, insert characters
; 391  :         _TRY_IO_BEGIN
; 392  :         if ((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left) {
; 393  :             for (; 0 < _Pad; --_Pad) { // pad on left
; 394  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
; 395  :                     _State |= _Ostr_t::badbit; // insertion failed, quit
; 396  :                     break;
; 397  :                 }
; 398  :             }
; 399  :         }
; 400  : 
; 401  :         if (_State == _Ostr_t::goodbit && _Ostr.rdbuf()->sputn(_Data, (streamsize) _Size) != (streamsize) _Size) {
; 402  :             _State |= _Ostr_t::badbit;
; 403  :         } else {
; 404  :             for (; 0 < _Pad; --_Pad) { // pad on right
; 405  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {
; 406  :                     _State |= _Ostr_t::badbit; // insertion failed, quit
; 407  :                     break;
; 408  :                 }
; 409  :             }
; 410  :         }
; 411  : 
; 412  :         _Ostr.width(0);
; 413  :         _CATCH_IO_(_Ostr_t, _Ostr)
; 414  :     }
; 415  : 
; 416  :     _Ostr.setstate(_State);
; 417  :     return _Ostr;
; 418  : }
; 419  : 
; 420  : // STRUCT TEMPLATE _Char_traits_eq
; 421  : template <class _Traits>
; 422  : struct _Char_traits_eq {
; 423  :     using _Elem = typename _Traits::char_type;
; 424  : 
; 425  :     bool operator()(_Elem _Left, _Elem _Right) const {
; 426  :         return _Traits::eq(_Left, _Right);
; 427  :     }
; 428  : };
; 429  : 
; 430  : // STRUCT TEMPLATE _Char_traits_lt
; 431  : template <class _Traits>
; 432  : struct _Char_traits_lt {
; 433  :     using _Elem = typename _Traits::char_type;
; 434  : 
; 435  :     bool operator()(_Elem _Left, _Elem _Right) const {
; 436  :         return _Traits::lt(_Left, _Right);
; 437  :     }
; 438  : };
; 439  : 
; 440  : template <class _Elem>
; 441  : struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>>
; 442  :     : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type { // builtin char_traits::eq behaves like equal_to<>
; 443  : };
; 444  : 
; 445  : template <class _Traits>
; 446  : using _Traits_ch_t = typename _Traits::char_type;
; 447  : 
; 448  : template <class _Traits>
; 449  : using _Traits_ptr_t = const typename _Traits::char_type*;
; 450  : 
; 451  : template <class _Traits>
; 452  : constexpr bool _Traits_equal(_In_reads_(_Left_size) const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
; 453  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right,
; 454  :     const size_t _Right_size) noexcept { // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for
; 455  :                                          // equality using _Traits
; 456  :     return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;
; 457  : }
; 458  : 
; 459  : template <class _Traits>
; 460  : constexpr int _Traits_compare(_In_reads_(_Left_size) const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size,
; 461  :     _In_reads_(_Right_size) const _Traits_ptr_t<_Traits> _Right,
; 462  :     const size_t
; 463  :         _Right_size) noexcept { // compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) using _Traits
; 464  :     const int _Ans = _Traits::compare(_Left, _Right, _Min_value(_Left_size, _Right_size));
; 465  : 
; 466  :     if (_Ans != 0) {
; 467  :         return _Ans;
; 468  :     }
; 469  : 
; 470  :     if (_Left_size < _Right_size) {
; 471  :         return -1;
; 472  :     }
; 473  : 
; 474  :     if (_Left_size > _Right_size) {
; 475  :         return 1;
; 476  :     }
; 477  : 
; 478  :     return 0;
; 479  : }
; 480  : 
; 481  : template <class _Traits>
; 482  : constexpr size_t _Traits_find(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 483  :     const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 484  :     const size_t _Needle_size) noexcept { // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle +
; 485  :                                           // _Needle_size), at/after _Start_at
; 486  :     if (_Needle_size > _Hay_size
; 487  :         || _Start_at > _Hay_size - _Needle_size) { // xpos cannot exist, report failure
; 488  :                                                    // N4659 24.3.2.7.2 [string.find]/1 says:
; 489  :                                                    // 1. _Start_at <= xpos
; 490  :                                                    // 2. xpos + _Needle_size <= _Hay_size;
; 491  :                                                    // therefore:
; 492  :                                                    // 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 493  :                                                    // 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 494  :                                                    // 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to
; 495  :                                                    // other side) (also checked above)
; 496  :         return static_cast<size_t>(-1);
; 497  :     }
; 498  : 
; 499  :     if (_Needle_size == 0) { // empty string always matches if xpos is possible
; 500  :         return _Start_at;
; 501  :     }
; 502  : 
; 503  :     const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
; 504  :     for (auto _Match_try = _Haystack + _Start_at;; ++_Match_try) {
; 505  :         _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
; 506  :         if (!_Match_try) { // didn't find first character; report failure
; 507  :             return static_cast<size_t>(-1);
; 508  :         }
; 509  : 
; 510  :         if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0) { // found match
; 511  :             return static_cast<size_t>(_Match_try - _Haystack);
; 512  :         }
; 513  :     }
; 514  : }
; 515  : 
; 516  : template <class _Traits>
; 517  : constexpr size_t _Traits_find_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 518  :     const size_t _Start_at,
; 519  :     const _Traits_ch_t<_Traits> _Ch) noexcept { // search [_Haystack, _Haystack + _Hay_size) for _Ch, at/after _Start_at
; 520  :     if (_Start_at < _Hay_size) {
; 521  :         const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
; 522  :         if (_Found_at) {
; 523  :             return static_cast<size_t>(_Found_at - _Haystack);
; 524  :         }
; 525  :     }
; 526  : 
; 527  :     return static_cast<size_t>(-1); // (npos) no match
; 528  : }
; 529  : 
; 530  : template <class _Traits>
; 531  : constexpr size_t _Traits_rfind(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 532  :     const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 533  :     const size_t _Needle_size) noexcept { // search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle +
; 534  :                                           // _Needle_size) beginning before _Start_at
; 535  :     if (_Needle_size == 0) {
; 536  :         return _Min_value(_Start_at, _Hay_size); // empty string always matches
; 537  :     }
; 538  : 
; 539  :     if (_Needle_size <= _Hay_size) { // room for match, look for it
; 540  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - _Needle_size);; --_Match_try) {
; 541  :             if (_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0) {
; 542  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 543  :             }
; 544  : 
; 545  :             if (_Match_try == _Haystack) {
; 546  :                 break; // at beginning, no more chance for match
; 547  :             }
; 548  :         }
; 549  :     }
; 550  : 
; 551  :     return static_cast<size_t>(-1); // no match
; 552  : }
; 553  : 
; 554  : template <class _Traits>
; 555  : constexpr size_t _Traits_rfind_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack, const size_t _Hay_size,
; 556  :     const size_t _Start_at,
; 557  :     const _Traits_ch_t<_Traits> _Ch) noexcept { // search [_Haystack, _Haystack + _Hay_size) for _Ch before _Start_at
; 558  :     if (_Hay_size != 0) { // room for match, look for it
; 559  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 560  :             if (_Traits::eq(*_Match_try, _Ch)) {
; 561  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 562  :             }
; 563  : 
; 564  :             if (_Match_try == _Haystack) {
; 565  :                 break; // at beginning, no more chance for match
; 566  :             }
; 567  :         }
; 568  :     }
; 569  : 
; 570  :     return static_cast<size_t>(-1); // no match
; 571  : }
; 572  : 
; 573  : template <class _Elem,
; 574  :     bool = _Is_character<_Elem>::value>
; 575  : class _String_bitmap { // _String_bitmap for character types
; 576  : public:
; 577  :     constexpr bool _Mark(const _Elem* _First,
; 578  :         const _Elem* const _Last) { // mark this bitmap such that the characters in [_First, _Last) are intended to
; 579  :                                     // match returns whether all inputs can be placed in the bitmap
; 580  :         for (; _First != _Last; ++_First) {
; 581  :             _Matches[static_cast<unsigned char>(*_First)] = true;
; 582  :         }
; 583  : 
; 584  :         return true;
; 585  :     }
; 586  : 
; 587  :     constexpr bool _Match(const _Elem _Ch) const { // test if _Ch is in the bitmap
; 588  :         return _Matches[static_cast<unsigned char>(_Ch)];
; 589  :     }
; 590  : 
; 591  : private:
; 592  :     bool _Matches[256] = {};
; 593  : };
; 594  : 
; 595  : template <class _Elem>
; 596  : class _String_bitmap<_Elem, false> { // _String_bitmap for wchar_t/unsigned short/char16_t/char32_t/etc. types
; 597  : public:
; 598  :     static_assert(is_unsigned_v<_Elem>,
; 599  :         "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 [char.traits]. "
; 600  :         "Visual C++ accepts other unsigned integral types as an extension.");
; 601  : 
; 602  :     constexpr bool _Mark(const _Elem* _First,
; 603  :         const _Elem* const _Last) { // mark this bitmap such that the characters in [_First, _Last) are intended to
; 604  :                                     // match returns whether all inputs can be placed in the bitmap
; 605  :         for (; _First != _Last; ++_First) {
; 606  :             const auto _Ch = *_First;
; 607  :             if (_Ch >= 256U) {
; 608  :                 return false;
; 609  :             }
; 610  : 
; 611  :             _Matches[static_cast<unsigned char>(_Ch)] = true;
; 612  :         }
; 613  : 
; 614  :         return true;
; 615  :     }
; 616  : 
; 617  :     constexpr bool _Match(const _Elem _Ch) const { // test if _Ch is in the bitmap
; 618  :         return _Ch < 256U && _Matches[_Ch];
; 619  :     }
; 620  : 
; 621  : private:
; 622  :     bool _Matches[256] = {};
; 623  : };
; 624  : 
; 625  : template <class _Traits>
; 626  : constexpr size_t _Traits_find_first_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 627  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 628  :     const size_t _Needle_size,
; 629  :     false_type) noexcept { // in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size),
; 630  :                            // at/after _Start_at general algorithm
; 631  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it
; 632  :         const auto _End = _Haystack + _Hay_size;
; 633  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 634  :             if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 635  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 636  :             }
; 637  :         }
; 638  :     }
; 639  : 
; 640  :     return static_cast<size_t>(-1); // no match
; 641  : }
; 642  : 
; 643  : template <class _Traits>
; 644  : constexpr size_t _Traits_find_first_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 645  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 646  :     const size_t _Needle_size,
; 647  :     true_type) noexcept { // in [_Haystack, _Haystack + _Hay_size), look for one of [_Needle, _Needle + _Needle_size),
; 648  :                           // at/after _Start_at special case for std::char_traits
; 649  :     if (_Needle_size != 0 && _Start_at < _Hay_size) { // room for match, look for it
; 650  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 651  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 652  :                                                                 // fall back to the serial algorithm
; 653  :             return _Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 654  :         }
; 655  : 
; 656  :         const auto _End = _Haystack + _Hay_size;
; 657  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 658  :             if (_Matches._Match(*_Match_try)) {
; 659  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 660  :             }
; 661  :         }
; 662  :     }
; 663  : 
; 664  :     return static_cast<size_t>(-1); // no match
; 665  : }
; 666  : 
; 667  : template <class _Traits>
; 668  : constexpr size_t _Traits_find_last_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 669  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 670  :     const size_t _Needle_size,
; 671  :     false_type) noexcept { // in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size),
; 672  :                            // before _Start_at general algorithm
; 673  :     if (_Needle_size != 0 && _Hay_size != 0) { // worth searching, do it
; 674  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 675  :             if (_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 676  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 677  :             }
; 678  : 
; 679  :             if (_Match_try == _Haystack) {
; 680  :                 break; // at beginning, no more chance for match
; 681  :             }
; 682  :         }
; 683  :     }
; 684  : 
; 685  :     return static_cast<size_t>(-1); // no match
; 686  : }
; 687  : 
; 688  : template <class _Traits>
; 689  : constexpr size_t _Traits_find_last_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 690  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 691  :     const size_t _Needle_size,
; 692  :     true_type) noexcept { // in [_Haystack, _Haystack + _Hay_size), look for last of [_Needle, _Needle + _Needle_size),
; 693  :                           // before _Start_at special case for std::char_traits
; 694  :     if (_Needle_size != 0 && _Hay_size != 0) { // worth searching, do it
; 695  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 696  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 697  :                                                                 // fall back to the serial algorithm
; 698  :             return _Traits_find_last_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 699  :         }
; 700  : 
; 701  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 702  :             if (_Matches._Match(*_Match_try)) {
; 703  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 704  :             }
; 705  : 
; 706  :             if (_Match_try == _Haystack) {
; 707  :                 break; // at beginning, no more chance for match
; 708  :             }
; 709  :         }
; 710  :     }
; 711  : 
; 712  :     return static_cast<size_t>(-1); // no match
; 713  : }
; 714  : 
; 715  : template <class _Traits>
; 716  : constexpr size_t _Traits_find_first_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 717  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 718  :     const size_t _Needle_size,
; 719  :     false_type) noexcept { // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size),
; 720  :                            // at/after _Start_at general algorithm
; 721  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 722  :         const auto _End = _Haystack + _Hay_size;
; 723  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 724  :             if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 725  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 726  :             }
; 727  :         }
; 728  :     }
; 729  : 
; 730  :     return static_cast<size_t>(-1); // no match
; 731  : }
; 732  : 
; 733  : template <class _Traits>
; 734  : constexpr size_t _Traits_find_first_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 735  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 736  :     const size_t _Needle_size,
; 737  :     true_type) noexcept { // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size),
; 738  :                           // at/after _Start_at special case for std::char_traits
; 739  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 740  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 741  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 742  :                                                                 // fall back to the serial algorithm
; 743  :             return _Traits_find_first_not_of<_Traits>(
; 744  :                 _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 745  :         }
; 746  : 
; 747  :         const auto _End = _Haystack + _Hay_size;
; 748  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 749  :             if (!_Matches._Match(*_Match_try)) {
; 750  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 751  :             }
; 752  :         }
; 753  :     }
; 754  : 
; 755  :     return static_cast<size_t>(-1); // no match
; 756  : }
; 757  : 
; 758  : template <class _Traits>
; 759  : constexpr size_t _Traits_find_not_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 760  :     const size_t _Hay_size, const size_t _Start_at,
; 761  :     const _Traits_ch_t<_Traits>
; 762  :         _Ch) noexcept { // search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch, at/after _Start_at
; 763  :     if (_Start_at < _Hay_size) { // room for match, look for it
; 764  :         const auto _End = _Haystack + _Hay_size;
; 765  :         for (auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try) {
; 766  :             if (!_Traits::eq(*_Match_try, _Ch)) {
; 767  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 768  :             }
; 769  :         }
; 770  :     }
; 771  : 
; 772  :     return static_cast<size_t>(-1); // no match
; 773  : }
; 774  : 
; 775  : template <class _Traits>
; 776  : constexpr size_t _Traits_find_last_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 777  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 778  :     const size_t _Needle_size,
; 779  :     false_type) noexcept { // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size),
; 780  :                            // before _Start_at general algorithm
; 781  :     if (_Hay_size != 0) { // worth searching, do it
; 782  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 783  :             if (!_Traits::find(_Needle, _Needle_size, *_Match_try)) {
; 784  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 785  :             }
; 786  : 
; 787  :             if (_Match_try == _Haystack) {
; 788  :                 break; // at beginning, no more chance for match
; 789  :             }
; 790  :         }
; 791  :     }
; 792  : 
; 793  :     return static_cast<size_t>(-1); // no match
; 794  : }
; 795  : 
; 796  : template <class _Traits>
; 797  : constexpr size_t _Traits_find_last_not_of(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 798  :     const size_t _Hay_size, const size_t _Start_at, _In_reads_(_Needle_size) const _Traits_ptr_t<_Traits> _Needle,
; 799  :     const size_t _Needle_size,
; 800  :     true_type) noexcept { // in [_Haystack, _Haystack + _Hay_size), look for none of [_Needle, _Needle + _Needle_size),
; 801  :                           // before _Start_at special case for std::char_traits
; 802  :     if (_Hay_size != 0) { // worth searching, do it
; 803  :         _String_bitmap<typename _Traits::char_type> _Matches;
; 804  :         if (!_Matches._Mark(_Needle, _Needle + _Needle_size)) { // couldn't put one of the characters into the bitmap,
; 805  :                                                                 // fall back to the serial algorithm
; 806  :             return _Traits_find_last_not_of<_Traits>(
; 807  :                 _Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
; 808  :         }
; 809  : 
; 810  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 811  :             if (!_Matches._Match(*_Match_try)) {
; 812  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 813  :             }
; 814  : 
; 815  :             if (_Match_try == _Haystack) {
; 816  :                 break; // at beginning, no more chance for match
; 817  :             }
; 818  :         }
; 819  :     }
; 820  : 
; 821  :     return static_cast<size_t>(-1); // no match
; 822  : }
; 823  : 
; 824  : template <class _Traits>
; 825  : constexpr size_t _Traits_rfind_not_ch(_In_reads_(_Hay_size) const _Traits_ptr_t<_Traits> _Haystack,
; 826  :     const size_t _Hay_size, const size_t _Start_at,
; 827  :     const _Traits_ch_t<_Traits>
; 828  :         _Ch) noexcept { // search [_Haystack, _Haystack + _Hay_size) for any value other than _Ch before _Start_at
; 829  :     if (_Hay_size != 0) { // room for match, look for it
; 830  :         for (auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try) {
; 831  :             if (!_Traits::eq(*_Match_try, _Ch)) {
; 832  :                 return static_cast<size_t>(_Match_try - _Haystack); // found a match
; 833  :             }
; 834  : 
; 835  :             if (_Match_try == _Haystack) {
; 836  :                 break; // at beginning, no more chance for match
; 837  :             }
; 838  :         }
; 839  :     }
; 840  : 
; 841  :     return static_cast<size_t>(-1); // no match
; 842  : }
; 843  : 
; 844  : 
; 845  : #if _HAS_CXX17
; 846  : // CLASS TEMPLATE _String_view_iterator
; 847  : template <class _Elem, class _Traits = char_traits<_Elem>>
; 848  : class basic_string_view;
; 849  : 
; 850  : template <class _Traits>
; 851  : class _String_view_iterator { // iterator for character buffer wrapper
; 852  : public:
; 853  :     using iterator_category = random_access_iterator_tag;
; 854  :     using value_type        = typename _Traits::char_type;
; 855  :     using difference_type   = ptrdiff_t;
; 856  :     using pointer           = const value_type*;
; 857  :     using reference         = const value_type&;
; 858  : 
; 859  :     constexpr _String_view_iterator() noexcept
; 860  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 861  :         : _Mydata(), _Mysize(0), _Myoff(0)
; 862  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 863  :         : _Myptr()
; 864  : #endif // _ITERATOR_DEBUG_LEVEL
; 865  :     { // default-initialize a basic_string_view::const_iterator
; 866  :     }
; 867  : 
; 868  : private:
; 869  :     friend basic_string_view<value_type, _Traits>;
; 870  : 
; 871  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 872  :     constexpr _String_view_iterator(const pointer _Data, const size_t _Size, const size_t _Off) noexcept
; 873  :         : _Mydata(_Data), _Mysize(_Size), _Myoff(_Off) { // initialize a basic_string_view::const_iterator
; 874  :     }
; 875  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 876  :     constexpr explicit _String_view_iterator(const pointer _Ptr) noexcept
; 877  :         : _Myptr(_Ptr) { // initialize a basic_string_view::const_iterator
; 878  :     }
; 879  : #endif // _ITERATOR_DEBUG_LEVEL
; 880  : 
; 881  : public:
; 882  :     _NODISCARD constexpr reference operator*() const noexcept { // return designated object
; 883  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 884  :         _STL_VERIFY(_Mydata, "cannot dereference value-initialized string_view iterator");
; 885  :         _STL_VERIFY(_Myoff < _Mysize, "cannot dereference end string_view iterator");
; 886  :         return _Mydata[_Myoff];
; 887  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 888  :         return *_Myptr;
; 889  : #endif // _ITERATOR_DEBUG_LEVEL
; 890  :     }
; 891  : 
; 892  :     _NODISCARD constexpr pointer operator->() const noexcept { // return pointer to class object
; 893  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 894  :         _STL_VERIFY(_Mydata, "cannot dereference value-initialized string_view iterator");
; 895  :         _STL_VERIFY(_Myoff < _Mysize, "cannot dereference end string_view iterator");
; 896  :         return _Mydata + _Myoff;
; 897  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 898  :         return _Myptr;
; 899  : #endif // _ITERATOR_DEBUG_LEVEL
; 900  :     }
; 901  : 
; 902  :     constexpr _String_view_iterator& operator++() noexcept { // preincrement
; 903  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 904  :         _STL_VERIFY(_Mydata, "cannot increment value-initialized string_view iterator");
; 905  :         _STL_VERIFY(_Myoff < _Mysize, "cannot increment string_view iterator past end");
; 906  :         ++_Myoff;
; 907  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 908  :         ++_Myptr;
; 909  : #endif // _ITERATOR_DEBUG_LEVEL
; 910  :         return *this;
; 911  :     }
; 912  : 
; 913  :     constexpr _String_view_iterator operator++(int) noexcept { // postincrement
; 914  :         _String_view_iterator _Tmp{*this};
; 915  :         ++*this;
; 916  :         return _Tmp;
; 917  :     }
; 918  : 
; 919  :     constexpr _String_view_iterator& operator--() noexcept { // predecrement
; 920  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 921  :         _STL_VERIFY(_Mydata, "cannot decrement value-initialized string_view iterator");
; 922  :         _STL_VERIFY(_Myoff != 0, "cannot decrement string_view iterator before begin");
; 923  :         --_Myoff;
; 924  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 925  :         --_Myptr;
; 926  : #endif // _ITERATOR_DEBUG_LEVEL
; 927  :         return *this;
; 928  :     }
; 929  : 
; 930  :     constexpr _String_view_iterator operator--(int) noexcept { // postdecrement
; 931  :         _String_view_iterator _Tmp{*this};
; 932  :         --*this;
; 933  :         return _Tmp;
; 934  :     }
; 935  : 
; 936  :     constexpr void _Verify_offset(const difference_type _Off) const noexcept {
; 937  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 938  :         if (_Off != 0) {
; 939  :             _STL_VERIFY(_Mydata, "cannot seek value-initialized string_view iterator");
; 940  :         }
; 941  : 
; 942  :         if (_Off < 0) {
; 943  : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 944  :             _STL_VERIFY(_Myoff >= -static_cast<size_t>(_Off), "cannot seek string_view iterator before begin");
; 945  :         }
; 946  : 
; 947  :         if (_Off > 0) {
; 948  :             _STL_VERIFY(_Mysize - _Myoff >= static_cast<size_t>(_Off), "cannot seek string_view iterator after end");
; 949  :         }
; 950  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 951  :         (void) _Off;
; 952  : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 953  :     }
; 954  : 
; 955  :     constexpr _String_view_iterator& operator+=(const difference_type _Off) noexcept { // increment by integer
; 956  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 957  :         _Verify_offset(_Off);
; 958  :         _Myoff += _Off;
; 959  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 960  :         _Myptr += _Off;
; 961  : #endif // _ITERATOR_DEBUG_LEVEL
; 962  : 
; 963  :         return *this;
; 964  :     }
; 965  : 
; 966  :     _NODISCARD constexpr _String_view_iterator operator+(const difference_type _Off) const
; 967  :         noexcept { // return this + integer
; 968  :         _String_view_iterator _Tmp{*this};
; 969  :         _Tmp += _Off;
; 970  :         return _Tmp;
; 971  :     }
; 972  : 
; 973  :     constexpr _String_view_iterator& operator-=(const difference_type _Off) noexcept { // decrement by integer
; 974  : #if _ITERATOR_DEBUG_LEVEL >= 1
; 975  :         if (_Off != 0) {
; 976  :             _STL_VERIFY(_Mydata, "cannot seek value-initialized string_view iterator");
; 977  :         }
; 978  : 
; 979  :         if (_Off > 0) {
; 980  :             _STL_VERIFY(_Myoff >= static_cast<size_t>(_Off), "cannot seek string_view iterator before begin");
; 981  :         }
; 982  : 
; 983  :         if (_Off < 0) {
; 984  : #pragma warning(suppress : 4146) // unary minus operator applied to unsigned type, result still unsigned
; 985  :             _STL_VERIFY(_Mysize - _Myoff >= -static_cast<size_t>(_Off), "cannot seek string_view iterator after end");
; 986  :         }
; 987  : 
; 988  :         _Myoff -= _Off;
; 989  : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 990  :         _Myptr -= _Off;
; 991  : #endif // _ITERATOR_DEBUG_LEVEL
; 992  : 
; 993  :         return *this;
; 994  :     }
; 995  : 
; 996  :     _NODISCARD constexpr _String_view_iterator operator-(const difference_type _Off) const
; 997  :         noexcept { // return this - integer
; 998  :         _String_view_iterator _Tmp{*this};
; 999  :         _Tmp -= _Off;
; 1000 :         return _Tmp;
; 1001 :     }
; 1002 : 
; 1003 :     _NODISCARD constexpr difference_type operator-(const _String_view_iterator& _Right) const
; 1004 :         noexcept { // return difference of iterators
; 1005 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1006 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1007 :             "cannot subtract incompatible string_view iterators");
; 1008 :         return static_cast<difference_type>(_Myoff - _Right._Myoff);
; 1009 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1010 :         return _Myptr - _Right._Myptr;
; 1011 : #endif // _ITERATOR_DEBUG_LEVEL
; 1012 :     }
; 1013 : 
; 1014 :     _NODISCARD constexpr reference operator[](const difference_type _Off) const noexcept { // subscript
; 1015 :         return *(*this + _Off);
; 1016 :     }
; 1017 : 
; 1018 :     _NODISCARD constexpr bool operator==(const _String_view_iterator& _Right) const
; 1019 :         noexcept { // test for iterator equality
; 1020 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1021 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1022 :             "cannot compare incompatible string_view iterators for equality");
; 1023 :         return _Myoff == _Right._Myoff;
; 1024 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1025 :         return _Myptr == _Right._Myptr;
; 1026 : #endif // _ITERATOR_DEBUG_LEVEL
; 1027 :     }
; 1028 : 
; 1029 :     _NODISCARD constexpr bool operator!=(const _String_view_iterator& _Right) const
; 1030 :         noexcept { // test for iterator inequality
; 1031 :         return !(*this == _Right);
; 1032 :     }
; 1033 : 
; 1034 :     _NODISCARD constexpr bool operator<(const _String_view_iterator& _Right) const noexcept { // test if this < _Right
; 1035 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1036 :         _STL_VERIFY(_Mydata == _Right._Mydata && _Mysize == _Right._Mysize,
; 1037 :             "cannot compare incompatible string_view iterators");
; 1038 :         return _Myoff < _Right._Myoff;
; 1039 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1040 :         return _Myptr < _Right._Myptr;
; 1041 : #endif // _ITERATOR_DEBUG_LEVEL
; 1042 :     }
; 1043 : 
; 1044 :     _NODISCARD constexpr bool operator>(const _String_view_iterator& _Right) const noexcept { // test if this > _Right
; 1045 :         return _Right < *this;
; 1046 :     }
; 1047 : 
; 1048 :     _NODISCARD constexpr bool operator<=(const _String_view_iterator& _Right) const noexcept { // test if this <= _Right
; 1049 :         return !(_Right < *this);
; 1050 :     }
; 1051 : 
; 1052 :     _NODISCARD constexpr bool operator>=(const _String_view_iterator& _Right) const noexcept { // test if this >= _Right
; 1053 :         return !(*this < _Right);
; 1054 :     }
; 1055 : 
; 1056 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1057 :     friend constexpr void _Verify_range(const _String_view_iterator& _First, const _String_view_iterator& _Last) {
; 1058 :         _STL_VERIFY(_First._Mydata == _Last._Mydata && _First._Mysize == _Last._Mysize,
; 1059 :             "string_view iterators in range are from different views");
; 1060 :         _STL_VERIFY(_First._Myoff <= _Last._Myoff, "string_view iterator range transposed");
; 1061 :     }
; 1062 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1063 : 
; 1064 :     using _Prevent_inheriting_unwrap = _String_view_iterator;
; 1065 : 
; 1066 :     _NODISCARD constexpr pointer _Unwrapped() const noexcept {
; 1067 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1068 :         return _Mydata + _Myoff;
; 1069 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1070 :         return _Myptr;
; 1071 : #endif // _ITERATOR_DEBUG_LEVEL
; 1072 :     }
; 1073 : 
; 1074 :     static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;
; 1075 : 
; 1076 :     constexpr void _Seek_to(pointer _It) noexcept {
; 1077 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1078 :         _Myoff = static_cast<size_t>(_It - _Mydata);
; 1079 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1080 :         _Myptr = _It;
; 1081 : #endif // _ITERATOR_DEBUG_LEVEL
; 1082 :     }
; 1083 : 
; 1084 : private:
; 1085 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1086 :     pointer _Mydata;
; 1087 :     size_t _Mysize;
; 1088 :     size_t _Myoff;
; 1089 : #else // ^^^ _ITERATOR_DEBUG_LEVEL >= 1 ^^^ // vvv _ITERATOR_DEBUG_LEVEL == 0 vvv
; 1090 :     pointer _Myptr;
; 1091 : #endif // _ITERATOR_DEBUG_LEVEL
; 1092 : };
; 1093 : 
; 1094 : template <class _Traits>
; 1095 : _NODISCARD constexpr _String_view_iterator<_Traits> operator+(
; 1096 :     const typename _String_view_iterator<_Traits>::difference_type _Off,
; 1097 :     _String_view_iterator<_Traits> _Right) noexcept { // return integer + _Right
; 1098 :     _Right += _Off;
; 1099 :     return _Right;
; 1100 : }
; 1101 : 
; 1102 : 
; 1103 : // CLASS TEMPLATE basic_string_view
; 1104 : template <class _Elem, class _Traits>
; 1105 : class basic_string_view { // wrapper for any kind of contiguous character buffer
; 1106 : public:
; 1107 :     static_assert(is_same_v<_Elem, typename _Traits::char_type>,
; 1108 :         "Bad char_traits for basic_string_view; "
; 1109 :         "N4659 24.4.2 [string.view.template]/1 \"the type traits::char_type shall name the same type as charT.\"");
; 1110 : 
; 1111 :     using traits_type            = _Traits;
; 1112 :     using value_type             = _Elem;
; 1113 :     using pointer                = _Elem*;
; 1114 :     using const_pointer          = const _Elem*;
; 1115 :     using reference              = _Elem&;
; 1116 :     using const_reference        = const _Elem&;
; 1117 :     using const_iterator         = _String_view_iterator<_Traits>;
; 1118 :     using iterator               = const_iterator;
; 1119 :     using const_reverse_iterator = _STD reverse_iterator<const_iterator>;
; 1120 :     using reverse_iterator       = const_reverse_iterator;
; 1121 :     using size_type              = size_t;
; 1122 :     using difference_type        = ptrdiff_t;
; 1123 : 
; 1124 :     static constexpr auto npos{static_cast<size_type>(-1)};
; 1125 : 
; 1126 :     constexpr basic_string_view() noexcept : _Mydata(), _Mysize(0) { // construct empty basic_string_view
; 1127 :     }
; 1128 : 
; 1129 :     constexpr basic_string_view(const basic_string_view&) noexcept = default;
; 1130 :     constexpr basic_string_view& operator=(const basic_string_view&) noexcept = default;
; 1131 : 
; 1132 :     /* implicit */ constexpr basic_string_view(_In_z_ const const_pointer _Ntcts) noexcept // strengthened
; 1133 :         : _Mydata(_Ntcts),

	mov	QWORD PTR [rcx], rdx

; 301  :         return __builtin_strlen(_First);

	mov	rax, -1
	npad	6
$LL5@basic_stri:
	inc	rax
	cmp	BYTE PTR [rdx+rax], 0
	jne	SHORT $LL5@basic_stri

; 1136 :     }

	mov	QWORD PTR [rcx+8], rax
	mov	rax, rcx
	ret	0
??0?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAA@QEBD@Z ENDP ; std::basic_string_view<char,std::char_traits<char> >::basic_string_view<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??0?$allocator@_W@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@_W@std@@QEAA@XZ PROC			; std::allocator<wchar_t>::allocator<wchar_t>, COMDAT

; 916  :     }

	mov	rax, rcx
	ret	0
??0?$allocator@_W@std@@QEAA@XZ ENDP			; std::allocator<wchar_t>::allocator<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >, COMDAT

; 906  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept { // destroy the object

$LN5:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, QWORD PTR [rcx-176]
	mov	rbx, rcx
	movsxd	rdx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rdx+rcx-176], rax
	mov	rax, QWORD PTR [rcx-176]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	r8d, DWORD PTR [rdx-176]
	mov	DWORD PTR [rdx+rcx-180], r8d

; 907  :     }

	add	rcx, -160				; ffffffffffffff60H
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	rcx, QWORD PTR [rbx-152]
	add	rsp, 32					; 00000020H
	pop	rbx
	rex_jmp	QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z
_TEXT	SEGMENT
this$ = 64
_Str$ = 72
_Mode$dead$ = 80
_Prot$dead$ = 88
$initVBases$dead$ = 96
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >, COMDAT

; 775  :     explicit basic_ifstream(

$LN19:
	push	rbx
	sub	rsp, 48					; 00000030H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 775  :     explicit basic_ifstream(

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN11@basic_ifst
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rdx, QWORD PTR [rdx]
$LN11@basic_ifst:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 777  :         : basic_ifstream(_Str.c_str(), _Mode, _Prot) { // construct with named file and specified mode

	call	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
	mov	rax, QWORD PTR [rbx]
	movsxd	rdx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rdx+rbx], rax
	mov	rax, QWORD PTR [rbx]
	movsxd	rcx, DWORD PTR [rax+4]

; 778  :     }

	mov	rax, rbx
	lea	edx, DWORD PTR [rcx-176]
	mov	DWORD PTR [rcx+rbx-4], edx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@HH@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
_TEXT	SEGMENT
this$ = 48
_Loc$ = 56
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT

; 650  :         const locale& _Loc) { // set locale to argument (capture nontrivial codecvt facet)

$LN17:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 651  :         _Initcvt(_STD use_facet<_Cvt>(_Loc));

	mov	rcx, rdx
	call	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >

; 716  :         if (_Newcvt.always_noconv()) {

	mov	rcx, rax

; 651  :         _Initcvt(_STD use_facet<_Cvt>(_Loc));

	mov	rdi, rax

; 716  :         if (_Newcvt.always_noconv()) {

	call	QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
	test	al, al
	je	SHORT $LN4@imbue

; 717  :             _Pcvt = nullptr; // nothing to do

	mov	QWORD PTR [rbx+104], 0

; 652  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN4@imbue:

; 720  :             _Mysb::_Init(); // reset any buffering

	mov	rcx, rbx
	mov	QWORD PTR [rbx+104], rdi

; 652  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 720  :             _Mysb::_Init(); // reset any buffering

	rex_jmp	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
this$ = 48
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT

; 643  :     virtual int __CLR_OR_THIS_CALL sync() { // synchronize C stream with external file

$LN13:
	push	rbx
	sub	rsp, 32					; 00000020H

; 644  :         return _Myfile == nullptr || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)

	cmp	QWORD PTR [rcx+128], 0
	mov	rbx, rcx
	je	SHORT $LN3@sync
	mov	rax, QWORD PTR [rcx]
	mov	edx, -1
	call	QWORD PTR [rax+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 644  :         return _Myfile == nullptr || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)

	je	SHORT $LN3@sync
	mov	rcx, QWORD PTR [rbx+128]
	call	QWORD PTR __imp_fflush
	test	eax, eax
	jns	SHORT $LN3@sync
	mov	eax, -1

; 645  :                    ? 0
; 646  :                    : -1;
; 647  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN3@sync:

; 644  :         return _Myfile == nullptr || _Traits::eq_int_type(_Traits::eof(), overflow()) || 0 <= _CSTD fflush(_Myfile)

	xor	eax, eax

; 645  :                    ? 0
; 646  :                    : -1;
; 647  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
_TEXT	SEGMENT
_Pb$1 = 32
_Pn$2 = 40
_Nr$3 = 48
__$ArrayPad$ = 56
this$ = 96
_Buffer$ = 104
_Count$ = 112
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT

; 631  :     virtual _Mysb* __CLR_OR_THIS_CALL setbuf(_Elem* _Buffer, streamsize _Count) { // offer _Buffer to C stream

$LN20:
	push	rbx
	push	rsi
	sub	rsp, 72					; 00000048H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rcx
	mov	r9, r8

; 632  :         if (_Myfile == nullptr
; 633  :             || _CSTD setvbuf(_Myfile, (char*) _Buffer, _Buffer == nullptr && _Count == 0 ? _IONBF : _IOFBF,

	mov	rcx, QWORD PTR [rcx+128]
	test	rcx, rcx
	je	$LN4@setbuf
	xor	esi, esi
	test	rdx, rdx
	jne	SHORT $LN6@setbuf
	test	r8, r8
	lea	r8d, QWORD PTR [rsi+4]
	je	SHORT $LN7@setbuf
$LN6@setbuf:
	mov	r8d, esi
$LN7@setbuf:
	call	QWORD PTR __imp_setvbuf
	test	eax, eax
	jne	$LN4@setbuf

; 637  :         } else { // new buffer, reinitialize pointers
; 638  :             _Init(_Myfile, _Openfl);

	mov	QWORD PTR [rsp+64], rdi

; 660  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	rcx, rbx

; 637  :         } else { // new buffer, reinitialize pointers
; 638  :             _Init(_Myfile, _Openfl);

	mov	rdi, QWORD PTR [rbx+128]

; 657  :         _Closef    = _Which == _Openfl;

	mov	BYTE PTR [rbx+124], 1

; 658  :         _Wrotesome = false;

	mov	BYTE PTR [rbx+113], sil

; 659  : 
; 660  :         _Mysb::_Init(); // initialize stream buffer base object

	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 661  : 
; 662  :         if (_File != nullptr && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer

	test	rdi, rdi
	je	SHORT $LN9@setbuf

; 663  :             _Elem** _Pb = nullptr;
; 664  :             _Elem** _Pn = nullptr;
; 665  :             int* _Nr    = nullptr;
; 666  : 
; 667  :             ::_get_stream_buffer_pointers(

	lea	r9, QWORD PTR _Nr$3[rsp]
	mov	QWORD PTR _Pb$1[rsp], rsi
	lea	r8, QWORD PTR _Pn$2[rsp]
	mov	QWORD PTR _Pn$2[rsp], rsi
	lea	rdx, QWORD PTR _Pb$1[rsp]
	mov	QWORD PTR _Nr$3[rsp], rsi
	mov	rcx, rdi
	call	QWORD PTR __imp__get_stream_buffer_pointers
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 272  :         _IGfirst = _Gf;

	mov	rcx, QWORD PTR _Pb$1[rsp]
	mov	QWORD PTR [rbx+24], rcx

; 273  :         _IPfirst = _Pf;

	mov	QWORD PTR [rbx+32], rcx

; 274  :         _IGnext  = _Gn;

	mov	rcx, QWORD PTR _Pn$2[rsp]
	mov	QWORD PTR [rbx+56], rcx

; 275  :         _IPnext  = _Pn;

	mov	QWORD PTR [rbx+64], rcx

; 276  :         _IGcount = _Gc;

	mov	rcx, QWORD PTR _Nr$3[rsp]
	mov	QWORD PTR [rbx+80], rcx

; 277  :         _IPcount = _Pc;

	mov	QWORD PTR [rbx+88], rcx
$LN9@setbuf:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 675  :         _State  = _Stinit;

	mov	rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit

; 639  :             return this;

	mov	rax, rbx

; 674  :         _Myfile = _File;

	mov	QWORD PTR [rbx+128], rdi

; 639  :             return this;

	mov	rdi, QWORD PTR [rsp+64]

; 675  :         _State  = _Stinit;

	mov	QWORD PTR [rbx+116], rcx

; 676  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	QWORD PTR [rbx+104], rsi

; 639  :             return this;

	jmp	SHORT $LN3@setbuf
$LN4@setbuf:

; 634  :                    (size_t) _Count * sizeof(_Elem))
; 635  :                    != 0) {
; 636  :             return nullptr; // failed

	xor	eax, eax
$LN3@setbuf:

; 640  :         }
; 641  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 72					; 00000048H
	pop	rsi
	pop	rbx
	ret	0
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
_Off$ = 32
__$ArrayPad$ = 40
this$ = 80
__$ReturnUdt$ = 88
_Pos$ = 96
__formal$ = 104
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT

; 619  :         pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) { // change position to _Pos

$LN22:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\iosfwd

; 69   :         return _Myoff + _Fpos;

	mov	rax, QWORD PTR [r8+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 619  :         pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) { // change position to _Pos

	mov	rsi, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\iosfwd

; 69   :         return _Myoff + _Fpos;

	add	rax, QWORD PTR [r8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 619  :         pos_type _Pos, ios_base::openmode = ios_base::in | ios_base::out) { // change position to _Pos

	mov	rbx, rdx

; 620  :         off_type _Off = static_cast<off_type>(_Pos);
; 621  : 
; 622  :         if (_Myfile == nullptr || !_Endwrite() || _CSTD fsetpos(_Myfile, &_Off) != 0) {

	cmp	QWORD PTR [rcx+128], 0
	mov	rdi, rcx
	mov	QWORD PTR _Off$[rsp], rax
	je	SHORT $LN3@seekpos
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
	test	al, al
	je	SHORT $LN3@seekpos
	mov	rcx, QWORD PTR [rdi+128]
	lea	rdx, QWORD PTR _Off$[rsp]
	call	QWORD PTR __imp_fsetpos
	test	eax, eax
	jne	SHORT $LN3@seekpos
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 179  :         return *_IGfirst;

	mov	rcx, QWORD PTR [rdi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 733  :         if (_Mysb::eback() == &_Mychar) {

	lea	rax, QWORD PTR [rdi+112]

; 623  :             return pos_type(-1); // report failure
; 624  :         }
; 625  : 
; 626  :         _State = _Pos.state();

	mov	rdx, QWORD PTR [rsi+16]
	mov	QWORD PTR [rdi+116], rdx

; 733  :         if (_Mysb::eback() == &_Mychar) {

	cmp	QWORD PTR [rcx], rax
	jne	SHORT $LN12@seekpos

; 734  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	rdx, QWORD PTR [rdi+136]
	mov	r8, QWORD PTR [rdi+144]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 204  :         *_IGfirst = _First;

	mov	QWORD PTR [rcx], rdx

; 205  :         *_IGnext  = _Next;
; 206  :         *_IGcount = (int) (_Last - _Next);

	sub	r8d, edx
	mov	rcx, QWORD PTR [rdi+56]
	mov	QWORD PTR [rcx], rdx
	mov	rcx, QWORD PTR [rdi+80]
	mov	DWORD PTR [rcx], r8d
	mov	rdx, QWORD PTR [rdi+116]
$LN12@seekpos:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\iosfwd

; 55   :         : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) { // construct with conversion state and C file position

	mov	rcx, QWORD PTR _Off$[rsp]
	mov	QWORD PTR [rbx], rcx
	mov	QWORD PTR [rbx+8], 0
	mov	QWORD PTR [rbx+16], rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 628  :         return pos_type(_State, _Off); // return new position

	jmp	SHORT $LN20@seekpos
$LN3@seekpos:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\iosfwd

; 51   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() { // construct with stream offset

	xor	eax, eax
	mov	QWORD PTR [rbx], -1
	mov	QWORD PTR [rbx+8], 0
	mov	QWORD PTR [rbx+16], rax
$LN20@seekpos:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 629  :     }

	mov	rax, rbx
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 48					; 00000030H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\iosfwd
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
_Fileposition$ = 32
__$ArrayPad$ = 40
this$ = 96
__$ReturnUdt$ = 104
_Off$ = 112
_Way$ = 120
__formal$ = 128
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT

; 599  :         ios_base::openmode = ios_base::in | ios_base::out) { // change position by _Off

$LN23:
	push	rbx
	push	rbp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 183  :         return *_IGnext;

	mov	rax, QWORD PTR [rcx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 604  :             && _Pcvt == nullptr) { // not converting

	lea	r14, QWORD PTR [rcx+112]
	mov	ebp, r9d
	mov	rsi, r8
	mov	rdi, rdx
	mov	rbx, rcx
	cmp	QWORD PTR [rax], r14
	jne	SHORT $LN2@seekoff
	cmp	r9d, 1
	jne	SHORT $LN2@seekoff
	cmp	QWORD PTR [rcx+104], 0
	jne	SHORT $LN2@seekoff

; 605  :             _Off -= static_cast<off_type>(sizeof(_Elem)); // back up over _Elem bytes

	dec	rsi
$LN2@seekoff:

; 606  :         }
; 607  : 
; 608  :         if (_Myfile == nullptr || !_Endwrite()
; 609  :             || ((_Off != 0 || _Way != ios_base::cur) && _CSTD _fseeki64(_Myfile, _Off, _Way) != 0)
; 610  :             || _CSTD fgetpos(_Myfile, &_Fileposition) != 0) {

	cmp	QWORD PTR [rcx+128], 0
	je	$LN4@seekoff
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
	test	al, al
	je	SHORT $LN4@seekoff
	test	rsi, rsi
	jne	SHORT $LN6@seekoff
	cmp	ebp, 1
	je	SHORT $LN5@seekoff
$LN6@seekoff:
	mov	rcx, QWORD PTR [rbx+128]
	mov	r8d, ebp
	mov	rdx, rsi
	call	QWORD PTR __imp__fseeki64
	test	eax, eax
	jne	SHORT $LN4@seekoff
$LN5@seekoff:
	mov	rcx, QWORD PTR [rbx+128]
	lea	rdx, QWORD PTR _Fileposition$[rsp]
	call	QWORD PTR __imp_fgetpos
	test	eax, eax
	jne	SHORT $LN4@seekoff
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 179  :         return *_IGfirst;

	mov	rax, QWORD PTR [rbx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 733  :         if (_Mysb::eback() == &_Mychar) {

	cmp	QWORD PTR [rax], r14
	jne	SHORT $LN13@seekoff

; 734  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	rdx, QWORD PTR [rbx+136]
	mov	r8, QWORD PTR [rbx+144]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 204  :         *_IGfirst = _First;

	mov	QWORD PTR [rax], rdx

; 205  :         *_IGnext  = _Next;
; 206  :         *_IGcount = (int) (_Last - _Next);

	sub	r8d, edx
	mov	rcx, QWORD PTR [rbx+56]
	mov	QWORD PTR [rcx], rdx
	mov	rcx, QWORD PTR [rbx+80]
	mov	DWORD PTR [rcx], r8d
$LN13@seekoff:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 615  :         return pos_type(_State, _Fileposition); // return new position

	mov	rcx, QWORD PTR [rbx+116]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\iosfwd

; 55   :         : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) { // construct with conversion state and C file position

	mov	rdx, QWORD PTR _Fileposition$[rsp]
	mov	QWORD PTR [rdi], rdx
	mov	QWORD PTR [rdi+16], rcx
	mov	QWORD PTR [rdi+8], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 615  :         return pos_type(_State, _Fileposition); // return new position

	jmp	SHORT $LN21@seekoff
$LN4@seekoff:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\iosfwd

; 51   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() { // construct with stream offset

	xor	eax, eax
	mov	QWORD PTR [rdi], -1
	mov	QWORD PTR [rdi+8], 0
	mov	QWORD PTR [rdi+16], rax
$LN21@seekoff:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 616  :     }

	mov	rax, rdi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 48					; 00000030H
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbp
	pop	rbx
	ret	0
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsputn, COMDAT

; 566  :         const _Elem* _Ptr, streamsize _Count) override { // put _Count characters to stream

$LN19:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rdi
	push	r14
	sub	rsp, 32					; 00000020H

; 567  :         if
; 568  :             _CONSTEXPR_IF(sizeof(_Elem) == 1) {
; 569  :                 if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing

	cmp	QWORD PTR [rcx+104], 0
	mov	rbx, r8
	mov	r14, rdx
	mov	rdi, rcx
	je	SHORT $LN2@xsputn

; 591  :             }
; 592  :         else { // non-chars always get element-by-element processing
; 593  :             return _Mysb::xsputn(_Ptr, _Count);
; 594  :         }
; 595  :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14

; 570  :                     return _Mysb::xsputn(_Ptr, _Count);

	rex_jmp	QWORD PTR __imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
$LN2@xsputn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 256  :         return *_IPnext != nullptr ? *_IPcount : 0;

	mov	rax, QWORD PTR [rcx+64]
	mov	QWORD PTR [rsp+48], rbp
	mov	QWORD PTR [rsp+56], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 573  :                 const streamsize _Start_count = _Count;

	mov	rsi, rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 256  :         return *_IPnext != nullptr ? *_IPcount : 0;

	mov	r9, QWORD PTR [rax]
	test	r9, r9
	je	SHORT $LN9@xsputn
	mov	rax, QWORD PTR [rcx+88]
	mov	ecx, DWORD PTR [rax]
	jmp	SHORT $LN10@xsputn
$LN9@xsputn:
	xor	ecx, ecx
$LN10@xsputn:
	movsxd	rbp, ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 575  :                 if (0 < _Count && 0 < _Size) { // copy to write buffer

	test	rbx, rbx
	jle	SHORT $LN5@xsputn
	test	ecx, ecx
	jle	SHORT $LN3@xsputn

; 576  :                     if (_Count < _Size) {

	cmp	rbx, rbp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rcx, r9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 576  :                     if (_Count < _Size) {

	cmovl	rbp, rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	r8, rbp
	call	memcpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 233  :         *_IPcount -= _Off;

	mov	rax, QWORD PTR [rdi+88]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 581  :                     _Ptr += _Size;

	add	r14, rbp

; 582  :                     _Count -= _Size;

	sub	rbx, rbp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 233  :         *_IPcount -= _Off;

	sub	DWORD PTR [rax], ebp

; 234  :         *_IPnext += _Off;

	mov	rcx, QWORD PTR [rdi+64]
	movsxd	rax, ebp
	add	QWORD PTR [rcx], rax
$LN3@xsputn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 586  :                 if (0 < _Count && _Myfile) { // open C stream, attempt write

	test	rbx, rbx
	jle	SHORT $LN5@xsputn
	mov	r9, QWORD PTR [rdi+128]
	test	r9, r9
	je	SHORT $LN5@xsputn

; 587  :                     _Count -= _CSTD fwrite(_Ptr, sizeof(_Elem), static_cast<size_t>(_Count), _Myfile);

	mov	r8, rbx
	mov	edx, 1
	mov	rcx, r14
	call	QWORD PTR __imp_fwrite
	sub	rbx, rax
$LN5@xsputn:

; 588  :                 }
; 589  : 
; 590  :                 return _Start_count - _Count;

	mov	rbp, QWORD PTR [rsp+48]
	sub	rsi, rbx

; 591  :             }
; 592  :         else { // non-chars always get element-by-element processing
; 593  :             return _Mysb::xsputn(_Ptr, _Count);
; 594  :         }
; 595  :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rax, rsi
	mov	rsi, QWORD PTR [rsp+56]
	mov	rdi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	r14
	ret	0
?xsputn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsputn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn, COMDAT

; 516  :         _Elem* _Ptr, streamsize _Count) override { // get _Count characters from stream

$LN39:
	push	rbp
	push	rsi
	push	r14
	sub	rsp, 48					; 00000030H
	mov	rbp, r8
	mov	r14, rdx
	mov	rsi, rcx

; 517  :         if
; 518  :             _CONSTEXPR_IF(sizeof(_Elem) == 1) {
; 519  :                 if (_Count <= 0) {

	test	r8, r8
	jg	SHORT $LN4@xsgetn

; 520  :                     return 0;

	xor	eax, eax

; 559  :             }
; 560  :         else { // non-chars always get element-by-element processing
; 561  :             return _Mysb::xsgetn(_Ptr, _Count);
; 562  :         }
; 563  :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rsi
	pop	rbp
	ret	0
$LN4@xsgetn:

; 521  :                 }
; 522  : 
; 523  :                 if (_Pcvt) { // if we need a nontrivial codecvt transform, do the default expensive thing

	cmp	QWORD PTR [rcx+104], 0
	je	SHORT $LN5@xsgetn

; 559  :             }
; 560  :         else { // non-chars always get element-by-element processing
; 561  :             return _Mysb::xsgetn(_Ptr, _Count);
; 562  :         }
; 563  :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rsi
	pop	rbp

; 524  :                     return _Mysb::xsgetn(_Ptr, _Count);

	rex_jmp	QWORD PTR __imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
$LN5@xsgetn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 229  :         return *_IGnext != nullptr ? *_IGcount : 0;

	mov	rax, QWORD PTR [rcx+56]
	mov	QWORD PTR [rsp+32], rdi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 528  :                 auto _Count_s           = static_cast<size_t>(_Count);

	mov	rdi, rbp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 229  :         return *_IGnext != nullptr ? *_IGcount : 0;

	mov	rdx, QWORD PTR [rax]
	test	rdx, rdx
	je	SHORT $LN13@xsgetn
	mov	rax, QWORD PTR [rcx+80]
	mov	ecx, DWORD PTR [rax]
	jmp	SHORT $LN14@xsgetn
$LN13@xsgetn:
	xor	ecx, ecx
$LN14@xsgetn:
	mov	QWORD PTR [rsp+40], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 530  :                 const auto _Available   = static_cast<size_t>(_Mysb::_Gnavail());

	movsxd	rax, ecx
	test	ecx, ecx

; 531  :                 if (0 < _Available) { // copy from get area

	je	SHORT $LN6@xsgetn
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmp	rax, rbp
	mov	rbx, rbp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rcx, r14
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmovb	rbx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	r8, rbx
	call	memcpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 199  :         *_IGcount -= _Off;

	mov	rax, QWORD PTR [rsi+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 535  :                     _Count_s -= _Read_size;

	sub	rdi, rbx
	add	r14, rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 200  :         *_IGnext += _Off;

	mov	r8, rdi
	sub	DWORD PTR [rax], ebx
	mov	rcx, QWORD PTR [rsi+56]
	movsxd	rax, ebx
	add	QWORD PTR [rcx], rax
$LN6@xsgetn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 539  :                 if (_Myfile) { // open C stream, attempt read

	cmp	QWORD PTR [rsi+128], 0
	je	$LN9@xsgetn
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 179  :         return *_IGfirst;

	mov	r9, QWORD PTR [rsi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 733  :         if (_Mysb::eback() == &_Mychar) {

	lea	rax, QWORD PTR [rsi+112]
	cmp	QWORD PTR [r9], rax
	jne	SHORT $LN24@xsgetn

; 734  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	rcx, QWORD PTR [rsi+136]
	mov	rdx, QWORD PTR [rsi+144]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 204  :         *_IGfirst = _First;

	mov	QWORD PTR [r9], rcx

; 205  :         *_IGnext  = _Next;
; 206  :         *_IGcount = (int) (_Last - _Next);

	sub	edx, ecx
	mov	rax, QWORD PTR [rsi+56]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR [rsi+80]
	mov	DWORD PTR [rax], edx
$LN24@xsgetn:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 544  :                     while (_Read_size < _Count_s) {

	mov	rbx, r8
	cmp	r8, 4095				; 00000fffH
	jbe	SHORT $LN3@xsgetn
	npad	9
$LL2@xsgetn:

; 545  :                         const auto _Actual_read = _CSTD fread(_Ptr, sizeof(_Elem), _Read_size, _Myfile);

	mov	r9, QWORD PTR [rsi+128]
	mov	edx, 1
	mov	r8d, 4095				; 00000fffH
	mov	rcx, r14
	call	QWORD PTR __imp_fread

; 546  :                         _Ptr += _Actual_read;
; 547  :                         _Count_s -= _Actual_read;

	sub	rdi, rax
	add	r14, rax
	mov	rbx, rdi

; 548  :                         if (_Actual_read != _Read_size) {

	cmp	rax, 4095				; 00000fffH
	jne	SHORT $LN31@xsgetn

; 544  :                     while (_Read_size < _Count_s) {

	cmp	rdi, rax
	ja	SHORT $LL2@xsgetn
$LN3@xsgetn:

; 550  :                         }
; 551  :                     }
; 552  : 
; 553  :                     if (0 < _Count_s) {

	mov	r8, rbx
	test	rbx, rbx
	je	SHORT $LN9@xsgetn

; 554  :                         _Count_s -= _CSTD fread(_Ptr, sizeof(_Elem), _Count_s, _Myfile);

	mov	r9, QWORD PTR [rsi+128]
	mov	r8, rdi
	mov	edx, 1
	mov	rcx, r14
	call	QWORD PTR __imp_fread
	mov	r8, rbx
	sub	r8, rax
$LN9@xsgetn:

; 555  :                     }
; 556  :                 }
; 557  : 
; 558  :                 return static_cast<streamsize>(_Start_count - _Count_s);

	sub	rbp, r8
$LN36@xsgetn:
	mov	rbx, QWORD PTR [rsp+40]
	mov	rax, rbp
	mov	rdi, QWORD PTR [rsp+32]

; 559  :             }
; 560  :         else { // non-chars always get element-by-element processing
; 561  :             return _Mysb::xsgetn(_Ptr, _Count);
; 562  :         }
; 563  :     }

	add	rsp, 48					; 00000030H
	pop	r14
	pop	rsi
	pop	rbp
	ret	0
$LN31@xsgetn:

; 549  :                             return static_cast<streamsize>(_Start_count - _Count_s);

	sub	rbp, rdi
	jmp	SHORT $LN36@xsgetn
?xsgetn@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::xsgetn
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
$T80 = 64
_Src$81 = 72
_Dest$82 = 80
_Ch$83 = 88
_Str$ = 96
__$ArrayPad$ = 128
this$ = 160
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT

; 457  :     virtual int_type __CLR_OR_THIS_CALL uflow() { // get an element from stream, point past it

$LN521:
	mov	rax, rsp
	push	rbp
	lea	rbp, QWORD PTR [rax-95]
	sub	rsp, 144				; 00000090H
	mov	QWORD PTR $T80[rbp-57], -2
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rdi
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rbp-57], rax
	mov	rdi, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 183  :         return *_IGnext;

	mov	rax, QWORD PTR [rcx+56]
	mov	rcx, QWORD PTR [rax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 458  :         if (_Mysb::gptr() != nullptr && _Mysb::gptr() < _Mysb::egptr()) {

	test	rcx, rcx
	je	SHORT $LN513@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 195  :         return *_IGnext + *_IGcount;

	mov	rdx, QWORD PTR [rdi+80]
	movsxd	r8, DWORD PTR [rdx]
	lea	rax, QWORD PTR [rcx+r8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 458  :         if (_Mysb::gptr() != nullptr && _Mysb::gptr() < _Mysb::egptr()) {

	cmp	rcx, rax
	jae	SHORT $LN513@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 219  :         --*_IGcount;

	lea	eax, DWORD PTR [r8-1]
	mov	DWORD PTR [rdx], eax

; 220  :         return (*_IGnext)++;

	mov	rcx, QWORD PTR [rdi+56]
	mov	rdx, QWORD PTR [rcx]
	lea	rax, QWORD PTR [rdx+1]
	mov	QWORD PTR [rcx], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, BYTE PTR [rdx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 459  :             return _Traits::to_int_type(*_Mysb::_Gninc()); // return buffered

	jmp	$LN490@uflow
$LN513@uflow:

; 460  :         }
; 461  : 
; 462  :         if (_Myfile == nullptr) {

	cmp	QWORD PTR [rdi+128], 0
	jne	SHORT $LN10@uflow

; 463  :             return _Traits::eof(); // no open C stream, fail

	mov	eax, -1
	jmp	$LN490@uflow
$LN10@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 179  :         return *_IGfirst;

	mov	r8, QWORD PTR [rdi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 733  :         if (_Mysb::eback() == &_Mychar) {

	lea	rax, QWORD PTR [rdi+112]
	cmp	QWORD PTR [r8], rax
	jne	SHORT $LN37@uflow

; 734  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	rdx, QWORD PTR [rdi+144]
	mov	rcx, QWORD PTR [rdi+136]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 204  :         *_IGfirst = _First;

	mov	QWORD PTR [r8], rcx

; 205  :         *_IGnext  = _Next;

	mov	rax, QWORD PTR [rdi+56]
	mov	QWORD PTR [rax], rcx

; 206  :         *_IGcount = (int) (_Last - _Next);

	sub	edx, ecx
	mov	rax, QWORD PTR [rdi+80]
	mov	DWORD PTR [rax], edx
$LN37@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 467  :         if (_Pcvt == nullptr) { // no codecvt facet, just get it

	mov	rcx, QWORD PTR [rdi+128]
	cmp	QWORD PTR [rdi+104], 0
	jne	SHORT $LN11@uflow

; 50   :     if ((_Meta = _CSTD fgetc(_File)) == EOF) {

	call	QWORD PTR __imp_fgetc
	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	ebx, al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 50   :     if ((_Meta = _CSTD fgetc(_File)) == EOF) {

	jne	$LN418@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 374  :         return EOF;

	mov	ebx, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 469  :             return _Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch) : _Traits::eof();

	jmp	$LN418@uflow
$LN11@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	QWORD PTR _Str$[rbp-41], 0

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR _Str$[rbp-33], 15

; 343  :         _Left = _Right;

	mov	BYTE PTR _Str$[rbp-57], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 477  :             int _Meta = _CSTD fgetc(_Myfile);

	call	QWORD PTR __imp_fgetc
	mov	r8d, eax

; 478  : 
; 479  :             if (_Meta == EOF) {

	cmp	eax, -1
	je	$LN502@uflow
	npad	7
$LL2@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3202 :         const size_type _Old_size = _My_data._Mysize;

	mov	rcx, QWORD PTR _Str$[rbp-41]
	mov	rdx, QWORD PTR _Str$[rbp-33]
	cmp	rcx, rdx

; 3203 :         if (_Old_size < _My_data._Myres) {

	jae	SHORT $LN135@uflow

; 3204 :             _My_data._Mysize  = _Old_size + 1;

	lea	rax, QWORD PTR [rcx+1]
	mov	QWORD PTR _Str$[rbp-41], rax

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR _Str$[rbp-57]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 16

; 2015 :         if (_Large_string_engaged()) {

	cmovae	rax, QWORD PTR _Str$[rbp-57]

; 343  :         _Left = _Right;

	mov	BYTE PTR [rax+rcx], r8b
	mov	BYTE PTR [rax+rcx+1], 0

; 3208 :             return;

	jmp	SHORT $LN134@uflow
$LN135@uflow:

; 3209 :         }
; 3210 : 
; 3211 :         _Reallocate_grow_by(1,

	movzx	r9d, r8b
	lea	rcx, QWORD PTR _Str$[rbp-57]
	call	??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
$LN134@uflow:

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR _Str$[rbp-57]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR _Str$[rbp-33], 16

; 2015 :         if (_Large_string_engaged()) {

	cmovae	rcx, QWORD PTR _Str$[rbp-57]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 487  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

	mov	r9, QWORD PTR _Str$[rbp-41]
	add	r9, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	r8, QWORD PTR _Str$[rbp-57]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR _Str$[rbp-33], 16

; 2015 :         if (_Large_string_engaged()) {

	cmovae	r8, QWORD PTR _Str$[rbp-57]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 487  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

	lea	rax, QWORD PTR _Dest$82[rbp-57]
	mov	QWORD PTR [rsp+56], rax
	lea	rax, QWORD PTR _Ch$83[rbp-56]
	mov	QWORD PTR [rsp+48], rax
	lea	rax, QWORD PTR _Ch$83[rbp-57]
	mov	QWORD PTR [rsp+40], rax
	lea	rax, QWORD PTR _Src$81[rbp-57]
	mov	QWORD PTR [rsp+32], rax
	lea	rdx, QWORD PTR [rdi+116]
	mov	rcx, QWORD PTR [rdi+104]
	call	QWORD PTR __imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z
	test	eax, eax
	js	SHORT $LN502@uflow
	cmp	eax, 1
	jg	$LN503@uflow

; 488  :                 _Dest)) { // test result of converting one element
; 489  :             case codecvt_base::partial:
; 490  :             case codecvt_base::ok:
; 491  :                 if (_Dest != &_Ch) { // got an element, put back excess and deliver it

	lea	rax, QWORD PTR _Ch$83[rbp-57]
	cmp	QWORD PTR _Dest$82[rbp-57], rax
	lea	rax, QWORD PTR _Str$[rbp-57]
	jne	$LN504@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR _Str$[rbp-33], 16

; 2015 :         if (_Large_string_engaged()) {

	cmovae	rax, QWORD PTR _Str$[rbp-57]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 500  :                 _Str.erase(0, static_cast<size_t>(_Src - _Str.data())); // partial, discard used input

	mov	r10, QWORD PTR _Src$81[rbp-57]
	sub	r10, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2053 :         return _Min_value(_Size, _Mysize - _Off);

	mov	r8, QWORD PTR _Str$[rbp-41]
	cmp	r8, r10
	cmovb	r10, r8

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	rcx, QWORD PTR _Str$[rbp-57]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR _Str$[rbp-33], 16

; 2015 :         if (_Large_string_engaged()) {

	cmovae	rcx, QWORD PTR _Str$[rbp-57]

; 2860 :         const size_type _New_size = _Old_size - _Count;

	sub	r8, r10

; 2861 :         _My_data._Mysize          = _New_size;

	mov	QWORD PTR _Str$[rbp-41], r8

; 2862 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

	inc	r8
	lea	rdx, QWORD PTR [rcx+r10]

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	call	memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 477  :             int _Meta = _CSTD fgetc(_Myfile);

	mov	rcx, QWORD PTR [rdi+128]
	call	QWORD PTR __imp_fgetc
	mov	r8d, eax

; 478  : 
; 479  :             if (_Meta == EOF) {

	cmp	eax, -1
	jne	$LL2@uflow
$LN502@uflow:

; 506  : 
; 507  :             default:
; 508  :                 return _Traits::eof(); // conversion failed

	mov	ebx, -1
$LN22@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR _Str$[rbp-33]
	cmp	rdx, 16

; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	$LN418@uflow

; 3872 :             const pointer _Ptr = _My_data._Bx._Ptr;
; 3873 :             auto& _Al          = _Getal();
; 3874 :             _Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3875 :             _Al.deallocate(_Ptr, _My_data._Myres + 1);

	inc	rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR _Str$[rbp-57]
	mov	rax, rcx

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	$LN428@uflow

; 107  :     _Bytes += _Non_user_size;

	add	rdx, 39					; 00000027H

; 108  : 
; 109  :     const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rcx-8]
	sub	rax, rcx

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	jbe	SHORT $LN428@uflow
	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	npad	1
$LN504@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR _Str$[rbp-33], 16

; 2015 :         if (_Large_string_engaged()) {

	cmovae	rax, QWORD PTR _Str$[rbp-57]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 492  :                     auto _Nleft = _Str.data() + _Str.size() - _Src;

	mov	rbx, QWORD PTR _Str$[rbp-41]
	mov	rcx, QWORD PTR _Src$81[rbp-57]
	sub	rbx, rcx
	add	rbx, rax

; 493  :                     while (0 < _Nleft) {

	test	rbx, rbx
	jle	SHORT $LN516@uflow
	npad	9
$LL7@uflow:

; 494  :                         _CSTD ungetc(_Src[--_Nleft], _Myfile);

	dec	rbx
	movsx	ecx, BYTE PTR [rbx+rcx]
	mov	rdx, QWORD PTR [rdi+128]
	call	QWORD PTR __imp_ungetc

; 493  :                     while (0 < _Nleft) {

	test	rbx, rbx
	jle	SHORT $LN516@uflow
	mov	rcx, QWORD PTR _Src$81[rbp-57]
	jmp	SHORT $LL7@uflow
$LN516@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	ebx, BYTE PTR _Ch$83[rbp-57]
	jmp	$LN22@uflow
$LN503@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 487  :             switch (_Pcvt->in(_State, _Str.data(), _Str.data() + _Str.size(), _Src, &_Ch, &_Ch + 1,

	cmp	eax, 3
	jne	$LN502@uflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2014 :         value_type* _Result = _Bx._Buf;

	lea	rax, QWORD PTR _Str$[rbp-57]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR _Str$[rbp-33], 16

; 2015 :         if (_Large_string_engaged()) {

	cmovae	rax, QWORD PTR _Str$[rbp-57]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 505  :                 return static_cast<int_type>(_Str.front());

	movsx	ebx, BYTE PTR [rax]
	jmp	$LN22@uflow
$LN428@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN418@uflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 511  :     }

	mov	eax, ebx
$LN490@uflow:
	mov	rcx, QWORD PTR __$ArrayPad$[rbp-57]
	xor	rcx, rsp
	call	__security_check_cookie
	lea	r11, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [r11+24]
	mov	rdi, QWORD PTR [r11+32]
	mov	rsp, r11
	pop	rbp
	ret	0
$LN518@uflow:
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T80 = 64
_Src$81 = 72
_Dest$82 = 80
_Ch$83 = 88
_Str$ = 96
__$ArrayPad$ = 128
this$ = 160
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
	lea	rcx, QWORD PTR _Str$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T80 = 64
_Src$81 = 72
_Dest$82 = 80
_Ch$83 = 88
_Str$ = 96
__$ArrayPad$ = 128
this$ = 160
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
	lea	rcx, QWORD PTR _Str$[rdx]
	jmp	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
this$ = 48
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT

; 445  :     virtual int_type __CLR_OR_THIS_CALL underflow() { // get an element from stream, but don't point past it

$LN24:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 183  :         return *_IGnext;

	mov	rax, QWORD PTR [rcx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 445  :     virtual int_type __CLR_OR_THIS_CALL underflow() { // get an element from stream, but don't point past it

	mov	rbx, rcx

; 447  :         if (_Mysb::gptr() != nullptr && _Mysb::gptr() < _Mysb::egptr()) {

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN2@underflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 195  :         return *_IGnext + *_IGcount;

	mov	rax, QWORD PTR [rbx+80]
	movsxd	rdx, DWORD PTR [rax]
	add	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 447  :         if (_Mysb::gptr() != nullptr && _Mysb::gptr() < _Mysb::egptr()) {

	cmp	rcx, rdx
	jae	SHORT $LN2@underflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, BYTE PTR [rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 455  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN2@underflow:

; 449  :         } else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow())) {

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	mov	QWORD PTR [rsp+48], rdi
	call	QWORD PTR [rax+56]
	mov	edi, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 449  :         } else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow())) {

	jne	SHORT $LN4@underflow
	mov	rdi, QWORD PTR [rsp+48]

; 455  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN4@underflow:

; 450  :             return _Meta; // uflow failed, return EOF
; 451  :         } else { // get a char, don't point past it
; 452  :             pbackfail(_Meta);

	mov	rax, QWORD PTR [rbx]
	mov	edx, edi
	mov	rcx, rbx
	call	QWORD PTR [rax+32]

; 453  :             return _Meta;

	mov	eax, edi
	mov	rdi, QWORD PTR [rsp+48]

; 455  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
this$ = 48
_Meta$ = 56
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT

; 425  :     virtual int_type __CLR_OR_THIS_CALL pbackfail(int_type _Meta = _Traits::eof()) { // put an element back to stream

$LN73:
	mov	QWORD PTR [rsp+24], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 183  :         return *_IGnext;

	mov	rax, QWORD PTR [rcx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 425  :     virtual int_type __CLR_OR_THIS_CALL pbackfail(int_type _Meta = _Traits::eof()) { // put an element back to stream

	mov	rbx, rcx
	mov	edi, edx

; 427  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

	mov	rcx, QWORD PTR [rax]
	test	rcx, rcx
	je	SHORT $LN2@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 179  :         return *_IGfirst;

	mov	rax, QWORD PTR [rbx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 427  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

	cmp	QWORD PTR [rax], rcx
	jae	SHORT $LN2@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	edx, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 427  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

	je	SHORT $LN4@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 361  :         return static_cast<unsigned char>(_Ch);

	movzx	eax, BYTE PTR [rcx-1]

; 366  :         return _Left == _Right;

	cmp	eax, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 427  :             && (_Traits::eq_int_type(_Traits::eof(), _Meta)

	jne	SHORT $LN2@pbackfail
$LN4@pbackfail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 214  :         ++*_IGcount;

	mov	rax, QWORD PTR [rbx+80]
	inc	DWORD PTR [rax]

; 215  :         return --*_IGnext;

	mov	rax, QWORD PTR [rbx+56]
	dec	QWORD PTR [rax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 370  :         return _Meta != eof() ? _Meta : !eof();

	xor	eax, eax
	cmp	edi, -1
	cmovne	eax, edi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 443  :     }

	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@pbackfail:

; 432  :         } else if (_Myfile == nullptr || _Traits::eq_int_type(_Traits::eof(), _Meta)) {

	mov	rdx, QWORD PTR [rbx+128]
	test	rdx, rdx
	je	SHORT $LN7@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	edi, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 432  :         } else if (_Myfile == nullptr || _Traits::eq_int_type(_Traits::eof(), _Meta)) {

	je	SHORT $LN7@pbackfail

; 433  :             return _Traits::eof(); // no open C stream or EOF, fail
; 434  :         } else if (_Pcvt == nullptr && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

	cmp	QWORD PTR [rbx+104], 0
	jne	SHORT $LN68@pbackfail

; 113  :     return _CSTD ungetc((unsigned char) _Byte, _File) != EOF;

	movzx	ecx, dil
	call	QWORD PTR __imp_ungetc
	cmp	eax, -1

; 433  :             return _Traits::eof(); // no open C stream or EOF, fail
; 434  :         } else if (_Pcvt == nullptr && _Ungetc(_Traits::to_char_type(_Meta), _Myfile)) {

	jne	SHORT $LN70@pbackfail
$LN68@pbackfail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 183  :         return *_IGnext;

	mov	r8, QWORD PTR [rbx+56]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 436  :         } else if (_Mysb::gptr() != &_Mychar) { // putback to _Mychar

	lea	rdx, QWORD PTR [rbx+112]
	cmp	QWORD PTR [r8], rdx
	je	SHORT $LN7@pbackfail
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 179  :         return *_IGfirst;

	mov	r9, QWORD PTR [rbx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 437  :             _Mychar = _Traits::to_char_type(_Meta);

	mov	BYTE PTR [rdx], dil

; 739  :         if (_Mysb::eback() != &_Mychar) { // save current get buffer

	mov	rax, QWORD PTR [r9]
	cmp	rax, rdx
	je	SHORT $LN69@pbackfail

; 740  :             _Set_eback = _Mysb::eback();

	mov	QWORD PTR [rbx+136], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 195  :         return *_IGnext + *_IGcount;

	mov	rax, QWORD PTR [rbx+80]
	movsxd	rcx, DWORD PTR [rax]
	add	rcx, QWORD PTR [r8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 741  :             _Set_egptr = _Mysb::egptr();

	mov	QWORD PTR [rbx+144], rcx
$LN69@pbackfail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 204  :         *_IGfirst = _First;

	mov	QWORD PTR [r9], rdx

; 205  :         *_IGnext  = _Next;
; 206  :         *_IGcount = (int) (_Last - _Next);

	mov	ecx, ebx
	mov	rax, QWORD PTR [rbx+56]
	sub	ecx, edx
	add	ecx, 113				; 00000071H
	mov	QWORD PTR [rax], rdx
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], ecx
$LN70@pbackfail:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 443  :     }

	mov	eax, edi
	mov	rbx, QWORD PTR [rsp+64]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN7@pbackfail:
	mov	rbx, QWORD PTR [rsp+64]
	mov	eax, -1
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
_Dest$ = 64
_Src$ = 72
_Ch$ = 80
_Str$ = 88
__$ArrayPad$ = 120
this$ = 144
_Meta$ = 152
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT

; 374  :     virtual int_type __CLR_OR_THIS_CALL overflow(int_type _Meta = _Traits::eof()) { // put an element to stream

$LN70:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 128				; 00000080H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	edi, edx
	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	edx, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 375  :         if (_Traits::eq_int_type(_Traits::eof(), _Meta)) {

	jne	SHORT $LN4@overflow

; 376  :             return _Traits::not_eof(_Meta); // EOF, return success code

	xor	eax, eax
	jmp	$LN1@overflow
$LN4@overflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 191  :         return *_IPnext;

	mov	rdx, QWORD PTR [rcx+64]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 379  :         if (_Mysb::pptr() != nullptr && _Mysb::pptr() < _Mysb::epptr()) { // room in buffer, store it

	mov	rax, QWORD PTR [rdx]
	test	rax, rax
	je	SHORT $LN5@overflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 210  :         return *_IPnext + *_IPcount;

	mov	rdx, QWORD PTR [rcx+88]
	movsxd	r8, DWORD PTR [rdx]
	add	r8, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 379  :         if (_Mysb::pptr() != nullptr && _Mysb::pptr() < _Mysb::epptr()) { // room in buffer, store it

	cmp	rax, r8
	jae	SHORT $LN5@overflow

; 380  :             *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

	call	QWORD PTR __imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ
	mov	BYTE PTR [rax], dil

; 381  :             return _Meta;

	mov	eax, edi
	jmp	$LN1@overflow
$LN5@overflow:

; 382  :         }
; 383  : 
; 384  :         if (_Myfile == nullptr) {

	cmp	QWORD PTR [rcx+128], 0
	mov	QWORD PTR [rsp+160], rsi
	je	$LN12@overflow
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 179  :         return *_IGfirst;

	mov	r8, QWORD PTR [rcx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 733  :         if (_Mysb::eback() == &_Mychar) {

	lea	rax, QWORD PTR [rcx+112]
	cmp	QWORD PTR [r8], rax
	jne	SHORT $LN43@overflow

; 734  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	rdx, QWORD PTR [rcx+144]
	mov	rcx, QWORD PTR [rcx+136]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 204  :         *_IGfirst = _First;

	mov	QWORD PTR [r8], rcx

; 205  :         *_IGnext  = _Next;
; 206  :         *_IGcount = (int) (_Last - _Next);

	sub	edx, ecx
	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax], rcx
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], edx
$LN43@overflow:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 389  :         if (_Pcvt == nullptr) { // no codecvt facet, put as is

	mov	rcx, QWORD PTR [rbx+104]
	test	rcx, rcx
	jne	SHORT $LN7@overflow

; 90   :     return _CSTD fputc(_Byte, _File) != EOF;

	mov	rdx, QWORD PTR [rbx+128]
	movsx	ecx, dil
	call	QWORD PTR __imp_fputc

; 390  :             return _Fputc(_Traits::to_char_type(_Meta), _Myfile) ? _Meta : _Traits::eof();

	mov	ecx, -1

; 90   :     return _CSTD fputc(_Byte, _File) != EOF;

	cmp	eax, ecx

; 390  :             return _Fputc(_Traits::to_char_type(_Meta), _Myfile) ? _Meta : _Traits::eof();

	cmovne	ecx, edi
	mov	eax, ecx
	jmp	$LN67@overflow
$LN7@overflow:

; 399  :         switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf,

	lea	rax, QWORD PTR _Dest$[rsp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 357  :         return static_cast<char>(_Meta);

	mov	BYTE PTR _Ch$[rsp], dil
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 399  :         switch (_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Str, _Str + _Codecvt_temp_buf,

	mov	QWORD PTR [rsp+56], rax
	lea	rdx, QWORD PTR [rbx+116]
	lea	rax, QWORD PTR _Str$[rsp+32]
	mov	QWORD PTR [rsp+48], rax
	lea	r9, QWORD PTR _Ch$[rsp+1]
	lea	rax, QWORD PTR _Str$[rsp]
	mov	QWORD PTR [rsp+40], rax
	lea	r8, QWORD PTR _Ch$[rsp]
	lea	rax, QWORD PTR _Src$[rsp]
	mov	QWORD PTR [rsp+32], rax
	call	QWORD PTR __imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z
	test	eax, eax
	js	SHORT $LN12@overflow
	cmp	eax, 1
	jle	SHORT $LN8@overflow
	cmp	eax, 3
	jne	SHORT $LN12@overflow

; 90   :     return _CSTD fputc(_Byte, _File) != EOF;

	movsx	ecx, BYTE PTR _Ch$[rsp]
	mov	rdx, QWORD PTR [rbx+128]
	call	QWORD PTR __imp_fputc

; 411  :             }
; 412  : 
; 413  :             return _Traits::eof(); // conversion failed
; 414  :         }
; 415  : 
; 416  :         case codecvt_base::noconv:
; 417  :             // no conversion, put as is
; 418  :             return _Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof();

	mov	ecx, -1

; 90   :     return _CSTD fputc(_Byte, _File) != EOF;

	cmp	eax, ecx

; 411  :             }
; 412  : 
; 413  :             return _Traits::eof(); // conversion failed
; 414  :         }
; 415  : 
; 416  :         case codecvt_base::noconv:
; 417  :             // no conversion, put as is
; 418  :             return _Fputc(_Ch, _Myfile) ? _Meta : _Traits::eof();

	cmovne	ecx, edi
	mov	eax, ecx
	jmp	SHORT $LN67@overflow
$LN8@overflow:

; 400  :             _Dest)) { // test result of converting one element
; 401  :         case codecvt_base::partial:
; 402  :         case codecvt_base::ok: { // converted something, try to put it out
; 403  :             const auto _Count = static_cast<size_t>(_Dest - _Str);

	mov	rsi, QWORD PTR _Dest$[rsp]
	lea	rax, QWORD PTR _Str$[rsp]
	sub	rsi, rax

; 404  :             if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

	je	SHORT $LN9@overflow
	mov	r9, QWORD PTR [rbx+128]
	lea	rcx, QWORD PTR _Str$[rsp]
	mov	r8, rsi
	mov	edx, 1
	call	QWORD PTR __imp_fwrite
	cmp	rsi, rax
	jne	SHORT $LN12@overflow
$LN9@overflow:

; 405  :                 return _Traits::eof(); // write failed
; 406  :             }
; 407  : 
; 408  :             _Wrotesome = true; // write succeeded
; 409  :             if (_Src != &_Ch) {

	lea	rax, QWORD PTR _Ch$[rsp]
	mov	BYTE PTR [rbx+113], 1
	cmp	QWORD PTR _Src$[rsp], rax

; 410  :                 return _Meta; // converted whole element

	mov	eax, edi
	jne	SHORT $LN67@overflow
$LN12@overflow:

; 419  : 
; 420  :         default:
; 421  :             return _Traits::eof(); // conversion failed

	mov	eax, -1
$LN67@overflow:
	mov	rsi, QWORD PTR [rsp+160]
$LN1@overflow:

; 422  :         }
; 423  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+168]
	add	rsp, 128				; 00000080H
	pop	rdi
	ret	0
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT

; 368  :         if (_Myfile) {

	mov	rcx, QWORD PTR [rcx+128]
	test	rcx, rcx
	je	SHORT $LN2@Unlock

; 369  :             _CSTD _unlock_file(_Myfile);

	rex_jmp	QWORD PTR __imp__unlock_file
$LN2@Unlock:

; 370  :         }
; 371  :     }

	ret	0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT

; 362  :         if (_Myfile) {

	mov	rcx, QWORD PTR [rcx+128]
	test	rcx, rcx
	je	SHORT $LN2@Lock

; 363  :             _CSTD _lock_file(_Myfile);

	rex_jmp	QWORD PTR __imp__lock_file
$LN2@Lock:

; 364  :         }
; 365  :     }

	ret	0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
$T2 = 32
this$ = 64
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT

; 150  :     virtual __CLR_OR_THIS_CALL ~basic_filebuf() noexcept { // destroy the object

$LN31:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T2[rsp], -2
	mov	rbx, rcx
	lea	rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rcx], rax

; 151  :         if (_Myfile != nullptr) {

	cmp	QWORD PTR [rcx+128], 0
	je	SHORT $LN6@basic_file
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 179  :         return *_IGfirst;

	mov	r8, QWORD PTR [rcx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 733  :         if (_Mysb::eback() == &_Mychar) {

	lea	rax, QWORD PTR [rcx+112]
	cmp	QWORD PTR [r8], rax
	jne	SHORT $LN6@basic_file

; 734  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	rdx, QWORD PTR [rcx+144]
	mov	rcx, QWORD PTR [rcx+136]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 204  :         *_IGfirst = _First;

	mov	QWORD PTR [r8], rcx

; 205  :         *_IGnext  = _Next;

	mov	rax, QWORD PTR [rbx+56]
	mov	QWORD PTR [rax], rcx

; 206  :         *_IGcount = (int) (_Last - _Next);

	sub	edx, ecx
	mov	rax, QWORD PTR [rbx+80]
	mov	DWORD PTR [rax], edx
$LN6@basic_file:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 155  :         if (_Closef) {

	cmp	BYTE PTR [rbx+124], 0
	je	SHORT $LN3@basic_file

; 346  :         if (_Myfile == nullptr) {

	cmp	QWORD PTR [rbx+128], 0
	je	SHORT $LN16@basic_file

; 347  :             _Ans = nullptr;
; 348  :         } else { // put any homing sequence and close file
; 349  :             if (!_Endwrite()) {

	mov	rcx, rbx
	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
	npad	1

; 350  :                 _Ans = nullptr;
; 351  :             }
; 352  : 
; 353  :             if (_CSTD fclose(_Myfile) != 0) {

	mov	rcx, QWORD PTR [rbx+128]
	call	QWORD PTR __imp_fclose
	npad	1
$LN16@basic_file:

; 657  :         _Closef    = _Which == _Openfl;

	mov	BYTE PTR [rbx+124], 0

; 658  :         _Wrotesome = false;

	mov	BYTE PTR [rbx+113], 0

; 659  : 
; 660  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	rcx, rbx
	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
	npad	1

; 661  : 
; 662  :         if (_File != nullptr && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 663  :             _Elem** _Pb = nullptr;
; 664  :             _Elem** _Pn = nullptr;
; 665  :             int* _Nr    = nullptr;
; 666  : 
; 667  :             ::_get_stream_buffer_pointers(
; 668  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 669  :             int* _Nw = _Nr;
; 670  : 
; 671  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 672  :         }
; 673  : 
; 674  :         _Myfile = _File;

	xor	ecx, ecx
	mov	QWORD PTR [rbx+128], rcx

; 675  :         _State  = _Stinit;

	mov	rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
	mov	QWORD PTR [rbx+116], rax

; 676  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	QWORD PTR [rbx+104], rcx
$LN3@basic_file:

; 156  :             close();
; 157  :         }
; 158  :     }

	mov	rcx, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>, COMDAT
	ret	0
??1?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::~_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN12:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 906  :     virtual __CLR_OR_THIS_CALL ~basic_ifstream() noexcept { // destroy the object

	mov	rax, QWORD PTR [rcx-176]
	mov	rbx, rcx
	mov	edi, edx
	movsxd	r8, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [r8+rcx-176], rax
	mov	rax, QWORD PTR [rcx-176]
	movsxd	r8, DWORD PTR [rax+4]
	lea	r9d, DWORD PTR [r8-176]
	mov	DWORD PTR [r8+rcx-180], r9d

; 907  :     }

	add	rcx, -160				; ffffffffffffff60H
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	lea	rcx, QWORD PTR [rbx-152]
	call	QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	mov	rcx, rbx
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
	test	dil, 1
	je	SHORT $LN9@scalar
	mov	edx, 272				; 00000110H
	lea	rcx, QWORD PTR [rbx-176]
	call	??3@YAXPEAX_K@Z				; operator delete
$LN9@scalar:
	mov	rsi, QWORD PTR [rsp+56]
	lea	rax, QWORD PTR [rbx-176]
	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN7:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	ebx, edx
	mov	rdi, rcx
	call	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
	test	bl, 1
	je	SHORT $LN4@scalar
	mov	edx, 152				; 00000098H
	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
$LN4@scalar:
	mov	rbx, QWORD PTR [rsp+48]
	mov	rax, rdi
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >, COMDAT
	ret	0
??1?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::~_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\chrono
;	COMDAT ?zero@?$duration_values@_J@chrono@std@@SA_JXZ
_TEXT	SEGMENT
?zero@?$duration_values@_J@chrono@std@@SA_JXZ PROC	; std::chrono::duration_values<__int64>::zero, COMDAT

; 33   :             // get zero value
; 34   :             return _Rep(0);

	xor	eax, eax

; 35   :         }

	ret	0
?zero@?$duration_values@_J@chrono@std@@SA_JXZ ENDP	; std::chrono::duration_values<__int64>::zero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myfirst@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAPEADXZ PROC ; std::vector<char,std::allocator<char> >::_Myfirst, COMDAT

; 1615 :         return _Get_data()._Myfirst;

	mov	rax, rcx

; 1616 :     }

	ret	0
?_Myfirst@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAPEADXZ ENDP ; std::vector<char,std::allocator<char> >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ PROC	; std::vector<char,std::allocator<char> >::_Tidy, COMDAT

; 1522 :     void _Tidy() noexcept { // free all storage

$LN49:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx

; 1523 :         _Orphan_all();
; 1524 :         auto& _My_data    = _Get_data();
; 1525 :         const auto _First = _My_data._Myfirst;

	mov	rcx, QWORD PTR [rcx]

; 1526 :         if (_First != pointer()) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN2@Tidy

; 1527 :             _Destroy(_First, _My_data._Mylast);
; 1528 :             _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN42@Tidy

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN39@Tidy

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN42@Tidy:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1530 :             _My_data._Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1531 :             _My_data._Mylast  = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1532 :             _My_data._Myend   = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN2@Tidy:

; 1534 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN39@Tidy:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN46@Tidy:
?_Tidy@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ ENDP	; std::vector<char,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Mylast@?$vector@NV?$allocator@N@std@@@std@@AEAAAEAPEANXZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$vector@NV?$allocator@N@std@@@std@@AEAAAEAPEANXZ PROC ; std::vector<double,std::allocator<double> >::_Mylast, COMDAT

; 1623 :         return _Get_data()._Mylast;

	lea	rax, QWORD PTR [rcx+8]

; 1624 :     }

	ret	0
?_Mylast@?$vector@NV?$allocator@N@std@@@std@@AEAAAEAPEANXZ ENDP ; std::vector<double,std::allocator<double> >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Orphan_range@?$vector@NV?$allocator@N@std@@@std@@AEBAXPEAN0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Orphan_range@?$vector@NV?$allocator@N@std@@@std@@AEBAXPEAN0@Z PROC ; std::vector<double,std::allocator<double> >::_Orphan_range, COMDAT

; 1545 : #if _ITERATOR_DEBUG_LEVEL == 2
; 1546 :         _Lockit _Lock(_LOCK_DEBUG);
; 1547 : 
; 1548 :         const_iterator** _Pnext = reinterpret_cast<const_iterator**>(_Getpfirst());
; 1549 : 
; 1550 :         if (_Pnext) {
; 1551 :             while (*_Pnext) {
; 1552 :                 if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr) { // skip the iterator
; 1553 :                     _Pnext = reinterpret_cast<const_iterator**>((*_Pnext)->_Getpnext());
; 1554 :                 } else { // orphan the iterator
; 1555 :                     (*_Pnext)->_Clrcont();
; 1556 :                     *_Pnext = *reinterpret_cast<const_iterator**>((*_Pnext)->_Getpnext());
; 1557 :                 }
; 1558 :             }
; 1559 :         }
; 1560 : #else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
; 1561 :         (void) _First;
; 1562 :         (void) _Last;
; 1563 : #endif // _ITERATOR_DEBUG_LEVEL == 2
; 1564 :     }

	ret	0
?_Orphan_range@?$vector@NV?$allocator@N@std@@@std@@AEBAXPEAN0@Z ENDP ; std::vector<double,std::allocator<double> >::_Orphan_range
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Has_unused_capacity@?$vector@NV?$allocator@N@std@@@std@@AEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Has_unused_capacity@?$vector@NV?$allocator@N@std@@@std@@AEBA_NXZ PROC ; std::vector<double,std::allocator<double> >::_Has_unused_capacity, COMDAT

; 1357 :         return _Myend() != _Mylast();

	mov	rax, QWORD PTR [rcx+8]
	cmp	QWORD PTR [rcx+16], rax
	setne	al

; 1358 :     }

	ret	0
?_Has_unused_capacity@?$vector@NV?$allocator@N@std@@@std@@AEBA_NXZ ENDP ; std::vector<double,std::allocator<double> >::_Has_unused_capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Move_construct@?$vector@NV?$allocator@N@std@@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$dead$ = 24
?_Move_construct@?$vector@NV?$allocator@N@std@@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::vector<double,std::allocator<double> >::_Move_construct, COMDAT

; 491  :         _My_data._Myfirst = _Right_data._Myfirst;

	mov	rax, QWORD PTR [rdx]
	mov	QWORD PTR [rcx], rax

; 492  :         _My_data._Mylast  = _Right_data._Mylast;

	mov	rax, QWORD PTR [rdx+8]
	mov	QWORD PTR [rcx+8], rax

; 493  :         _My_data._Myend   = _Right_data._Myend;

	mov	rax, QWORD PTR [rdx+16]
	mov	QWORD PTR [rcx+16], rax

; 494  : 
; 495  :         _Right_data._Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rdx], rax

; 496  :         _Right_data._Mylast  = pointer();

	mov	QWORD PTR [rdx+8], rax

; 497  :         _Right_data._Myend   = pointer();

	mov	QWORD PTR [rdx+16], rax

; 502  :         _Take_contents(_Right);
; 503  :     }

	ret	0
?_Move_construct@?$vector@NV?$allocator@N@std@@@std@@AEAAXAEAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<double,std::allocator<double> >::_Move_construct
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 120  :             return _Ok;

	movzx	eax, BYTE PTR [rcx+8]

; 121  :         }

	ret	0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T3 = 32
this$ = 64
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 104  :         __CLR_OR_THIS_CALL ~sentry() noexcept { // destroy the object

$LN15:
	push	rbx
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T3[rsp], -2
	mov	rbx, rcx

; 105  : #if _HAS_EXCEPTIONS
; 106  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	QWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	npad	1
	test	al, al
	jne	SHORT $LN2@sentry

; 107  :                 this->_Myostr._Osfx();

	mov	rcx, QWORD PTR [rbx]
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN2@sentry:

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	rdx, QWORD PTR [rbx]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rcx+rdx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	test	rcx, rcx
	je	SHORT $LN12@sentry

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN12@sentry:

; 108  :             }
; 109  : #else // _HAS_EXCEPTIONS
; 110  :             this->_Myostr._Osfx();
; 111  : #endif // _HAS_EXCEPTIONS
; 112  :         }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
$T8 = 32
this$ = 64
_Ostr$ = 72
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 88   :         explicit __CLR_OR_THIS_CALL sentry(basic_ostream& _Ostr)

$LN28:
	mov	QWORD PTR [rsp+8], rcx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	QWORD PTR $T8[rsp], -2
	mov	QWORD PTR [rsp+72], rbx
	mov	rbx, rdx
	mov	rdi, rcx

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	QWORD PTR [rcx], rdx

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	mov	rdx, QWORD PTR [rdx]
	movsxd	rax, DWORD PTR [rdx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rax+rbx+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	test	rcx, rcx
	je	SHORT $LN6@sentry

; 71   :                 _Myostr.rdbuf()->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
	mov	rdx, QWORD PTR [rbx]
$LN6@sentry:

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	movsxd	rcx, DWORD PTR [rdx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 302  :         return _Mystate;

	mov	rax, rdx

; 321  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [rcx+rbx+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	jne	SHORT $LN2@sentry
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 67   :         return _Tiestr;

	mov	rcx, QWORD PTR [rcx+rbx+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	test	rcx, rcx
	je	SHORT $LN2@sentry
	cmp	rcx, rbx
	je	SHORT $LN2@sentry

; 91   :                 _Ostr.tie()->flush();

	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
	mov	rax, QWORD PTR [rbx]
$LN2@sentry:

; 94   :             _Ok = _Ostr.good(); // store test only after flushing tie

	movsxd	rax, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 321  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [rax+rbx+16], 0
	sete	al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 94   :             _Ok = _Ostr.good(); // store test only after flushing tie

	mov	BYTE PTR [rdi+8], al

; 95   :         }

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T8 = 32
this$ = 64
_Ostr$ = 72
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 32
this$ = 64
_Ostr$ = 72
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
	mov	rcx, QWORD PTR this$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty, COMDAT

; 2061 :         }

	ret	0
??1_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged, COMDAT

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8
	setae	al

; 2033 :     }

	ret	0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2023 :         const value_type* _Result = _Bx._Buf;
; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@Myptr

; 2025 :             _Result = _Unfancy(_Bx._Ptr);
; 2026 :         }
; 2027 : 
; 2028 :         return _Result;

	mov	rax, QWORD PTR [rcx]

; 2029 :     }

	ret	0
$LN8@Myptr:

; 2025 :             _Result = _Unfancy(_Bx._Ptr);
; 2026 :         }
; 2027 : 
; 2028 :         return _Result;

	mov	rax, rcx

; 2029 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEBAPEB_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr, COMDAT

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2014 :         value_type* _Result = _Bx._Buf;
; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@Myptr

; 2016 :             _Result = _Unfancy(_Bx._Ptr);
; 2017 :         }
; 2018 : 
; 2019 :         return _Result;

	mov	rax, QWORD PTR [rcx]

; 2020 :     }

	ret	0
$LN8@Myptr:

; 2016 :             _Result = _Unfancy(_Bx._Ptr);
; 2017 :         }
; 2018 : 
; 2019 :         return _Result;

	mov	rax, rcx

; 2020 :     }

	ret	0
?_Myptr@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAAPEA_WXZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction, COMDAT

; 832  :         return _Al;

	mov	rax, rcx

; 833  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA?AV?$allocator@_W@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size, COMDAT

; 828  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 829  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SA_KAEBV?$allocator@_W@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEADXZ
_TEXT	SEGMENT
this$ = 8
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT

; 1910 :         return const_cast<reference>(_Mybase::operator*());

	mov	rax, QWORD PTR [rcx]

; 1911 :     }

	ret	0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pstring$dead$ = 24
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1707 :         : _Ptr(_Parg) { // construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 1906 :         : _Mybase(_Parg, _Pstring) { // construct with pointer _Parg
; 1907 :     }

	mov	rax, rcx
	ret	0
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 832  :         return _Al;

	mov	rax, rcx

; 833  :     }

	ret	0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Get_data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Get_data, COMDAT

; 3912 :         return _Mypair._Get_second();

	mov	rax, rcx

; 3913 :     }

	ret	0
?_Get_data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Get_data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Get_data, COMDAT

; 3908 :         return _Mypair._Get_second();

	mov	rax, rcx

; 3909 :     }

	ret	0
?_Get_data@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT

; 3904 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3905 :     }

	ret	0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBAAEBV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal, COMDAT

; 3900 :         return _Mypair._Get_first();

	mov	rax, rcx

; 3901 :     }

	ret	0
?_Getal@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV?$allocator@_W@2@XZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate, COMDAT

; 3868 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

$LN49:
	push	rbx
	sub	rsp, 32					; 00000020H

; 2032 :         return _BUF_SIZE <= _Myres;

	mov	rdx, QWORD PTR [rcx+24]

; 3868 :     void _Tidy_deallocate() noexcept { // initialize buffer, deallocating any storage

	mov	rbx, rcx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 8

; 3869 :         _Orphan_all();
; 3870 :         auto& _My_data = _Get_data();
; 3871 :         if (_My_data._Large_string_engaged()) {

	jb	SHORT $LN30@Tidy_deall
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rcx]
	lea	rdx, QWORD PTR [rdx*2+2]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN40@Tidy_deall

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN37@Tidy_deall

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN40@Tidy_deall:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN30@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3878 :         _My_data._Mysize = 0;

	xor	eax, eax

; 3879 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rbx+24], 7
	mov	QWORD PTR [rbx+16], rax

; 211  :         _Left = _Right;

	mov	WORD PTR [rbx], ax

; 3883 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN37@Tidy_deall:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN46@Tidy_deall:
?_Tidy_deallocate@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init, COMDAT

; 3860 :         auto& _My_data   = _Get_data();
; 3861 :         _My_data._Mysize = 0;

	xor	eax, eax

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7
	mov	QWORD PTR [rcx+16], rax

; 211  :         _Left = _Right;

	mov	WORD PTR [rcx], ax

; 3863 :         // the _Traits::assign is last so the codegen doesn't think the char
; 3864 :         // write can alias this
; 3865 :         _Traits::assign(_My_data._Bx._Buf[0], _Elem());
; 3866 :     }

	ret	0
?_Tidy_init@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAX_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos, COMDAT

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	rax, rcx

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN8@Eos
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rax, QWORD PTR [rcx]
$LN8@Eos:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3856 :         _Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

	mov	QWORD PTR [rcx+16], rdx

; 211  :         _Left = _Right;

	xor	ecx, ecx
	mov	WORD PTR [rax+rdx*2], cx

; 3857 :     }

	ret	0
?_Eos@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAX_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K_W@Z
_TEXT	SEGMENT
this$ = 64
_Count$ = 72
_Ch$dead$ = 80
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append, COMDAT

; 2630 :     basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // append _Count * _Ch

$LN30:
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	r8, rcx

; 2631 :         auto& _My_data            = _Get_data();
; 2632 :         const size_type _Old_size = _My_data._Mysize;

	mov	rcx, QWORD PTR [rcx+16]

; 2633 :         if (_Count <= _My_data._Myres - _Old_size) {

	mov	rdi, QWORD PTR [r8+24]
	mov	rax, rdi
	sub	rax, rcx
	cmp	rdx, rax
	ja	SHORT $LN2@append

; 2634 :             _My_data._Mysize      = _Old_size + _Count;

	lea	r10, QWORD PTR [rcx+rdx]

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	r9, r8

; 2634 :             _My_data._Mysize      = _Old_size + _Count;

	mov	QWORD PTR [r8+16], r10

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	rdi, 8

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@append
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	r9, QWORD PTR [r8]
$LN9@append:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	xor	r11d, r11d
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2636 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	lea	rdi, QWORD PTR [r9+rcx*2]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	test	rdx, rdx
	je	SHORT $LN20@append
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 207  :         return reinterpret_cast<_Elem*>(_CSTD wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));

	movzx	eax, r11w
	mov	rcx, rdx
	rep stosw
$LN20@append:

; 211  :         _Left = _Right;

	mov	WORD PTR [r9+r10*2], r11w

; 2637 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
; 2638 :             return *this;

	mov	rax, r8

; 2642 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 2643 :                 const _Elem _Ch) {
; 2644 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2645 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2646 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2647 :             },
; 2648 :             _Count, _Ch);
; 2649 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN2@append:

; 2639 :         }
; 2640 : 
; 2641 :         return _Reallocate_grow_by(_Count,

	mov	r9, rdx
	mov	rcx, r8
	call	??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_a3050a43f3157934f354774ab3dd2e02>,unsigned __int64,wchar_t>

; 2642 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 2643 :                 const _Elem _Ch) {
; 2644 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2645 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2646 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2647 :             },
; 2648 :             _Count, _Ch);
; 2649 :     }

	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?append@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAAEAV12@_K_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??R<lambda_a3050a43f3157934f354774ab3dd2e02>@@QEBAXQEA_WQEB_W_K2_W@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Count$ = 80
_Ch$dead$ = 88
??R<lambda_a3050a43f3157934f354774ab3dd2e02>@@QEBAXQEA_WQEB_W_K2_W@Z PROC ; <lambda_a3050a43f3157934f354774ab3dd2e02>::operator(), COMDAT

; 2643 :                 const _Elem _Ch) {

$LN22:
	mov	QWORD PTR [rsp+8], rbx
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, r8
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	rdi, QWORD PTR [r9+r9]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2643 :                 const _Elem _Ch) {

	mov	rbx, rdx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	r8, rdi
	mov	rdx, rax
	mov	rcx, rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2643 :                 const _Elem _Ch) {

	mov	rsi, r9
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	call	memcpy

; 259  :         for (; 0 < _N; ++_Su, --_N)

	mov	r8, QWORD PTR _Count$[rsp]
	xor	edx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2645 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

	add	rdi, rbx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	test	r8, r8
	je	SHORT $LN12@operator

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	movzx	eax, dx
	mov	rcx, r8
	rep stosw
$LN12@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2646 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	lea	rax, QWORD PTR [rsi+r8]

; 2647 :             },

	mov	rsi, QWORD PTR [rsp+56]

; 211  :         _Left = _Right;

	mov	WORD PTR [rbx+rax*2], dx

; 2647 :             },

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_a3050a43f3157934f354774ab3dd2e02>@@QEBAXQEA_WQEB_W_K2_W@Z ENDP ; <lambda_a3050a43f3157934f354774ab3dd2e02>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEBV12@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEBV12@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_lv_contents, COMDAT

; 2434 :     void _Construct_lv_contents(const basic_string& _Right) {

$LN89:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 8

; 2434 :     void _Construct_lv_contents(const basic_string& _Right) {

	mov	rbx, rdx

; 2435 :         // assign by copying data stored in _Right
; 2436 :         // pre: this != &_Right
; 2437 :         // pre: *this owns no memory, iterators orphaned (note:
; 2438 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2439 :         auto& _My_data                = _Get_data();
; 2440 :         auto& _Right_data             = _Right._Get_data();
; 2441 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	rsi, QWORD PTR [rdx+16]
	mov	rdi, rcx

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN13@Construct_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rbx, QWORD PTR [rdx]
$LN13@Construct_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2443 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

	cmp	rsi, 8
	jae	SHORT $LN2@Construct_
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	vmovups	xmm0, XMMWORD PTR [rbx]
	vmovups	XMMWORD PTR [rcx], xmm0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2445 :             _My_data._Mysize = _Right_size;

	mov	QWORD PTR [rcx+16], rsi

; 2446 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 7

; 2457 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN2@Construct_:
	mov	QWORD PTR [rsp+80], rbp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	mov	rax, 9223372036854775806		; 7ffffffffffffffeH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	mov	rbp, rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	or	rbp, 7
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	mov	r8, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmp	rbp, rax
	cmova	rbp, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2452 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	lea	rax, QWORD PTR [rbp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 25   :     size_t _Result                 = _Count * _Ty_size;

	lea	rdx, QWORD PTR [rax+rax]

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	cmp	rax, rcx
	jbe	SHORT $LN46@Construct_

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);

	mov	rdx, r8

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	jmp	SHORT $LN84@Construct_
$LN46@Construct_:
	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN49@Construct_
$LN84@Construct_:

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	cmp	rcx, rdx
	cmovbe	rcx, r8

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN58@Construct_

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN48@Construct_
$LN58@Construct_:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN49@Construct_:

; 178  :     if (_Bytes != 0) {

	test	rdx, rdx
	je	SHORT $LN50@Construct_

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rdx
	call	??2@YAPEAX_K@Z				; operator new

; 179  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN48@Construct_
$LN50@Construct_:

; 180  :     }
; 181  : 
; 182  :     return nullptr;

	xor	eax, eax
$LN48@Construct_:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	lea	r8, QWORD PTR [rsi*2+2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	QWORD PTR [rdi], rax
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	rdx, rbx
	mov	rcx, rax
	call	memcpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2456 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rdi+24], rbp
	mov	rbp, QWORD PTR [rsp+80]
	mov	QWORD PTR [rdi+16], rsi

; 2457 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN86@Construct_:
?_Construct_lv_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEBV12@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$dead$ = 24
?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents, COMDAT

; 2390 :         // assign by stealing _Right's buffer, memcpy optimization
; 2391 :         // pre: this != &_Right
; 2392 :         // pre: allocator propagation (POCMA) from _Right, if necessary, is
; 2393 :         // complete pre: *this owns no memory, iterators orphaned (note:
; 2394 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2395 :         auto& _Right_data = _Right._Get_data();
; 2396 : 
; 2397 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2398 :         if (_Right_data._Large_string_engaged()) { // take ownership of _Right's iterators along with its buffer
; 2399 :             _Swap_proxy_and_iterators(_Right);
; 2400 :         } else {
; 2401 :             _Right._Orphan_all();
; 2402 :         }
; 2403 : #endif // _ITERATOR_DEBUG_LEVEL != 0
; 2404 : 
; 2405 :         const auto _My_data_mem = reinterpret_cast<unsigned char*>(_STD addressof(_Get_data())) + _Memcpy_move_offset;
; 2406 :         const auto _Right_data_mem =
; 2407 :             reinterpret_cast<unsigned char*>(_STD addressof(_Right_data)) + _Memcpy_move_offset;
; 2408 :         _CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

	vmovups	ymm0, YMMWORD PTR [rdx]
	vmovups	YMMWORD PTR [rcx], ymm0

; 3861 :         _My_data._Mysize = 0;

	xor	eax, eax

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdx+24], 7
	mov	QWORD PTR [rdx+16], rax

; 211  :         _Left = _Right;

	mov	WORD PTR [rdx], ax
	vzeroupper

; 2409 :         _Right._Tidy_init();
; 2410 :     }

	ret	0
?_Take_contents@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@QEAAXAEAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Take_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN14@data

; 3255 :         return _Get_data()._Myptr();

	mov	rax, QWORD PTR [rcx]

; 3256 :     }

	ret	0
$LN14@data:

; 3255 :         return _Get_data()._Myptr();

	mov	rax, rcx

; 3256 :     }

	ret	0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ
_TEXT	SEGMENT
this$ = 8
?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front, COMDAT

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN30@front

; 3230 :         return *begin();

	mov	rax, QWORD PTR [rcx]

; 3231 :     }

	ret	0
$LN30@front:

; 3230 :         return *begin();

	mov	rax, rcx

; 3231 :     }

	ret	0
?front@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::front
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$dead$ = 56
_Count$ = 64
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT

; 2853 :     basic_string& erase(const size_type _Off, size_type _Count) { // erase elements [_Off, _Off + _Count)

$LN26:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rax, r8
	mov	rbx, rcx

; 2036 :         if (_Mysize < _Off) {

	mov	r8, QWORD PTR [rcx+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmp	r8, rax
	cmovb	rax, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN16@erase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rcx, QWORD PTR [rcx]
$LN16@erase:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2860 :         const size_type _New_size = _Old_size - _Count;

	sub	r8, rax

; 2861 :         _My_data._Mysize          = _New_size;
; 2862 :         _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

	lea	rdx, QWORD PTR [rax+rcx]
	mov	QWORD PTR [rbx+16], r8
	inc	r8

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	call	memmove

; 2863 :         return *this;

	mov	rax, rbx

; 2864 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
_Ch$dead$ = 64
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 2707 :     basic_string& assign(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // assign _Count * _Ch

$LN137:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 2708 :         auto& _My_data = _Get_data();
; 2709 :         if (_Count <= _My_data._Myres) {

	mov	rsi, QWORD PTR [rcx+24]
	mov	rdi, rcx
	cmp	rsi, 32767				; 00007fffH
	jb	SHORT $LN2@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rbx, QWORD PTR [rcx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	xor	edx, edx

; 2710 :             _Elem* const _Old_ptr = _My_data._Myptr();
; 2711 :             _My_data._Mysize      = _Count;

	mov	QWORD PTR [rcx+16], 32767		; 00007fffH

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8d, 32767				; 00007fffH
	mov	rcx, rbx
	call	memset

; 2723 :     }

	mov	rax, rdi

; 343  :         _Left = _Right;

	mov	BYTE PTR [rbx+32767], 0

; 2723 :     }

	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@assign:
	mov	QWORD PTR [rsp+56], rbp

; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, rsi
	shr	rcx, 1
	mov	rbp, 9223372036854775807		; 7fffffffffffffffH
	mov	rax, rbp
	sub	rax, rcx
	cmp	rsi, rax
	ja	SHORT $LN42@assign

; 3775 :             return _Max;
; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rcx+rsi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	mov	ebp, 32767				; 00007fffH
	cmp	rax, rbp
	cmova	rbp, rax
$LN42@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, rbp
	mov	rdx, -1
	add	rax, 1
	cmovb	rax, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN75@assign

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	cmp	rcx, rax
	cmovbe	rcx, rdx

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN117@assign

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN74@assign
$LN75@assign:

; 175  :     }
; 176  : #endif // defined(_M_IX86) || defined(_M_X64)
; 177  : 
; 178  :     if (_Bytes != 0) {

	test	rax, rax
	je	SHORT $LN76@assign

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 179  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN74@assign
$LN76@assign:

; 180  :     }
; 181  : 
; 182  :     return nullptr;

	xor	ebx, ebx
$LN74@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	xor	edx, edx

; 3795 :         _My_data._Mysize = _New_size;

	mov	QWORD PTR [rdi+16], 32767		; 00007fffH

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8d, 32767				; 00007fffH

; 3796 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rdi+24], rbp

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	rcx, rbx
	call	memset

; 343  :         _Left = _Right;

	mov	BYTE PTR [rbx+32767], 0

; 3798 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	rsi, 16
	jb	SHORT $LN21@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3799 :             _Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	lea	rdx, QWORD PTR [rsi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN120@assign

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN117@assign

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN120@assign:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2717 :         return _Reallocate_for(_Count,

	mov	QWORD PTR [rdi], rbx

; 2723 :     }

	mov	rax, rdi
	mov	rbp, QWORD PTR [rsp+56]
	mov	rbx, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN117@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN133@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??R<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@QEBAXQEAD_KD@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Count$dead$ = 64
_Ch$dead$ = 72
??R<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@QEBAXQEAD_KD@Z PROC ; <lambda_138c3d7c38c85abb84c7fc7bfe5747b7>::operator(), COMDAT

; 2718 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {

$LN9:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8d, 32767				; 00007fffH
	mov	rcx, rbx
	xor	edx, edx
	call	memset

; 343  :         _Left = _Right;

	mov	BYTE PTR [rbx+32767], 0

; 2719 :                 _Traits::assign(_New_ptr, _Count, _Ch);
; 2720 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2721 :             },

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??R<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@QEBAXQEAD_KD@Z ENDP ; <lambda_138c3d7c38c85abb84c7fc7bfe5747b7>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 301  :         return __builtin_strlen(_First);

	mov	r8, -1
	npad	9
$LL7@assign:
	inc	r8
	cmp	BYTE PTR [rdx+r8], 0
	jne	SHORT $LL7@assign

; 2704 :         return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));

	jmp	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
this$ = 80
_Ptr$ = 88
_Count$ = 96
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 2684 :     basic_string& assign(_In_reads_(_Count) const _Elem* const _Ptr, _CRT_GUARDOVERFLOW const size_type _Count) {

$LN138:
	push	rbx
	push	rsi
	push	rdi
	push	r14
	push	r15
	sub	rsp, 32					; 00000020H

; 2685 :         // assign [_Ptr, _Ptr + _Count)
; 2686 :         auto& _My_data = _Get_data();
; 2687 :         if (_Count <= _My_data._Myres) {

	mov	r14, QWORD PTR [rcx+24]
	mov	rsi, r8
	mov	r15, rdx
	mov	rbx, rcx
	cmp	r8, r14
	ja	SHORT $LN2@assign

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	rdi, rcx

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	r14, 16

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rdi, QWORD PTR [rcx]
$LN9@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2689 :             _My_data._Mysize      = _Count;

	mov	QWORD PTR [rcx+16], rsi

; 333  :         return static_cast<char*>(_CSTD memmove(_First1, _First2, _Count));

	mov	rcx, rdi
	call	memmove

; 2696 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 2697 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2698 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2699 :             },
; 2700 :             _Ptr);
; 2701 :     }

	mov	rax, rbx

; 343  :         _Left = _Right;

	mov	BYTE PTR [rsi+rdi], 0

; 2696 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 2697 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2698 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2699 :             },
; 2700 :             _Ptr);
; 2701 :     }

	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN2@assign:

; 3785 :         if (_New_size > max_size()) {

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	cmp	rsi, rdi
	ja	$LN136@assign

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rcx, rsi
	or	rcx, 15
	cmp	rcx, rdi

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN42@assign

; 3770 :             return _Max;
; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rdx, r14
	mov	rax, rdi
	shr	rdx, 1
	sub	rax, rdx
	cmp	r14, rax
	ja	SHORT $LN42@assign

; 3775 :             return _Max;
; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rdx+r14]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	mov	rdi, rcx
	cmp	rcx, rax
	cmovb	rdi, rax
$LN42@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, rdi
	mov	QWORD PTR [rsp+104], rbp
	add	rax, 1
	mov	rdx, -1
	cmovb	rax, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN75@assign

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	cmp	rcx, rax
	cmovbe	rcx, rdx

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN117@assign

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbp, QWORD PTR [rax+39]
	and	rbp, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbp-8], rax

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN74@assign
$LN75@assign:

; 175  :     }
; 176  : #endif // defined(_M_IX86) || defined(_M_X64)
; 177  : 
; 178  :     if (_Bytes != 0) {

	test	rax, rax
	je	SHORT $LN76@assign

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbp, rax

; 179  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN74@assign
$LN76@assign:

; 180  :     }
; 181  : 
; 182  :     return nullptr;

	xor	ebp, ebp
$LN74@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	r8, rsi

; 3795 :         _My_data._Mysize = _New_size;

	mov	QWORD PTR [rbx+16], rsi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, r15

; 3796 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rbx+24], rdi

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rcx, rbp
	call	memcpy

; 343  :         _Left = _Right;

	mov	BYTE PTR [rsi+rbp], 0

; 3798 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	r14, 16
	jb	SHORT $LN21@assign
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rbx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3799 :             _Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	lea	rdx, QWORD PTR [r14+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN120@assign

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN117@assign

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN120@assign:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN21@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2695 :         return _Reallocate_for(_Count,

	mov	QWORD PTR [rbx], rbp

; 2696 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
; 2697 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2698 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2699 :             },
; 2700 :             _Ptr);
; 2701 :     }

	mov	rax, rbx
	mov	rbp, QWORD PTR [rsp+104]
	add	rsp, 32					; 00000020H
	pop	r15
	pop	r14
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN117@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN136@assign:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3786 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
	int	3
$LN133@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Count$ = 64
_Ptr$ = 72
??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z PROC ; <lambda_66f57f934f28d61049862f64df852ff0>::operator(), COMDAT

; 2696 :             [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {

$LN9:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rcx, rbx
	mov	rdx, r9
	call	memcpy

; 343  :         _Left = _Right;

	mov	BYTE PTR [rbx+rdi], 0

; 2697 :                 _Traits::copy(_New_ptr, _Ptr, _Count);
; 2698 :                 _Traits::assign(_New_ptr[_Count], _Elem());
; 2699 :             },

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBAXQEAD_KQEBD@Z ENDP ; <lambda_66f57f934f28d61049862f64df852ff0>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
_TEXT	SEGMENT
this$ = 64
_Count$ = 72
_Ch$dead$ = 80
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 2630 :     basic_string& append(_CRT_GUARDOVERFLOW const size_type _Count, const _Elem _Ch) { // append _Count * _Ch

$LN21:
	mov	QWORD PTR [rsp+16], rsi
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rdi, rcx
	mov	rsi, rdx

; 2631 :         auto& _My_data            = _Get_data();
; 2632 :         const size_type _Old_size = _My_data._Mysize;

	mov	rcx, QWORD PTR [rcx+16]

; 2633 :         if (_Count <= _My_data._Myres - _Old_size) {

	mov	rdx, QWORD PTR [rdi+24]
	mov	rax, rdx
	sub	rax, rcx
	cmp	rsi, rax
	ja	SHORT $LN2@append

; 2634 :             _My_data._Mysize      = _Old_size + _Count;

	mov	QWORD PTR [rsp+64], rbx
	lea	rax, QWORD PTR [rcx+rsi]
	mov	QWORD PTR [rdi+16], rax

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	rax, rdi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	rdx, 16

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN9@append
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rax, QWORD PTR [rdi]
$LN9@append:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2636 :             _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

	lea	rbx, QWORD PTR [rax+rcx]

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8, rsi
	mov	rcx, rbx
	xor	edx, edx
	call	memset

; 343  :         _Left = _Right;

	mov	BYTE PTR [rbx+rsi], 0

; 2637 :             _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
; 2638 :             return *this;

	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+64]

; 2642 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 2643 :                 const _Elem _Ch) {
; 2644 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2645 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2646 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2647 :             },
; 2648 :             _Count, _Ch);
; 2649 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
$LN2@append:

; 2639 :         }
; 2640 : 
; 2641 :         return _Reallocate_grow_by(_Count,

	mov	r9, rsi
	mov	rdx, rsi
	mov	rcx, rdi
	call	??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>

; 2642 :             [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count,
; 2643 :                 const _Elem _Ch) {
; 2644 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2645 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2646 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2647 :             },
; 2648 :             _Count, _Ch);
; 2649 :     }

	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBAXQEADQEBD_K2D@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Count$ = 80
_Ch$dead$ = 88
??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBAXQEADQEBD_K2D@Z PROC ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator(), COMDAT

; 2643 :                 const _Elem _Ch) {

$LN11:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rax, r8
	mov	rbx, rdx

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, rax
	mov	rcx, rbx
	mov	r8, r9

; 2643 :                 const _Elem _Ch) {

	mov	rdi, r9

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	call	memcpy

; 2644 :                 _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2645 :                 _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

	add	rdi, rbx

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	xor	edx, edx
	mov	rbx, QWORD PTR _Count$[rsp]
	mov	rcx, rdi
	mov	r8, rbx
	call	memset

; 343  :         _Left = _Right;

	mov	BYTE PTR [rdi+rbx], 0

; 2646 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2647 :             },

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBAXQEADQEBD_K2D@Z ENDP ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT

; 2434 :     void _Construct_lv_contents(const basic_string& _Right) {

$LN83:
	push	rbx
	push	rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 2434 :     void _Construct_lv_contents(const basic_string& _Right) {

	mov	rbx, rdx

; 2435 :         // assign by copying data stored in _Right
; 2436 :         // pre: this != &_Right
; 2437 :         // pre: *this owns no memory, iterators orphaned (note:
; 2438 :         // _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2439 :         auto& _My_data                = _Get_data();
; 2440 :         auto& _Right_data             = _Right._Get_data();
; 2441 :         const size_type _Right_size   = _Right_data._Mysize;

	mov	rsi, QWORD PTR [rdx+16]
	mov	rdi, rcx

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN13@Construct_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rbx, QWORD PTR [rdx]
$LN13@Construct_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2443 :         if (_Right_size < _BUF_SIZE) { // stay small, don't allocate

	cmp	rsi, 16
	jae	SHORT $LN2@Construct_

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	vmovups	xmm0, XMMWORD PTR [rbx]
	vmovups	XMMWORD PTR [rcx], xmm0

; 2444 :             _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);
; 2445 :             _My_data._Mysize = _Right_size;

	mov	QWORD PTR [rcx+16], rsi

; 2446 :             _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 2457 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN2@Construct_:
	mov	QWORD PTR [rsp+80], rbp
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	mov	rax, 9223372036854775807		; 7fffffffffffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2451 :         const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());

	mov	rbp, rsi
	or	rbp, 15
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmp	rbp, rax
	cmova	rbp, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2452 :         const pointer _New_array      = _Al.allocate(_New_capacity + 1); // throws

	lea	rax, QWORD PTR [rbp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN46@Construct_

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	mov	rdx, -1
	cmp	rcx, rax
	cmovbe	rcx, rdx

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN55@Construct_

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN45@Construct_
$LN55@Construct_:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN46@Construct_:

; 178  :     if (_Bytes != 0) {

	test	rax, rax
	je	SHORT $LN45@Construct_

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
$LN45@Construct_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2454 :         _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

	lea	r8, QWORD PTR [rsi+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	QWORD PTR [rdi], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, rbx
	mov	rcx, rax
	call	memcpy

; 2455 :         _My_data._Mysize = _Right_size;
; 2456 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rdi+24], rbp
	mov	rbp, QWORD PTR [rsp+80]
	mov	QWORD PTR [rdi+16], rsi

; 2457 :     }

	add	rsp, 32					; 00000020H
	pop	rdi
	pop	rsi
	pop	rbx
	ret	0
$LN80@Construct_:
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z PROC	; std::_WChar_traits<wchar_t>::assign, COMDAT

; 211  :         _Left = _Right;

	movzx	eax, WORD PTR [rdx]
	mov	WORD PTR [rcx], ax

; 212  :     }

	ret	0
?assign@?$_WChar_traits@_W@std@@SAXAEA_WAEB_W@Z ENDP	; std::_WChar_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?copy@?$_WChar_traits@_W@std@@SAPEA_WQEA_WQEB_W_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$_WChar_traits@_W@std@@SAPEA_WQEA_WQEB_W_K@Z PROC ; std::_WChar_traits<wchar_t>::copy, COMDAT

; 169  :         const size_t _Count) noexcept { // strengthened

$LN7:
	push	rbx
	sub	rsp, 32					; 00000020H
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	add	r8, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 169  :         const size_t _Count) noexcept { // strengthened

	mov	rbx, rcx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	call	memcpy
	mov	rax, rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 173  :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?copy@?$_WChar_traits@_W@std@@SAPEA_WQEA_WQEB_W_K@Z ENDP ; std::_WChar_traits<wchar_t>::copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z
_TEXT	SEGMENT
$T1 = 32
$T9 = 40
this$GSCopy$ = 48
$T5 = 64
$T2 = 80
_Nr$10 = 80
_Pb$11 = 88
_Pn$12 = 96
__$ArrayPad$ = 104
this$ = 144
_Filename$ = 152
_Mode$dead$ = 160
_Prot$dead$ = 168
$initVBases$dead$ = 176
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >, COMDAT

; 767  :     explicit basic_ifstream(const char* _Filename, ios_base::openmode _Mode = ios_base::in,

$LN62:
	push	rbp
	push	rsi
	push	rdi
	sub	rsp, 112				; 00000070H
	mov	QWORD PTR $T9[rsp], -2
	mov	QWORD PTR [rsp+160], rbx
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rbx, rdx
	mov	rsi, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
	xor	ebp, ebp
	mov	DWORD PTR $T1[rsp], ebp

; 768  :         int _Prot = (int) ios_base::_Openprot)
; 769  :         : _Mybase(&_Filebuffer) { // construct with named file and specified mode

	lea	rax, OFFSET FLAT:??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
	mov	QWORD PTR [rcx], rax
	add	rcx, 176				; 000000b0H
	call	QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	mov	DWORD PTR $T1[rsp], 1
	lea	rdi, QWORD PTR [rsi+16]
	xor	r9d, r9d
	xor	r8d, r8d
	mov	rdx, rdi
	mov	rcx, rsi
	call	QWORD PTR __imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
	npad	1
	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rcx+rsi], rax
	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	lea	edx, DWORD PTR [rcx-176]
	mov	DWORD PTR [rcx+rsi-4], edx
	mov	QWORD PTR $T2[rsp], rdi

; 146  :     basic_filebuf(FILE* _File = nullptr) : _Mysb() { // construct from pointer to C stream

	mov	rcx, rdi
	call	QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	lea	rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rdi], rax

; 657  :         _Closef    = _Which == _Openfl;

	mov	BYTE PTR [rdi+124], bpl

; 658  :         _Wrotesome = false;

	mov	BYTE PTR [rdi+113], bpl

; 659  : 
; 660  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	rcx, rdi
	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 674  :         _Myfile = _File;

	mov	QWORD PTR [rdi+128], rbp

; 675  :         _State  = _Stinit;

	mov	rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
	mov	QWORD PTR [rdi+116], rax

; 676  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	QWORD PTR [rdi+104], rbp

; 260  :         if (_Myfile != nullptr || (_File = _Fiopen(_Filename, _Mode, _Prot)) == nullptr) {

	lea	edx, QWORD PTR [rbp+33]
	lea	r8d, QWORD PTR [rbp+64]
	mov	rcx, rbx
	call	QWORD PTR __imp_?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z
	mov	rbx, rax
	test	rax, rax
	je	$LN56@basic_ifst

; 657  :         _Closef    = _Which == _Openfl;

	mov	BYTE PTR [rdi+124], 1

; 658  :         _Wrotesome = false;

	mov	BYTE PTR [rdi+113], bpl

; 659  : 
; 660  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	rcx, rdi
	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 661  : 
; 662  :         if (_File != nullptr && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 663  :             _Elem** _Pb = nullptr;

	mov	QWORD PTR _Pb$11[rsp], rbp

; 664  :             _Elem** _Pn = nullptr;

	mov	QWORD PTR _Pn$12[rsp], rbp

; 665  :             int* _Nr    = nullptr;

	mov	QWORD PTR _Nr$10[rsp], rbp

; 666  : 
; 667  :             ::_get_stream_buffer_pointers(

	lea	r9, QWORD PTR _Nr$10[rsp]
	lea	r8, QWORD PTR _Pn$12[rsp]
	lea	rdx, QWORD PTR _Pb$11[rsp]
	mov	rcx, rbx
	call	QWORD PTR __imp__get_stream_buffer_pointers
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 272  :         _IGfirst = _Gf;

	mov	rax, QWORD PTR _Pb$11[rsp]
	mov	QWORD PTR [rdi+24], rax

; 273  :         _IPfirst = _Pf;

	mov	QWORD PTR [rdi+32], rax

; 274  :         _IGnext  = _Gn;

	mov	rax, QWORD PTR _Pn$12[rsp]
	mov	QWORD PTR [rdi+56], rax

; 275  :         _IPnext  = _Pn;

	mov	QWORD PTR [rdi+64], rax

; 276  :         _IGcount = _Gc;

	mov	rax, QWORD PTR _Nr$10[rsp]
	mov	QWORD PTR [rdi+80], rax

; 277  :         _IPcount = _Pc;

	mov	QWORD PTR [rdi+88], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 674  :         _Myfile = _File;

	mov	QWORD PTR [rdi+128], rbx

; 675  :         _State  = _Stinit;

	mov	rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
	mov	QWORD PTR [rdi+116], rax

; 676  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	QWORD PTR [rdi+104], rbp

; 265  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

	lea	rdx, QWORD PTR $T5[rsp]
	mov	rcx, rdi
	call	QWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ
	npad	1
	mov	rcx, rax
	call	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
	mov	rbx, rax

; 716  :         if (_Newcvt.always_noconv()) {

	mov	rcx, rax
	call	QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
	test	al, al
	je	SHORT $LN40@basic_ifst

; 717  :             _Pcvt = nullptr; // nothing to do

	mov	QWORD PTR [rdi+104], rbp

; 718  :         } else { // set up for nontrivial codecvt facet

	jmp	SHORT $LN41@basic_ifst
$LN40@basic_ifst:

; 719  :             _Pcvt = _STD addressof(_Newcvt);

	mov	QWORD PTR [rdi+104], rbx

; 720  :             _Mysb::_Init(); // reset any buffering

	mov	rcx, rdi
	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
	npad	1
$LN41@basic_ifst:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	mov	rcx, QWORD PTR $T5[rsp+8]
	test	rcx, rcx
	je	SHORT $LN59@basic_ifst

; 360  :             delete _Ptr->_Decref();

	mov	r8, QWORD PTR [rcx]
	call	QWORD PTR [r8+16]
	test	rax, rax
	je	SHORT $LN59@basic_ifst
	mov	rcx, QWORD PTR [rax]
	mov	r8, QWORD PTR [rcx]
	mov	edx, 1
	mov	rcx, rax
	call	r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 266  :         return this; // open succeeded

	jmp	SHORT $LN59@basic_ifst
$LN56@basic_ifst:

; 770  :         if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == nullptr) {
; 771  :             _Myios::setstate(ios_base::failbit);

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	xor	r8d, r8d
	lea	edx, QWORD PTR [r8+2]
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
$LN59@basic_ifst:

; 772  :         }
; 773  :     }

	mov	rax, rsi
	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+160]
	add	rsp, 112				; 00000070H
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T9 = 40
this$GSCopy$ = 48
$T5 = 64
$T2 = 80
_Nr$10 = 80
_Pb$11 = 88
_Pn$12 = 96
__$ArrayPad$ = 104
this$ = 144
_Filename$ = 152
_Mode$dead$ = 160
_Prot$dead$ = 168
$initVBases$dead$ = 176
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR this$GSCopy$[rbp]
	add	rcx, 176				; 000000b0H
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN6@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
$T1 = 32
$T9 = 40
this$GSCopy$ = 48
$T5 = 64
$T2 = 80
_Nr$10 = 80
_Pb$11 = 88
_Pn$12 = 96
__$ArrayPad$ = 104
this$ = 144
_Filename$ = 152
_Mode$dead$ = 160
_Prot$dead$ = 168
$initVBases$dead$ = 176
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 24
	rex_jmp	QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
$T1 = 32
$T9 = 40
this$GSCopy$ = 48
$T5 = 64
$T2 = 80
_Nr$10 = 80
_Pb$11 = 88
_Pn$12 = 96
__$ArrayPad$ = 104
this$ = 144
_Filename$ = 152
_Mode$dead$ = 160
_Prot$dead$ = 168
$initVBases$dead$ = 176
?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$3
	mov	rcx, QWORD PTR $T2[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$3
$T1 = 32
$T9 = 40
this$GSCopy$ = 48
$T5 = 64
$T2 = 80
_Nr$10 = 80
_Pb$11 = 88
_Pn$12 = 96
__$ArrayPad$ = 104
this$ = 144
_Filename$ = 152
_Mode$dead$ = 160
_Prot$dead$ = 168
$initVBases$dead$ = 176
?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 16
	jmp	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$2
$T1 = 32
$T9 = 40
this$GSCopy$ = 48
$T5 = 64
$T2 = 80
_Nr$10 = 80
_Pb$11 = 88
_Pn$12 = 96
__$ArrayPad$ = 104
this$ = 144
_Filename$ = 152
_Mode$dead$ = 160
_Prot$dead$ = 168
$initVBases$dead$ = 176
?dtor$4@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$4
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1locale@std@@QEAA@XZ			; std::locale::~locale
?dtor$4@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T9 = 40
this$GSCopy$ = 48
$T5 = 64
$T2 = 80
_Nr$10 = 80
_Pb$11 = 88
_Pn$12 = 96
__$ArrayPad$ = 104
this$ = 144
_Filename$ = 152
_Mode$dead$ = 160
_Prot$dead$ = 168
$initVBases$dead$ = 176
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR this$GSCopy$[rbp]
	add	rcx, 176				; 000000b0H
	call	QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN6@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T9 = 40
this$GSCopy$ = 48
$T5 = 64
$T2 = 80
_Nr$10 = 80
_Pb$11 = 88
_Pn$12 = 96
__$ArrayPad$ = 104
this$ = 144
_Filename$ = 152
_Mode$dead$ = 160
_Prot$dead$ = 168
$initVBases$dead$ = 176
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 24
	rex_jmp	QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T9 = 40
this$GSCopy$ = 48
$T5 = 64
$T2 = 80
_Nr$10 = 80
_Pb$11 = 88
_Pn$12 = 96
__$ArrayPad$ = 104
this$ = 144
_Filename$ = 152
_Mode$dead$ = 160
_Prot$dead$ = 168
$initVBases$dead$ = 176
?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$3
	mov	rcx, QWORD PTR $T2[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T9 = 40
this$GSCopy$ = 48
$T5 = 64
$T2 = 80
_Nr$10 = 80
_Pb$11 = 88
_Pn$12 = 96
__$ArrayPad$ = 104
this$ = 144
_Filename$ = 152
_Mode$dead$ = 160
_Prot$dead$ = 168
$initVBases$dead$ = 176
?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$2
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	add	rcx, 16
	jmp	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
?dtor$2@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T9 = 40
this$GSCopy$ = 48
$T5 = 64
$T2 = 80
_Nr$10 = 80
_Pb$11 = 88
_Pn$12 = 96
__$ArrayPad$ = 104
this$ = 144
_Filename$ = 152
_Mode$dead$ = 160
_Prot$dead$ = 168
$initVBases$dead$ = 176
?dtor$4@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$4
	lea	rcx, QWORD PTR $T5[rdx]
	jmp	??1locale@std@@QEAA@XZ			; std::locale::~locale
?dtor$4@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@PEBDHH@Z@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back, COMDAT

; 738  :     void _Set_back() { // set up putback area

	mov	r8, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 179  :         return *_IGfirst;

	mov	rcx, QWORD PTR [rcx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 739  :         if (_Mysb::eback() != &_Mychar) { // save current get buffer

	mov	rax, QWORD PTR [rcx]
	lea	r9, QWORD PTR [r8+112]
	cmp	rax, r9
	je	SHORT $LN13@Set_back

; 740  :             _Set_eback = _Mysb::eback();

	mov	QWORD PTR [r8+136], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 195  :         return *_IGnext + *_IGcount;

	mov	rax, QWORD PTR [r8+80]
	movsxd	rdx, DWORD PTR [rax]
	mov	rax, QWORD PTR [r8+56]
	add	rdx, QWORD PTR [rax]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 741  :             _Set_egptr = _Mysb::egptr();

	mov	QWORD PTR [r8+144], rdx
$LN13@Set_back:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 204  :         *_IGfirst = _First;

	mov	QWORD PTR [rcx], r9

; 205  :         *_IGnext  = _Next;
; 206  :         *_IGcount = (int) (_Last - _Next);

	mov	ecx, r8d
	mov	rax, QWORD PTR [r8+56]
	sub	ecx, r9d
	add	ecx, 113				; 00000071H
	mov	QWORD PTR [rax], r9
	mov	rax, QWORD PTR [r8+80]
	mov	DWORD PTR [rax], ecx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 744  :     }

	ret	0
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 179  :         return *_IGfirst;

	mov	r9, QWORD PTR [rcx+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 733  :         if (_Mysb::eback() == &_Mychar) {

	lea	rax, QWORD PTR [rcx+112]
	cmp	QWORD PTR [r9], rax
	jne	SHORT $LN2@Reset_back

; 734  :             _Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

	mov	rdx, QWORD PTR [rcx+136]
	mov	r8, QWORD PTR [rcx+144]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 204  :         *_IGfirst = _First;

	mov	QWORD PTR [r9], rdx

; 205  :         *_IGnext  = _Next;
; 206  :         *_IGcount = (int) (_Last - _Next);

	sub	r8d, edx
	mov	rax, QWORD PTR [rcx+56]
	mov	QWORD PTR [rax], rdx
	mov	rax, QWORD PTR [rcx+80]
	mov	DWORD PTR [rax], r8d
$LN2@Reset_back:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 736  :     }

	ret	0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Newcvt$ = 56
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT

; 715  :     void _Initcvt(const _Cvt& _Newcvt) { // initialize codecvt pointer

$LN15:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rdi, rdx

; 716  :         if (_Newcvt.always_noconv()) {

	mov	rcx, rdx
	call	QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
	test	al, al
	je	SHORT $LN2@Initcvt

; 717  :             _Pcvt = nullptr; // nothing to do

	mov	QWORD PTR [rbx+104], 0

; 721  :         }
; 722  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN2@Initcvt:

; 718  :         } else { // set up for nontrivial codecvt facet
; 719  :             _Pcvt = _STD addressof(_Newcvt);
; 720  :             _Mysb::_Init(); // reset any buffering

	mov	rcx, rbx
	mov	QWORD PTR [rbx+104], rdi

; 721  :         }
; 722  :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi

; 718  :         } else { // set up for nontrivial codecvt facet
; 719  :             _Pcvt = _STD addressof(_Newcvt);
; 720  :             _Mysb::_Init(); // reset any buffering

	rex_jmp	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXAEBV?$codecvt@DDU_Mbstatet@@@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
_TEXT	SEGMENT
_Dest$ = 48
_Str$ = 56
__$ArrayPad$ = 88
this$ = 112
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT

; 679  :     bool _Endwrite() { // put shift to initial conversion state, as needed

$LN23:
	push	rbx
	sub	rsp, 96					; 00000060H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 680  :         if (_Pcvt == nullptr || !_Wrotesome) {

	cmp	QWORD PTR [rcx+104], 0
	mov	rbx, rcx
	je	$LN5@Endwrite
	cmp	BYTE PTR [rcx+113], 0
	je	$LN5@Endwrite

; 685  :         if (_Traits::eq_int_type(_Traits::eof(), overflow())) {

	mov	rax, QWORD PTR [rcx]
	mov	edx, -1
	mov	QWORD PTR [rsp+120], rdi
	call	QWORD PTR [rax+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 366  :         return _Left == _Right;

	cmp	eax, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 685  :         if (_Traits::eq_int_type(_Traits::eof(), overflow())) {

	je	$LN19@Endwrite

; 686  :             return false;
; 687  :         }
; 688  : 
; 689  :         constexpr size_t _Codecvt_temp_buf = 32;
; 690  :         char _Str[_Codecvt_temp_buf];
; 691  :         char* _Dest;
; 692  :         switch (_Pcvt->unshift(_State, _Str, _Str + _Codecvt_temp_buf, _Dest)) { // test result of homing conversion

	mov	rcx, QWORD PTR [rbx+104]
	lea	rax, QWORD PTR _Dest$[rsp]
	lea	rdx, QWORD PTR [rbx+116]
	mov	QWORD PTR [rsp+32], rax
	lea	r9, QWORD PTR _Str$[rsp+32]
	lea	r8, QWORD PTR _Str$[rsp]
	call	QWORD PTR __imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEAD1AEAPEAD@Z
	test	eax, eax
	je	SHORT $LN7@Endwrite
	sub	eax, 1
	je	SHORT $LN8@Endwrite
	cmp	eax, 2
	jne	SHORT $LN19@Endwrite

; 704  :         }
; 705  : 
; 706  :         case codecvt_base::noconv:
; 707  :             _Wrotesome = false; // homed successfully

	mov	BYTE PTR [rbx+113], 0

; 708  :             return true; // nothing else to do

	mov	al, 1
$LN20@Endwrite:
	mov	rdi, QWORD PTR [rsp+120]

; 709  : 
; 710  :         default:
; 711  :             return false; // conversion failed
; 712  :         }
; 713  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	rbx
	ret	0
$LN7@Endwrite:

; 693  :         case codecvt_base::ok:
; 694  :             _Wrotesome = false; // homed successfully

	mov	BYTE PTR [rbx+113], 0
$LN8@Endwrite:

; 695  : 
; 696  :         case codecvt_base::partial: // fall through
; 697  :         { // put any generated bytes
; 698  :             const auto _Count = static_cast<size_t>(_Dest - _Str);

	mov	rdi, QWORD PTR _Dest$[rsp]
	lea	rax, QWORD PTR _Str$[rsp]
	sub	rdi, rax

; 699  :             if (0 < _Count && _Count != static_cast<size_t>(_CSTD fwrite(_Str, 1, _Count, _Myfile))) {

	je	SHORT $LN9@Endwrite
	mov	r9, QWORD PTR [rbx+128]
	lea	rcx, QWORD PTR _Str$[rsp]
	mov	r8, rdi
	mov	edx, 1
	call	QWORD PTR __imp_fwrite
	cmp	rdi, rax
	jne	SHORT $LN19@Endwrite
$LN9@Endwrite:

; 701  :             }
; 702  : 
; 703  :             return !_Wrotesome;

	cmp	BYTE PTR [rbx+113], 0
	sete	al
	jmp	SHORT $LN20@Endwrite
$LN19@Endwrite:

; 700  :                 return false; // write failed

	xor	al, al
	jmp	SHORT $LN20@Endwrite
$LN5@Endwrite:

; 681  :             return true;

	mov	al, 1

; 709  : 
; 710  :         default:
; 711  :             return false; // conversion failed
; 712  :         }
; 713  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 96					; 00000060H
	pop	rbx
	ret	0
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
_Pb$1 = 32
_Pn$2 = 40
_Nr$3 = 48
__$ArrayPad$ = 56
this$ = 80
_File$ = 88
_Which$ = 96
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT

; 654  :     void _Init(FILE* _File, _Initfl _Which) { // initialize to C stream _File after {new, open, close}

$LN13:
	mov	QWORD PTR [rsp+24], rbx
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 64					; 00000040H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax

; 655  :         __PURE_APPDOMAIN_GLOBAL static _Myst _Stinit; // initial state
; 656  : 
; 657  :         _Closef    = _Which == _Openfl;

	cmp	r8d, 1

; 658  :         _Wrotesome = false;

	mov	BYTE PTR [rcx+113], 0
	mov	rdi, rdx
	mov	rbx, rcx
	sete	al
	mov	BYTE PTR [rcx+124], al

; 659  : 
; 660  :         _Mysb::_Init(); // initialize stream buffer base object

	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 661  : 
; 662  :         if (_File != nullptr && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer

	xor	esi, esi
	test	rdi, rdi
	je	SHORT $LN2@Init

; 663  :             _Elem** _Pb = nullptr;
; 664  :             _Elem** _Pn = nullptr;
; 665  :             int* _Nr    = nullptr;
; 666  : 
; 667  :             ::_get_stream_buffer_pointers(

	lea	r9, QWORD PTR _Nr$3[rsp]
	mov	QWORD PTR _Pb$1[rsp], rsi
	lea	r8, QWORD PTR _Pn$2[rsp]
	mov	QWORD PTR _Pn$2[rsp], rsi
	lea	rdx, QWORD PTR _Pb$1[rsp]
	mov	QWORD PTR _Nr$3[rsp], rsi
	mov	rcx, rdi
	call	QWORD PTR __imp__get_stream_buffer_pointers
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 272  :         _IGfirst = _Gf;

	mov	rax, QWORD PTR _Pb$1[rsp]
	mov	QWORD PTR [rbx+24], rax

; 273  :         _IPfirst = _Pf;

	mov	QWORD PTR [rbx+32], rax

; 274  :         _IGnext  = _Gn;

	mov	rax, QWORD PTR _Pn$2[rsp]
	mov	QWORD PTR [rbx+56], rax

; 275  :         _IPnext  = _Pn;

	mov	QWORD PTR [rbx+64], rax

; 276  :         _IGcount = _Gc;

	mov	rax, QWORD PTR _Nr$3[rsp]
	mov	QWORD PTR [rbx+80], rax

; 277  :         _IPcount = _Pc;

	mov	QWORD PTR [rbx+88], rax
$LN2@Init:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 675  :         _State  = _Stinit;

	mov	rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
	mov	QWORD PTR [rbx+116], rax
	mov	QWORD PTR [rbx+128], rdi

; 676  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	QWORD PTR [rbx+104], rsi

; 677  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+96]
	mov	rsi, QWORD PTR [rsp+104]
	add	rsp, 64					; 00000040H
	pop	rdi
	ret	0
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
_TEXT	SEGMENT
this$ = 48
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT

; 344  :     basic_filebuf* close() { // close the C stream

$LN19:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 345  :         basic_filebuf* _Ans = this;
; 346  :         if (_Myfile == nullptr) {

	cmp	QWORD PTR [rcx+128], 0
	mov	rbx, rcx
	jne	SHORT $LN2@close

; 347  :             _Ans = nullptr;

	xor	edi, edi
	mov	esi, edi

; 348  :         } else { // put any homing sequence and close file

	jmp	SHORT $LN5@close
$LN2@close:

; 349  :             if (!_Endwrite()) {

	call	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 350  :                 _Ans = nullptr;
; 351  :             }
; 352  : 
; 353  :             if (_CSTD fclose(_Myfile) != 0) {

	mov	rcx, QWORD PTR [rbx+128]
	xor	edi, edi
	test	al, al
	mov	rsi, rbx
	cmove	rsi, rdi
	call	QWORD PTR __imp_fclose
	test	eax, eax
	cmovne	rsi, rdi
$LN5@close:

; 660  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	rcx, rbx
	mov	BYTE PTR [rbx+124], 0
	mov	BYTE PTR [rbx+113], 0
	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 661  : 
; 662  :         if (_File != nullptr && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 663  :             _Elem** _Pb = nullptr;
; 664  :             _Elem** _Pn = nullptr;
; 665  :             int* _Nr    = nullptr;
; 666  : 
; 667  :             ::_get_stream_buffer_pointers(
; 668  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 669  :             int* _Nw = _Nr;
; 670  : 
; 671  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 672  :         }
; 673  : 
; 674  :         _Myfile = _File;
; 675  :         _State  = _Stinit;

	mov	rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit

; 354  :                 _Ans = nullptr;
; 355  :             }
; 356  :         }
; 357  :         _Init(nullptr, _Closefl);
; 358  :         return _Ans;

	mov	rax, rsi

; 359  :     }

	mov	rsi, QWORD PTR [rsp+64]

; 675  :         _State  = _Stinit;

	mov	QWORD PTR [rbx+116], rcx
	mov	QWORD PTR [rbx+128], rdi

; 676  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	QWORD PTR [rbx+104], rdi

; 359  :     }

	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT

; 67   :                                  // TRANSITION, ABI: We currently always set _Fpos to 0 but older .objs containing old
; 68   :                                  // basic_filebuf would set _Fpos.
; 69   :         return _Myoff + _Fpos;

	mov	rax, QWORD PTR [rcx+8]
	add	rax, QWORD PTR [rcx]

; 70   :     }

	ret	0
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\iosfwd
;	COMDAT ?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ PROC ; std::fpos<_Mbstatet>::state, COMDAT

; 59   :         return _Mystate;

	mov	rax, QWORD PTR [rcx+16]
	mov	QWORD PTR [rdx], rax
	mov	rax, rdx

; 60   :     }

	ret	0
?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ ENDP ; std::fpos<_Mbstatet>::state
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z
_TEXT	SEGMENT
this$ = 8
_State$ = 16
_Fileposition$ = 24
??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z PROC	; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 55   :         : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State) { // construct with conversion state and C file position

	mov	QWORD PTR [rcx], r8

; 56   :     }

	mov	rax, rcx
	mov	QWORD PTR [rcx+8], 0
	mov	QWORD PTR [rcx+16], rdx
	ret	0
??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ENDP	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 51   :     /* implicit */ fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate() { // construct with stream offset

	xor	eax, eax
	mov	QWORD PTR [rcx], -1
	mov	QWORD PTR [rcx+8], 0
	mov	QWORD PTR [rcx+16], rax

; 52   :     }

	mov	rax, rcx
	ret	0
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Get_data@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::vector<char,std::allocator<char> >::_Get_data, COMDAT

; 1597 :         return _Mypair._Get_second();

	mov	rax, rcx

; 1598 :     }

	ret	0
?_Get_data@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::vector<char,std::allocator<char> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$allocator@D@2@XZ PROC ; std::vector<char,std::allocator<char> >::_Getal, COMDAT

; 1589 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1590 :     }

	ret	0
?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAV?$allocator@D@2@XZ ENDP ; std::vector<char,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Orphan_all@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ PROC ; std::vector<char,std::allocator<char> >::_Orphan_all, COMDAT

; 1581 :         _Get_data()._Orphan_all();
; 1582 :     }

	ret	0
?_Orphan_all@?$vector@DV?$allocator@D@std@@@std@@AEAAXXZ ENDP ; std::vector<char,std::allocator<char> >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Destroy@?$vector@DV?$allocator@D@std@@@std@@AEAAXPEAD0@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$dead$ = 16
_Last$dead$ = 24
?_Destroy@?$vector@DV?$allocator@D@std@@@std@@AEAAXPEAD0@Z PROC ; std::vector<char,std::allocator<char> >::_Destroy, COMDAT

; 1468 :         _Destroy_range(_First, _Last, _Getal());
; 1469 :     }

	ret	0
?_Destroy@?$vector@DV?$allocator@D@std@@@std@@AEAAXPEAD0@Z ENDP ; std::vector<char,std::allocator<char> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myend@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBQEANXZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBQEANXZ PROC ; std::vector<double,std::allocator<double> >::_Myend, COMDAT

; 1635 :         return _Get_data()._Myend;

	lea	rax, QWORD PTR [rcx+16]

; 1636 :     }

	ret	0
?_Myend@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBQEANXZ ENDP ; std::vector<double,std::allocator<double> >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Mylast@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBQEANXZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBQEANXZ PROC ; std::vector<double,std::allocator<double> >::_Mylast, COMDAT

; 1627 :         return _Get_data()._Mylast;

	lea	rax, QWORD PTR [rcx+8]

; 1628 :     }

	ret	0
?_Mylast@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBQEANXZ ENDP ; std::vector<double,std::allocator<double> >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T3 = 32
this$ = 64
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 75   :         __CLR_OR_THIS_CALL ~_Sentry_base() noexcept { // destroy after unlocking

$LN10:
	sub	rsp, 56					; 00000038H
	mov	QWORD PTR $T3[rsp], -2

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	rdx, QWORD PTR [rcx]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [rcx+rdx+72]
	test	rcx, rcx
	je	SHORT $LN2@Sentry_bas

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN2@Sentry_bas:

; 78   :             }
; 79   :         }

	add	rsp, 56					; 00000038H
	ret	0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Ostr$ = 56
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

$LN10:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	QWORD PTR [rcx], rdx
	mov	rbx, rcx

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	mov	rax, QWORD PTR [rdx]
	movsxd	r8, DWORD PTR [rax+4]
	mov	rcx, QWORD PTR [r8+rdx+72]
	test	rcx, rcx
	je	SHORT $LN8@Sentry_bas

; 71   :                 _Myostr.rdbuf()->_Lock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+8]
$LN8@Sentry_bas:

; 72   :             }
; 73   :         }

	mov	rax, rbx
	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT

; 1549 :         return _Myval2;

	mov	rax, rcx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second, COMDAT

; 1545 :         return _Myval2;

	mov	rax, rcx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@_W@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 1541 :         return *this;

	mov	rax, rcx

; 1542 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEBAAEBV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first, COMDAT

; 1537 :         return *this;

	mov	rax, rcx

; 1538 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAAAEAV?$allocator@_W@2@XZ ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ
_TEXT	SEGMENT
this$ = 8
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT

; 1712 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1713 :         _STL_VERIFY(_Ptr, "cannot dereference value-initialized string iterator");
; 1714 :         const auto _Mycont = static_cast<const _Mystr*>(this->_Getcont());
; 1715 :         _STL_VERIFY(_Mycont, "cannot dereference string iterator because the iterator was"
; 1716 :                              " invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1717 :         const auto _Contptr = _Mycont->_Myptr();
; 1718 :         const auto _Rawptr  = _Unfancy(_Ptr);
; 1719 :         _STL_VERIFY(_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize,
; 1720 :             "cannot dereference string iterator because it is out of range (e.g. an end iterator)");
; 1721 : #endif // _ITERATOR_DEBUG_LEVEL >= 1
; 1722 : 
; 1723 :         _Analysis_assume_(_Ptr);
; 1724 :         return *_Ptr;

	mov	rax, QWORD PTR [rcx]

; 1725 :     }

	ret	0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pstring$dead$ = 24
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1707 :         : _Ptr(_Parg) { // construct with pointer _Parg

	mov	QWORD PTR [rcx], rdx

; 1708 :         this->_Adopt(_Pstring);
; 1709 :     }

	mov	rax, rcx
	ret	0
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
_Size$ = 24
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 21   :     return _Right < _Left ? _Right : _Left;

	cmp	QWORD PTR [rcx+16], r8
	cmovb	r8, QWORD PTR [rcx+16]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2053 :         return _Min_value(_Size, _Mysize - _Off);

	mov	rax, r8

; 2054 :     }

	ret	0
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z
_TEXT	SEGMENT
_First$ = 16
_Count$ = 24
_Ch$dead$ = 32
?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z PROC	; std::_WChar_traits<wchar_t>::assign, COMDAT

; 205  :         _Out_writes_all_(_Count) _Elem* const _First, size_t _Count, _Elem _Ch) noexcept { // strengthened

$LN15:
	sub	rsp, 8
	mov	r8, rcx
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 259  :         for (; 0 < _N; ++_Su, --_N)

	test	rdx, rdx
	je	SHORT $LN12@assign

; 258  :         wchar_t *_Su = _S;

	mov	QWORD PTR [rsp], rdi
	xor	eax, eax
	mov	rdi, rcx
	movzx	eax, ax
	mov	rcx, rdx
	rep stosw
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 207  :         return reinterpret_cast<_Elem*>(_CSTD wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));

	mov	rdi, QWORD PTR [rsp]
$LN12@assign:

; 208  :     }

	mov	rax, r8
	add	rsp, 8
	ret	0
?assign@?$_WChar_traits@_W@std@@SAPEA_WQEA_W_K_W@Z ENDP	; std::_WChar_traits<wchar_t>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z PROC	; std::allocator<wchar_t>::allocate, COMDAT

; 929  :         _CRT_GUARDOVERFLOW const size_t _Count) { // allocate array of _Count elements

$LN31:
	sub	rsp, 40					; 00000028H

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
	lea	rax, QWORD PTR [rdx+rdx]
	mov	r8, -1
	cmp	rdx, rcx
	jbe	SHORT $LN4@allocate

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);

	mov	rax, r8

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	jmp	SHORT $LN27@allocate
$LN4@allocate:
	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN7@allocate
$LN27@allocate:

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	cmp	rcx, rax
	cmovbe	rcx, r8

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN16@allocate

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN16@allocate:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@allocate:

; 178  :     if (_Bytes != 0) {

	test	rax, rax
	je	SHORT $LN8@allocate

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rax

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	add	rsp, 40					; 00000028H

; 49   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN8@allocate:

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:
?allocate@?$allocator@_W@std@@QEAAPEA_W_K@Z ENDP	; std::allocator<wchar_t>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z PROC	; std::allocator<wchar_t>::deallocate, COMDAT

; 923  :     void deallocate(_Ty* const _Ptr, const size_t _Count) { // deallocate object at _Ptr

$LN21:
	sub	rsp, 40					; 00000028H
	mov	rax, rdx

; 924  :         // no overflow check on the following multiply; we assume _Allocate did that check
; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [r8+r8]

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN15@deallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rax-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rax, rcx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	add	rax, -8
	cmp	rax, 31
	ja	SHORT $LN12@deallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rax, rcx
$LN15@deallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	mov	rcx, rax

; 926  :     }

	add	rsp, 40					; 00000028H

; 195  :     ::operator delete(_Ptr, _Bytes);

	jmp	??3@YAXPEAX_K@Z				; operator delete
$LN12@deallocate:

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN18@deallocate:
?deallocate@?$allocator@_W@std@@QEAAXQEA_W_K@Z ENDP	; std::allocator<wchar_t>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
_TEXT	SEGMENT
$T5 = 32
_Pb$6 = 40
_Pn$7 = 48
_Nr$8 = 56
$T1 = 56
__$ArrayPad$ = 72
this$ = 96
_Filename$ = 104
_Mode$dead$ = 112
_Prot$dead$ = 120
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT

; 258  :         int _Prot = (int) ios_base::_Openprot) { // open a C stream with specified mode

$LN36:
	push	rdi
	sub	rsp, 80					; 00000050H
	mov	QWORD PTR $T5[rsp], -2
	mov	QWORD PTR [rsp+112], rbx
	mov	QWORD PTR [rsp+120], rsi
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rax, rdx
	mov	rbx, rcx

; 259  :         FILE* _File;
; 260  :         if (_Myfile != nullptr || (_File = _Fiopen(_Filename, _Mode, _Prot)) == nullptr) {

	cmp	QWORD PTR [rcx+128], 0
	jne	$LN3@open
	mov	edx, 33					; 00000021H
	lea	r8d, QWORD PTR [rdx+31]
	mov	rcx, rax
	call	QWORD PTR __imp_?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z
	mov	rdi, rax
	test	rax, rax
	je	$LN3@open

; 657  :         _Closef    = _Which == _Openfl;

	mov	BYTE PTR [rbx+124], 1

; 658  :         _Wrotesome = false;

	mov	BYTE PTR [rbx+113], 0

; 659  : 
; 660  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	rcx, rbx
	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 661  : 
; 662  :         if (_File != nullptr && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 663  :             _Elem** _Pb = nullptr;

	xor	esi, esi
	mov	QWORD PTR _Pb$6[rsp], rsi

; 664  :             _Elem** _Pn = nullptr;

	mov	QWORD PTR _Pn$7[rsp], rsi

; 665  :             int* _Nr    = nullptr;

	mov	QWORD PTR _Nr$8[rsp], rsi

; 666  : 
; 667  :             ::_get_stream_buffer_pointers(

	lea	r9, QWORD PTR _Nr$8[rsp]
	lea	r8, QWORD PTR _Pn$7[rsp]
	lea	rdx, QWORD PTR _Pb$6[rsp]
	mov	rcx, rdi
	call	QWORD PTR __imp__get_stream_buffer_pointers
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\streambuf

; 272  :         _IGfirst = _Gf;

	mov	rax, QWORD PTR _Pb$6[rsp]
	mov	QWORD PTR [rbx+24], rax

; 273  :         _IPfirst = _Pf;

	mov	QWORD PTR [rbx+32], rax

; 274  :         _IGnext  = _Gn;

	mov	rax, QWORD PTR _Pn$7[rsp]
	mov	QWORD PTR [rbx+56], rax

; 275  :         _IPnext  = _Pn;

	mov	QWORD PTR [rbx+64], rax

; 276  :         _IGcount = _Gc;

	mov	rax, QWORD PTR _Nr$8[rsp]
	mov	QWORD PTR [rbx+80], rax

; 277  :         _IPcount = _Pc;

	mov	QWORD PTR [rbx+88], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 674  :         _Myfile = _File;

	mov	QWORD PTR [rbx+128], rdi

; 675  :         _State  = _Stinit;

	mov	rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
	mov	QWORD PTR [rbx+116], rax

; 676  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	QWORD PTR [rbx+104], rsi

; 262  :         }
; 263  : 
; 264  :         _Init(_File, _Openfl);
; 265  :         _Initcvt(_STD use_facet<_Cvt>(_Mysb::getloc()));

	lea	rdx, QWORD PTR $T1[rsp]
	mov	rcx, rbx
	call	QWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ
	npad	1
	mov	rcx, rax
	call	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
	mov	rdi, rax

; 716  :         if (_Newcvt.always_noconv()) {

	mov	rcx, rax
	call	QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
	test	al, al
	je	SHORT $LN18@open

; 717  :             _Pcvt = nullptr; // nothing to do

	mov	QWORD PTR [rbx+104], rsi

; 718  :         } else { // set up for nontrivial codecvt facet

	jmp	SHORT $LN19@open
$LN18@open:

; 719  :             _Pcvt = _STD addressof(_Newcvt);

	mov	QWORD PTR [rbx+104], rdi

; 720  :             _Mysb::_Init(); // reset any buffering

	mov	rcx, rbx
	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
	npad	1
$LN19@open:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 359  :         if (_Ptr != nullptr) {

	mov	rcx, QWORD PTR $T1[rsp+8]
	test	rcx, rcx
	je	SHORT $LN32@open

; 360  :             delete _Ptr->_Decref();

	mov	rdx, QWORD PTR [rcx]
	call	QWORD PTR [rdx+16]
	test	rax, rax
	je	SHORT $LN32@open
	mov	r8, QWORD PTR [rax]
	mov	edx, 1
	mov	rcx, rax
	call	QWORD PTR [r8]
$LN32@open:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream

; 266  :         return this; // open succeeded

	mov	rax, rbx
	jmp	SHORT $LN1@open
$LN3@open:

; 261  :             return nullptr; // open failed

	xor	eax, eax
$LN1@open:

; 267  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+112]
	mov	rsi, QWORD PTR [rsp+120]
	add	rsp, 80					; 00000050H
	pop	rdi
	ret	0
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T5 = 32
_Pb$6 = 40
_Pn$7 = 48
_Nr$8 = 56
$T1 = 56
__$ArrayPad$ = 72
this$ = 96
_Filename$ = 104
_Mode$dead$ = 112
_Prot$dead$ = 120
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1locale@std@@QEAA@XZ			; std::locale::~locale
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 32
_Pb$6 = 40
_Pn$7 = 48
_Nr$8 = 56
$T1 = 56
__$ArrayPad$ = 72
this$ = 96
_Filename$ = 104
_Mode$dead$ = 112
_Prot$dead$ = 120
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
	lea	rcx, QWORD PTR $T1[rdx]
	jmp	??1locale@std@@QEAA@XZ			; std::locale::~locale
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\fstream
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
_TEXT	SEGMENT
$T1 = 32
this$GSCopy$ = 48
this$ = 80
_File$dead$ = 88
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT

; 146  :     basic_filebuf(FILE* _File = nullptr) : _Mysb() { // construct from pointer to C stream

$LN17:
	push	rbx
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T1[rsp], -2
	mov	rbx, rcx
	mov	QWORD PTR this$GSCopy$[rsp], rcx
	call	QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
	npad	1
	lea	rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
	mov	QWORD PTR [rbx], rax

; 657  :         _Closef    = _Which == _Openfl;

	mov	BYTE PTR [rbx+124], 0

; 658  :         _Wrotesome = false;

	mov	BYTE PTR [rbx+113], 0

; 659  : 
; 660  :         _Mysb::_Init(); // initialize stream buffer base object

	mov	rcx, rbx
	call	QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 661  : 
; 662  :         if (_File != nullptr && sizeof(_Elem) == 1) { // point inside C stream with [first, first + count) buffer
; 663  :             _Elem** _Pb = nullptr;
; 664  :             _Elem** _Pn = nullptr;
; 665  :             int* _Nr    = nullptr;
; 666  : 
; 667  :             ::_get_stream_buffer_pointers(
; 668  :                 _File, reinterpret_cast<char***>(&_Pb), reinterpret_cast<char***>(&_Pn), &_Nr);
; 669  :             int* _Nw = _Nr;
; 670  : 
; 671  :             _Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 672  :         }
; 673  : 
; 674  :         _Myfile = _File;

	xor	eax, eax
	mov	QWORD PTR [rbx+128], rax

; 675  :         _State  = _Stinit;

	mov	rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
	mov	QWORD PTR [rbx+116], rcx

; 676  :         _Pcvt   = nullptr; // pointer to codecvt facet

	mov	QWORD PTR [rbx+104], rax

; 147  :         _Init(_File, _Newfl);
; 148  :     }

	mov	rax, rbx
	add	rsp, 64					; 00000040H
	pop	rbx
	ret	0
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 48
this$ = 80
_File$dead$ = 88
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 48
this$ = 80
_File$dead$ = 88
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
	mov	rcx, QWORD PTR this$GSCopy$[rdx]
	rex_jmp	QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT

; 1545 :         return _Myval2;

	mov	rax, rcx

; 1546 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$_Vector_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1537 :         return *this;

	mov	rax, rcx

; 1538 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Get_data@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ PROC ; std::vector<double,std::allocator<double> >::_Get_data, COMDAT

; 1601 :         return _Mypair._Get_second();

	mov	rax, rcx

; 1602 :     }

	ret	0
?_Get_data@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ ENDP ; std::vector<double,std::allocator<double> >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_second, COMDAT

; 1549 :         return _Myval2;

	mov	rax, rcx

; 1550 :     }

	ret	0
?_Get_second@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QEBAAEBV?$_Vector_val@U?$_Simple_types@N@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@0@XZ
_TEXT	SEGMENT
??$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@0@XZ PROC ; std::_Immortalize<std::_Generic_error_category>, COMDAT

; 501  : inline _Ty& _Immortalize() { // return a reference to an object that will live forever

$LN6:
	sub	rsp, 40					; 00000028H

; 502  :     static_assert(sizeof(void*) == sizeof(once_flag), "TRANSITION, VSO#406237");
; 503  :     static_assert(alignof(void*) == alignof(once_flag), "TRANSITION, VSO#406237");
; 504  :     static void* _Flag = nullptr;
; 505  :     static aligned_union_t<1, _Ty> _Storage;
; 506  :     if (_Execute_once(reinterpret_cast<once_flag&>(_Flag), _Immortalize_impl<_Ty>, &_Storage)
; 507  :         == 0) { // _Execute_once should never fail if the callback never fails

	lea	r8, OFFSET FLAT:?_Storage@?1???$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A ; `std::_Immortalize<std::_Generic_error_category>'::`2'::_Storage
	lea	rdx, OFFSET FLAT:??$_Immortalize_impl@V_Generic_error_category@std@@@std@@YAHPEAX0PEAPEAX@Z ; std::_Immortalize_impl<std::_Generic_error_category>
	lea	rcx, OFFSET FLAT:?_Flag@?1???$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@1@XZ@4PEAXEA ; `std::_Immortalize<std::_Generic_error_category>'::`2'::_Flag
	call	QWORD PTR __imp_?_Execute_once@std@@YAHAEAUonce_flag@1@P6AHPEAX1PEAPEAX@Z1@Z
	test	eax, eax
	jne	SHORT $LN2@Immortaliz

; 508  :         _STD terminate();

	call	QWORD PTR __imp_terminate
	int	3
$LN2@Immortaliz:

; 509  :     }
; 510  : 
; 511  :     return reinterpret_cast<_Ty&>(_Storage);

	lea	rax, OFFSET FLAT:?_Storage@?1???$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A ; `std::_Immortalize<std::_Generic_error_category>'::`2'::_Storage

; 512  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@Immortaliz:
??$_Immortalize@V_Generic_error_category@std@@@std@@YAAEAV_Generic_error_category@0@XZ ENDP ; std::_Immortalize<std::_Generic_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@0@XZ
_TEXT	SEGMENT
??$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@0@XZ PROC ; std::_Immortalize<std::_System_error_category>, COMDAT

; 501  : inline _Ty& _Immortalize() { // return a reference to an object that will live forever

$LN6:
	sub	rsp, 40					; 00000028H

; 502  :     static_assert(sizeof(void*) == sizeof(once_flag), "TRANSITION, VSO#406237");
; 503  :     static_assert(alignof(void*) == alignof(once_flag), "TRANSITION, VSO#406237");
; 504  :     static void* _Flag = nullptr;
; 505  :     static aligned_union_t<1, _Ty> _Storage;
; 506  :     if (_Execute_once(reinterpret_cast<once_flag&>(_Flag), _Immortalize_impl<_Ty>, &_Storage)
; 507  :         == 0) { // _Execute_once should never fail if the callback never fails

	lea	r8, OFFSET FLAT:?_Storage@?1???$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A ; `std::_Immortalize<std::_System_error_category>'::`2'::_Storage
	lea	rdx, OFFSET FLAT:??$_Immortalize_impl@V_System_error_category@std@@@std@@YAHPEAX0PEAPEAX@Z ; std::_Immortalize_impl<std::_System_error_category>
	lea	rcx, OFFSET FLAT:?_Flag@?1???$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@1@XZ@4PEAXEA ; `std::_Immortalize<std::_System_error_category>'::`2'::_Flag
	call	QWORD PTR __imp_?_Execute_once@std@@YAHAEAUonce_flag@1@P6AHPEAX1PEAPEAX@Z1@Z
	test	eax, eax
	jne	SHORT $LN2@Immortaliz

; 508  :         _STD terminate();

	call	QWORD PTR __imp_terminate
	int	3
$LN2@Immortaliz:

; 509  :     }
; 510  : 
; 511  :     return reinterpret_cast<_Ty&>(_Storage);

	lea	rax, OFFSET FLAT:?_Storage@?1???$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@1@XZ@4T?$_Align_type@N$0BA@@1@A ; `std::_Immortalize<std::_System_error_category>'::`2'::_Storage

; 512  : }

	add	rsp, 40					; 00000028H
	ret	0
$LN4@Immortaliz:
??$_Immortalize@V_System_error_category@std@@@std@@YAAEAV_System_error_category@0@XZ ENDP ; std::_Immortalize<std::_System_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
$T1 = 48
$T32 = 64
$T23 = 64
$T36 = 80
__$ReturnUdt$GSCopy$ = 88
$T22 = 96
$T31 = 112
$T24 = 128
$T33 = 168
this$ = 240
__$ReturnUdt$ = 248
_Al$dead$ = 256
??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z PROC ; std::filesystem::path::string<char,std::char_traits<char>,std::allocator<char>,0>, COMDAT

; 943  :             const _Alloc& _Al = _Alloc()) const { // convert the native path from this instance into a basic_string

$LN93:
	mov	rax, rsp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 208				; 000000d0H
	mov	QWORD PTR $T36[rsp], -2
	mov	QWORD PTR [rax+8], rbx
	mov	QWORD PTR [rax+24], rbp
	mov	rdi, rdx
	mov	rsi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rdx
	xor	ebx, ebx
	mov	DWORD PTR $T1[rsp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3196 :         return basic_string_view<_Elem, _Traits>(_My_data._Myptr(), _My_data._Mysize);

	mov	rbp, QWORD PTR [rcx+16]

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 8

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN12@string
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rsi, QWORD PTR [rcx]
$LN12@string:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 164  :             return _Convert_wide_to_narrow<_Traits>(__std_fs_code_page(), _Input, _Al);

	call	__std_fs_code_page
	mov	r14d, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], rbx

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 343  :         _Left = _Right;

	mov	BYTE PTR [rdi], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 95   :         return _Output;

	mov	DWORD PTR $T1[rsp], 4

; 51   :         }
; 52   : 
; 53   :         return _Result._Len;
; 54   :     }
; 55   : 
; 56   :     _NODISCARD inline wstring _Convert_narrow_to_wide(const __std_code_page _Code_page, const string_view _Input) {
; 57   :         wstring _Output;
; 58   : 
; 59   :         if (!_Input.empty()) {
; 60   :             if (_Input.size() > static_cast<size_t>(INT_MAX)) {
; 61   :                 _Xsystem_error_invalid_argument();
; 62   :             }
; 63   : 
; 64   :             const int _Len = _Check_convert_result(__std_fs_convert_narrow_to_wide(
; 65   :                 _Code_page, _Input.data(), static_cast<int>(_Input.size()), nullptr, 0));
; 66   : 
; 67   :             _Output.resize(static_cast<size_t>(_Len));
; 68   : 
; 69   :             (void) _Check_convert_result(__std_fs_convert_narrow_to_wide(
; 70   :                 _Code_page, _Input.data(), static_cast<int>(_Input.size()), _Output.data(), _Len));
; 71   :         }
; 72   : 
; 73   :         return _Output;
; 74   :     }
; 75   : 
; 76   :     template <class _Traits, class _Alloc>
; 77   :     _NODISCARD inline basic_string<char, _Traits, _Alloc> _Convert_wide_to_narrow(
; 78   :         const __std_code_page _Code_page, const wstring_view _Input, const _Alloc& _Al) {
; 79   :         basic_string<char, _Traits, _Alloc> _Output(_Al);
; 80   : 
; 81   :         if (!_Input.empty()) {

	test	rbp, rbp
	je	SHORT $LN83@string

; 82   :             if (_Input.size() > static_cast<size_t>(INT_MAX)) {

	cmp	rbp, 2147483647				; 7fffffffH
	ja	$LN89@string

; 84   :             }
; 85   : 
; 86   :             const int _Len = _Check_convert_result(__std_fs_convert_wide_to_narrow(

	mov	DWORD PTR [rsp+32], ebx
	xor	r9d, r9d
	mov	r8d, ebp
	mov	rdx, rsi
	mov	ecx, eax
	call	__std_fs_convert_wide_to_narrow
	mov	rbx, rax

; 49   :         if (_Result._Err != __std_win_error::_Success) {

	shr	rax, 32					; 00000020H
	test	eax, eax
	jne	$LN90@string

; 89   :             _Output.resize(static_cast<size_t>(_Len));

	movsxd	rdx, ebx
	mov	rcx, rdi
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	r9, rdi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi+24], 16

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN72@string
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	r9, QWORD PTR [rdi]
$LN72@string:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 91   :             (void) _Check_convert_result(__std_fs_convert_wide_to_narrow(

	mov	DWORD PTR [rsp+32], ebx
	mov	r8d, ebp
	mov	rdx, rsi
	mov	ecx, r14d
	call	__std_fs_convert_wide_to_narrow

; 49   :         if (_Result._Err != __std_win_error::_Success) {

	shr	rax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN91@string
$LN83@string:

; 944  :             return _Convert_wide_to<_EcharT, _Traits>(_Text, _Al);

	mov	rax, rdi

; 945  :         }

	lea	r11, QWORD PTR [rsp+208]
	mov	rbx, QWORD PTR [r11+32]
	mov	rbp, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN91@string:

; 50   :             _THROW(system_error(_Make_ec(_Result._Err)));

	mov	edx, eax
	lea	rcx, QWORD PTR $T31[rsp]
	call	?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z ; std::filesystem::_Make_ec
	vmovups	xmm0, XMMWORD PTR [rax]
	vmovups	XMMWORD PTR $T32[rsp], xmm0
	lea	rdx, QWORD PTR $T32[rsp]
	lea	rcx, QWORD PTR $T33[rsp]
	call	??0system_error@std@@QEAA@Verror_code@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T33[rsp]
	call	_CxxThrowException
	int	3
$LN89@string:

; 83   :                 _Xsystem_error_invalid_argument();

	call	?_Xsystem_error_invalid_argument@filesystem@std@@YAXXZ ; std::filesystem::_Xsystem_error_invalid_argument
	int	3
$LN90@string:

; 50   :             _THROW(system_error(_Make_ec(_Result._Err)));

	mov	edx, eax
	lea	rcx, QWORD PTR $T22[rsp]
	call	?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z ; std::filesystem::_Make_ec
	vmovups	xmm0, XMMWORD PTR [rax]
	vmovups	XMMWORD PTR $T23[rsp], xmm0
	lea	rdx, QWORD PTR $T23[rsp]
	lea	rcx, QWORD PTR $T24[rsp]
	call	??0system_error@std@@QEAA@Verror_code@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T24[rsp]
	call	_CxxThrowException
	int	3
$LN87@string:
??$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z ENDP ; std::filesystem::path::string<char,std::char_traits<char>,std::allocator<char>,0>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T32 = 64
$T23 = 64
$T36 = 80
__$ReturnUdt$GSCopy$ = 88
$T22 = 96
$T31 = 112
$T24 = 128
$T33 = 168
this$ = 240
__$ReturnUdt$ = 248
_Al$dead$ = 256
?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA PROC ; `std::filesystem::path::string<char,std::char_traits<char>,std::allocator<char>,0>'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN29@dtor$2
	and	DWORD PTR $T1[rbp], -5
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN29@dtor$2:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA ENDP ; `std::filesystem::path::string<char,std::char_traits<char>,std::allocator<char>,0>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T32 = 64
$T23 = 64
$T36 = 80
__$ReturnUdt$GSCopy$ = 88
$T22 = 96
$T31 = 112
$T24 = 128
$T33 = 168
this$ = 240
__$ReturnUdt$ = 248
_Al$dead$ = 256
?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA PROC ; `std::filesystem::path::string<char,std::char_traits<char>,std::allocator<char>,0>'::`1'::dtor$2
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 4
	test	eax, eax
	je	SHORT $LN29@dtor$2
	and	DWORD PTR $T1[rbp], -5
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN29@dtor$2:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$2@?0???$string@DU?$char_traits@D@std@@V?$allocator@D@2@$0A@@path@filesystem@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@AEBV?$allocator@D@2@@Z@4HA ENDP ; `std::filesystem::path::string<char,std::char_traits<char>,std::allocator<char>,0>'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T1 = 48
$T22 = 64
$T13 = 64
$T21 = 80
$T12 = 80
$T23 = 96
$T14 = 96
__$ReturnUdt$ = 176
_Code_page$ = 184
_Input$ = 192
_Al$dead$ = 200
??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z PROC ; std::filesystem::_Convert_wide_to_narrow<std::char_traits<char>,std::allocator<char> >, COMDAT

; 78   :         const __std_code_page _Code_page, const wstring_view _Input, const _Alloc& _Al) {

$LN68:
	mov	rax, rsp
	mov	QWORD PTR [rax+8], rcx
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 144				; 00000090H
	mov	QWORD PTR [rax-112], -2
	mov	QWORD PTR [rax+16], rbx
	mov	QWORD PTR [rax+24], rbp
	mov	ebp, edx
	mov	rdi, rcx
	xor	eax, eax
	mov	DWORD PTR $T1[rsp], eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], rax

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 343  :         _Left = _Right;

	mov	BYTE PTR [rcx], al
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 95   :         return _Output;

	mov	DWORD PTR $T1[rsp], 1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 1204 :         return _Mysize == 0;

	mov	rsi, QWORD PTR [r8+8]
	test	rsi, rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 81   :         if (!_Input.empty()) {

	je	SHORT $LN60@Convert_wi

; 82   :             if (_Input.size() > static_cast<size_t>(INT_MAX)) {

	cmp	rsi, 2147483647				; 7fffffffH
	ja	$LN64@Convert_wi

; 84   :             }
; 85   : 
; 86   :             const int _Len = _Check_convert_result(__std_fs_convert_wide_to_narrow(

	mov	r14, QWORD PTR [r8]
	mov	DWORD PTR [rsp+32], eax
	xor	r9d, r9d
	mov	r8d, esi
	mov	rdx, r14
	mov	ecx, ebp
	call	__std_fs_convert_wide_to_narrow
	mov	rbx, rax

; 49   :         if (_Result._Err != __std_win_error::_Success) {

	shr	rax, 32					; 00000020H
	test	eax, eax
	jne	$LN65@Convert_wi

; 87   :                 _Code_page, _Input.data(), static_cast<int>(_Input.size()), nullptr, 0));
; 88   : 
; 89   :             _Output.resize(static_cast<size_t>(_Len));

	movsxd	rdx, ebx
	mov	rcx, rdi
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	r9, rdi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi+24], 16

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN49@Convert_wi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	r9, QWORD PTR [rdi]
$LN49@Convert_wi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 91   :             (void) _Check_convert_result(__std_fs_convert_wide_to_narrow(

	mov	DWORD PTR [rsp+32], ebx
	mov	r8d, esi
	mov	rdx, r14
	mov	ecx, ebp
	call	__std_fs_convert_wide_to_narrow

; 49   :         if (_Result._Err != __std_win_error::_Success) {

	shr	rax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN66@Convert_wi
$LN60@Convert_wi:

; 95   :         return _Output;

	mov	rax, rdi

; 96   :     }

	lea	r11, QWORD PTR [rsp+144]
	mov	rbx, QWORD PTR [r11+40]
	mov	rbp, QWORD PTR [r11+48]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN66@Convert_wi:

; 50   :             _THROW(system_error(_Make_ec(_Result._Err)));

	mov	edx, eax
	lea	rcx, QWORD PTR $T21[rsp]
	call	?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z ; std::filesystem::_Make_ec
	vmovups	xmm0, XMMWORD PTR [rax]
	vmovups	XMMWORD PTR $T22[rsp], xmm0
	lea	rdx, QWORD PTR $T22[rsp]
	lea	rcx, QWORD PTR $T23[rsp]
	call	??0system_error@std@@QEAA@Verror_code@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T23[rsp]
	call	_CxxThrowException
	int	3
$LN64@Convert_wi:

; 83   :                 _Xsystem_error_invalid_argument();

	call	?_Xsystem_error_invalid_argument@filesystem@std@@YAXXZ ; std::filesystem::_Xsystem_error_invalid_argument
	int	3
$LN65@Convert_wi:

; 50   :             _THROW(system_error(_Make_ec(_Result._Err)));

	mov	edx, eax
	lea	rcx, QWORD PTR $T12[rsp]
	call	?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z ; std::filesystem::_Make_ec
	vmovups	xmm0, XMMWORD PTR [rax]
	vmovups	XMMWORD PTR $T13[rsp], xmm0
	lea	rdx, QWORD PTR $T13[rsp]
	lea	rcx, QWORD PTR $T14[rsp]
	call	??0system_error@std@@QEAA@Verror_code@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T14[rsp]
	call	_CxxThrowException
	int	3
$LN62@Convert_wi:
??$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z ENDP ; std::filesystem::_Convert_wide_to_narrow<std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T22 = 64
$T13 = 64
$T21 = 80
$T12 = 80
$T23 = 96
$T14 = 96
__$ReturnUdt$ = 176
_Code_page$ = 184
_Input$ = 192
_Al$dead$ = 200
?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA PROC ; `std::filesystem::_Convert_wide_to_narrow<std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::filesystem::_Convert_wide_to_narrow<std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T22 = 64
$T13 = 64
$T21 = 80
$T12 = 80
$T23 = 96
$T14 = 96
__$ReturnUdt$ = 176
_Code_page$ = 184
_Input$ = 192
_Al$dead$ = 200
?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA PROC ; `std::filesystem::_Convert_wide_to_narrow<std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 1
	test	eax, eax
	je	SHORT $LN6@dtor$0
	and	DWORD PTR $T1[rbp], -2
	mov	rcx, QWORD PTR __$ReturnUdt$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN6@dtor$0:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$0@?0???$_Convert_wide_to_narrow@U?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@W4__std_code_page@@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::filesystem::_Convert_wide_to_narrow<std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??$?YV?$basic_string_view@DU?$char_traits@D@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$?YV?$basic_string_view@DU?$char_traits@D@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=<std::basic_string_view<char,std::char_traits<char> >,void>, COMDAT

; 2592 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;

	vmovups	xmm0, XMMWORD PTR [rdx]

; 2593 :         return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));

	vpextrq	r8, xmm0, 1
	vmovq	rdx, xmm0
	jmp	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
??$?YV?$basic_string_view@DU?$char_traits@D@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=<std::basic_string_view<char,std::char_traits<char> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z
_TEXT	SEGMENT
$T14 = 32
this$ = 64
_Source$ = 72
__formal$dead$ = 80
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z PROC ; std::filesystem::path::path<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>, COMDAT

; 652  :             : _Text(_Convert_Source_to_wide(_Source)) { // construct a path with native() set to _Source

$LN37:
	push	rbx
	sub	rsp, 48					; 00000030H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 652  :             : _Text(_Convert_Source_to_wide(_Source)) { // construct a path with native() set to _Source

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3264 :         return _Get_data()._Mysize;

	mov	rax, QWORD PTR [rdx+16]

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN23@path
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rdx, QWORD PTR [rdx]
$LN23@path:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 199  :             return _Convert_narrow_to_wide(__std_fs_code_page(), _Input);

	mov	QWORD PTR $T14[rsp], rdx
	mov	QWORD PTR $T14[rsp+8], rax
	call	__std_fs_code_page
	lea	r8, QWORD PTR $T14[rsp]
	mov	edx, eax
	mov	rcx, rbx
	call	?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z ; std::filesystem::_Convert_narrow_to_wide

; 653  :                                                         // format has no meaning for this implementation, as the generic
; 654  :                                                         // grammar is acceptable as a native path
; 655  :         }

	mov	rax, rbx
	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$?0V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$0A@@path@filesystem@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@W4format@012@@Z ENDP ; std::filesystem::path::path<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
$T29 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 696  :     const char* _Val) { // insert NTBS into char stream

$LN109:
	mov	QWORD PTR [rsp+8], rcx
	push	rsi
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 64					; 00000040H
	mov	QWORD PTR $T29[rsp], -2
	mov	QWORD PTR [rsp+120], rbx
	mov	r15, rdx
	mov	rsi, rcx

; 697  :     using _Elem = char;
; 698  :     using _Myos = basic_ostream<_Elem, _Traits>;
; 699  : 
; 700  :     ios_base::iostate _State = ios_base::goodbit;

	xor	ebx, ebx
	mov	DWORD PTR _State$[rsp], ebx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 301  :         return __builtin_strlen(_First);

	mov	r14, -1
$LL103@operator:
	inc	r14
	cmp	BYTE PTR [rdx+r14], bl
	jne	SHORT $LL103@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 702  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	mov	rcx, QWORD PTR [rcx]
	movsxd	rax, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 389  :         return _Wide;

	mov	rdi, QWORD PTR [rax+rsi+40]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 702  :     streamsize _Pad          = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;

	test	rdi, rdi
	jle	SHORT $LN17@operator
	cmp	rdi, r14
	jle	SHORT $LN17@operator
	sub	rdi, r14
	jmp	SHORT $LN18@operator
$LN17@operator:
	xor	edi, edi
$LN18@operator:

; 69   :         __CLR_OR_THIS_CALL _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr) { // lock the stream buffer, if there

	mov	r12, rsi
	mov	QWORD PTR _Ok$[rsp], rsi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	rdx, QWORD PTR [rax+rsi+72]
	mov	r8, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 70   :             if (_Myostr.rdbuf() != nullptr) {

	test	rdx, rdx
	je	SHORT $LN37@operator

; 71   :                 _Myostr.rdbuf()->_Lock();

	mov	rax, QWORD PTR [rdx]
	mov	rcx, rdx
	call	QWORD PTR [rax+8]
	mov	rcx, QWORD PTR [rsi]
	mov	r8, rcx
$LN37@operator:

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	movsxd	r9, DWORD PTR [rcx+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 302  :         return _Mystate;

	mov	rax, rcx
	mov	rdx, r8

; 321  :         return rdstate() == ios_base::goodbit;

	cmp	DWORD PTR [r9+rsi+16], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	jne	SHORT $LN33@operator
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 67   :         return _Tiestr;

	mov	r9, QWORD PTR [r9+rsi+80]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 90   :             if (_Ostr.good() && _Ostr.tie() != nullptr && _Ostr.tie() != &_Ostr) {

	test	r9, r9
	je	SHORT $LN33@operator
	cmp	r9, rsi
	je	SHORT $LN33@operator

; 91   :                 _Ostr.tie()->flush();

	mov	rcx, r9
	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
	mov	rax, QWORD PTR [rsi]
	mov	rdx, rax
$LN33@operator:

; 92   :             }
; 93   : 
; 94   :             _Ok = _Ostr.good(); // store test only after flushing tie

	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 302  :         return _Mystate;

	mov	eax, DWORD PTR [rcx+rsi+16]

; 321  :         return rdstate() == ios_base::goodbit;

	test	eax, eax
	sete	BYTE PTR _Ok$[rsp+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 703  :     const typename _Myos::sentry _Ok(_Ostr);

	test	eax, eax

; 704  : 
; 705  :     if (!_Ok) {

	je	SHORT $LN8@operator

; 706  :         _State |= ios_base::badbit;

	mov	ebx, 4

; 707  :     } else { // state okay, insert

	jmp	$LN22@operator
$LN8@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 352  :         return _Fmtfl;

	mov	eax, DWORD PTR [rcx+rsi+24]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 709  :         if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left) {

	and	eax, 448				; 000001c0H
	cmp	eax, 64					; 00000040H
	je	SHORT $LN99@operator
	npad	6
$LL4@operator:

; 710  :             for (; 0 < _Pad; --_Pad) { // pad on left

	test	rdi, rdi
	jle	SHORT $LN3@operator

; 711  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	cmp	eax, -1
	je	SHORT $LN106@operator

; 710  :             for (; 0 < _Pad; --_Pad) { // pad on left

	dec	rdi
	jmp	SHORT $LL4@operator
$LN3@operator:

; 712  :                     _State |= ios_base::badbit; // insertion failed, quit
; 713  :                     break;
; 714  :                 }
; 715  :             }
; 716  :         }
; 717  : 
; 718  :         if (_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count) {

	mov	rdx, QWORD PTR [rsi]
$LN99@operator:
	movsxd	rax, DWORD PTR [rdx+4]
	mov	r8, r14
	mov	rdx, r15
	mov	rcx, QWORD PTR [rax+rsi+72]
	call	QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
	cmp	rax, r14
	jne	SHORT $LN106@operator
$LL104@operator:

; 719  :             _State |= ios_base::badbit;
; 720  :         }
; 721  : 
; 722  :         if (_State == ios_base::goodbit) {
; 723  :             for (; 0 < _Pad; --_Pad) { // pad on right

	test	rdi, rdi
	jle	SHORT $LN6@operator

; 724  :                 if (_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill()))) {

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	movzx	edx, BYTE PTR [rcx+rsi+88]
	mov	rcx, QWORD PTR [rcx+rsi+72]
	call	QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
	cmp	eax, -1
	je	SHORT $LN106@operator

; 719  :             _State |= ios_base::badbit;
; 720  :         }
; 721  : 
; 722  :         if (_State == ios_base::goodbit) {
; 723  :             for (; 0 < _Pad; --_Pad) { // pad on right

	dec	rdi
	jmp	SHORT $LL104@operator
$LN106@operator:

; 725  :                     _State |= ios_base::badbit; // insertion failed, quit
; 726  :                     break;
; 727  :                 }
; 728  :             }
; 729  :         }
; 730  : 
; 731  :         _Ostr.width(0);

	mov	ebx, 4
	mov	DWORD PTR _State$[rsp], ebx
$LN6@operator:
	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xiosbase

; 394  :         _Wide                      = _Newwidth;

	mov	QWORD PTR [rcx+rsi+40], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
	jmp	SHORT $LN22@operator
$LN23@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios
	mov	rsi, QWORD PTR _Ostr$[rsp]
	mov	ebx, DWORD PTR _State$[rsp]
	mov	r12, QWORD PTR _Ok$[rsp]
$LN22@operator:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 735  :     _Ostr.setstate(_State);

	mov	rax, QWORD PTR [rsi]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rsi
	xor	r8d, r8d
	mov	edx, ebx
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1

; 106  :             if (!_STD uncaught_exception()) { // TRANSITION, OS#15518458

	call	QWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
	test	al, al
	jne	SHORT $LN82@operator

; 107  :                 this->_Myostr._Osfx();

	mov	rcx, r12
	call	QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	npad	1
$LN82@operator:

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	mov	rax, QWORD PTR [r12]
	movsxd	rcx, DWORD PTR [rax+4]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ios

; 77   :         return _Mystrbuf;

	mov	rcx, QWORD PTR [rcx+r12+72]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream

; 76   :             if (_Myostr.rdbuf() != nullptr) {

	test	rcx, rcx
	je	SHORT $LN86@operator

; 77   :                 _Myostr.rdbuf()->_Unlock();

	mov	rax, QWORD PTR [rcx]
	call	QWORD PTR [rax+16]
	npad	1
$LN86@operator:

; 736  :     return _Ostr;

	mov	rax, rsi

; 737  : }

	mov	rbx, QWORD PTR [rsp+120]
	add	rsp, 64					; 00000040H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T29 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
$T29 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
$T29 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4

; 732  :         _CATCH_IO_(ios_base, _Ostr)

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
	mov	rdx, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rdx
	mov	r8b, 1
	mov	edx, 4
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
	lea	rax, $LN23@catch$4
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T29 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T29 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Ok$[rdx]
	jmp	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T29 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4

; 732  :         _CATCH_IO_(ios_base, _Ostr)

	mov	QWORD PTR [rsp+16], rdx
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
	mov	rdx, QWORD PTR _Ostr$[rbp]
	mov	rax, QWORD PTR [rdx]
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rdx
	mov	r8b, 1
	mov	edx, 4
	call	QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
	npad	1
	lea	rax, $LN23@catch$4
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
	int	3
?catch$4@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$4
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Ostr$ = 48
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 901  :     basic_ostream<_Elem, _Traits>& _Ostr) { // insert newline and flush stream

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 902  :     _Ostr.put(_Ostr.widen('\n'));

	mov	rax, QWORD PTR [rcx]
	mov	rbx, rcx
	mov	dl, 10
	movsxd	rcx, DWORD PTR [rax+4]
	add	rcx, rbx
	call	QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
	movzx	edx, al
	mov	rcx, rbx
	call	QWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z

; 903  :     _Ostr.flush();

	mov	rcx, rbx
	call	QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 904  :     return _Ostr;

	mov	rax, rbx

; 905  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??$_Unfancy_maybe_null@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy_maybe_null@D@std@@YAPEADPEAD@Z PROC		; std::_Unfancy_maybe_null<char>, COMDAT

; 334  :     return _Ptr;

	mov	rax, rcx

; 335  : }

	ret	0
??$_Unfancy_maybe_null@D@std@@YAPEADPEAD@Z ENDP		; std::_Unfancy_maybe_null<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1534 :     }

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@DV?$allocator@D@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z
_TEXT	SEGMENT
__$ArrayPad$ = 32
this$ = 64
_Count$dead$ = 72
_Val$dead$ = 80
??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@DV?$allocator@D@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z PROC ; std::vector<char,std::allocator<char> >::_Construct_n_copies_of_ty<std::_Value_init_tag>, COMDAT

; 383  :     void _Construct_n_copies_of_ty(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty2& _Val) {

$LN142:
	mov	QWORD PTR [rsp+16], rbx
	push	rdi
	sub	rsp, 48					; 00000030H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rdi, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	mov	ecx, 800				; 00000320H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	mov	QWORD PTR [rdi], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8d, 800				; 00000320H
	mov	rcx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	lea	rbx, QWORD PTR [rax+800]
	mov	QWORD PTR [rdi+16], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	call	memset
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 389  :             _Mylast()      = _Ufill(_Myfirst(), _Count, _Val);

	mov	QWORD PTR [rdi+8], rbx

; 390  :             _Guard._Target = nullptr;
; 391  :         }
; 392  : 
; 393  :         _Proxy._Release();
; 394  :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 48					; 00000030H
	pop	rdi
	ret	0
??$_Construct_n_copies_of_ty@U_Value_init_tag@std@@@?$vector@DV?$allocator@D@std@@@std@@AEAAX_KAEBU_Value_init_tag@1@@Z ENDP ; std::vector<char,std::allocator<char> >::_Construct_n_copies_of_ty<std::_Value_init_tag>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AEBN@std@@YAAEBNAEBN@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBN@std@@YAAEBNAEBN@Z PROC			; std::forward<double const &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1298 : }

	ret	0
??$forward@AEBN@std@@YAAEBNAEBN@Z ENDP			; std::forward<double const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$_Unfancy@N@std@@YAPEANPEAN@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@N@std@@YAPEANPEAN@Z PROC			; std::_Unfancy<double>, COMDAT

; 295  :     return _Ptr;

	mov	rax, rcx

; 296  : }

	ret	0
??$_Unfancy@N@std@@YAPEANPEAN@Z ENDP			; std::_Unfancy<double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$construct@NAEBN@?$_Default_allocator_traits@V?$allocator@N@std@@@std@@SAXAEAV?$allocator@N@1@QEANAEBN@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@NAEBN@?$_Default_allocator_traits@V?$allocator@N@std@@@std@@SAXAEAV?$allocator@N@1@QEANAEBN@Z PROC ; std::_Default_allocator_traits<std::allocator<double> >::construct<double,double const &>, COMDAT

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 819  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 820  :     }

	ret	0
??$construct@NAEBN@?$_Default_allocator_traits@V?$allocator@N@std@@@std@@SAXAEAV?$allocator@N@1@QEANAEBN@Z ENDP ; std::_Default_allocator_traits<std::allocator<double> >::construct<double,double const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z
_TEXT	SEGMENT
this$ = 80
_Whereptr$ = 88
<_Val_0>$ = 96
??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z PROC ; std::vector<double,std::allocator<double> >::_Emplace_reallocate<double const &>, COMDAT

; 659  :         const pointer _Whereptr, _Valty&&... _Val) { // reallocate and insert by perfectly forwarding _Val at _Whereptr

$LN318:
	push	rsi
	push	rdi
	push	r12
	push	r14
	sub	rsp, 40					; 00000028H

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	rax, QWORD PTR [rcx+8]

; 659  :         const pointer _Whereptr, _Valty&&... _Val) { // reallocate and insert by perfectly forwarding _Val at _Whereptr

	mov	r14, rdx

; 660  :                                                      // pre: !_Has_unused_capacity()
; 661  :         const size_type _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst());

	mov	rdx, QWORD PTR [rcx]
	mov	rsi, r14
	sub	rsi, rdx

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	sub	rax, rdx

; 660  :                                                      // pre: !_Has_unused_capacity()
; 661  :         const size_type _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst());

	sar	rsi, 3

; 662  :         _Alty& _Al                = _Getal();
; 663  :         const size_type _Oldsize  = size();
; 664  : 
; 665  :         if (_Oldsize == max_size()) {

	mov	r9, 2305843009213693951			; 1fffffffffffffffH

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	sar	rax, 3

; 659  :         const pointer _Whereptr, _Valty&&... _Val) { // reallocate and insert by perfectly forwarding _Val at _Whereptr

	mov	r12, r8
	mov	rdi, rcx

; 662  :         _Alty& _Al                = _Getal();
; 663  :         const size_type _Oldsize  = size();
; 664  : 
; 665  :         if (_Oldsize == max_size()) {

	cmp	rax, r9
	je	$LN316@Emplace_re

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	rcx, QWORD PTR [rcx+16]
	sub	rcx, rdx
	mov	QWORD PTR [rsp+104], rbp
	sar	rcx, 3

; 667  :         }
; 668  : 
; 669  :         const size_type _Newsize     = _Oldsize + 1;

	lea	rbp, QWORD PTR [rax+1]

; 1475 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	rdx, rcx
	mov	QWORD PTR [rsp+32], r15
	shr	rdx, 1
	mov	rax, r9
	sub	rax, rdx
	cmp	rcx, rax
	jbe	SHORT $LN48@Emplace_re

; 1476 :             return _Newsize; // geometric growth would overflow

	mov	rax, rbp
	jmp	SHORT $LN49@Emplace_re
$LN48@Emplace_re:

; 1477 :         }
; 1478 : 
; 1479 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rdx+rcx]

; 1480 : 
; 1481 :         if (_Geometric < _Newsize) {

	cmp	rax, rbp
	cmovb	rax, rbp
$LN49@Emplace_re:
	mov	QWORD PTR [rsp+96], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 25   :     size_t _Result                 = _Count * _Ty_size;

	lea	r15, QWORD PTR [rax*8]
	mov	rdx, r15

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	mov	r8, -1
	cmp	rax, r9
	jbe	SHORT $LN80@Emplace_re

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);

	mov	rdx, r8

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	jmp	SHORT $LN309@Emplace_re
$LN80@Emplace_re:
	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN83@Emplace_re
$LN309@Emplace_re:

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	cmp	rcx, rdx
	cmovbe	rcx, r8

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN278@Emplace_re

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN82@Emplace_re
$LN83@Emplace_re:

; 175  :     }
; 176  : #endif // defined(_M_IX86) || defined(_M_X64)
; 177  : 
; 178  :     if (_Bytes != 0) {

	test	rdx, rdx
	je	SHORT $LN84@Emplace_re

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rdx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 179  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN82@Emplace_re
$LN84@Emplace_re:

; 180  :     }
; 181  : 
; 182  :     return nullptr;

	xor	ebx, ebx
$LN82@Emplace_re:

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	rax, QWORD PTR [r12]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 677  :         _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward<_Valty>(_Val)...);

	lea	rsi, QWORD PTR [rbx+rsi*8]

; 680  :         if (_Whereptr == _Mylast()) { // at back, provide strong guarantee

	mov	rdx, QWORD PTR [rdi]
	mov	rcx, rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	QWORD PTR [rsi], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 680  :         if (_Whereptr == _Mylast()) { // at back, provide strong guarantee

	mov	r8, QWORD PTR [rdi+8]
	cmp	r14, r8
	jne	SHORT $LN4@Emplace_re
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 682  :         } else { // provide basic guarantee

	jmp	SHORT $LN314@Emplace_re
$LN4@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, r14
	sub	r8, rdx

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	call	memmove

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	mov	r8, QWORD PTR [rdi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 685  :             _Umove(_Whereptr, _Mylast(), _Newvec + _Whereoff + 1);

	lea	rcx, QWORD PTR [rsi+8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, r14

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, r14
$LN314@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 685  :             _Umove(_Whereptr, _Mylast(), _Newvec + _Whereoff + 1);

	call	memmove

; 1512 :         if (_Myfirst() != pointer()) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rdi]
	test	rcx, rcx
	je	SHORT $LN271@Emplace_re

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	rdx, QWORD PTR [rdi+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN281@Emplace_re

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN278@Emplace_re

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN281@Emplace_re:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN271@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1518 :         _Mylast()  = _Newvec + _Newsize;

	lea	rcx, QWORD PTR [rbx+rbp*8]
	mov	QWORD PTR [rdi], rbx
	mov	rbp, QWORD PTR [rsp+104]

; 686  :         }
; 687  :         _CATCH_ALL
; 688  :         _Destroy(_Constructed_first, _Constructed_last);
; 689  :         _Al.deallocate(_Newvec, _Newcapacity);
; 690  :         _RERAISE;
; 691  :         _CATCH_END
; 692  : 
; 693  :         _Change_array(_Newvec, _Newsize, _Newcapacity);
; 694  :         return this->_Myfirst() + _Whereoff;

	mov	rax, rsi

; 1518 :         _Mylast()  = _Newvec + _Newsize;

	mov	QWORD PTR [rdi+8], rcx

; 1519 :         _Myend()   = _Newvec + _Newcapacity;

	lea	rcx, QWORD PTR [r15+rbx]
	mov	rbx, QWORD PTR [rsp+96]
	mov	r15, QWORD PTR [rsp+32]
	mov	QWORD PTR [rdi+16], rcx

; 695  :     }

	add	rsp, 40					; 00000028H
	pop	r14
	pop	r12
	pop	rdi
	pop	rsi
	ret	0
$LN278@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN316@Emplace_re:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 666  :             _Xlength();

	call	?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ ; std::vector<double,std::allocator<double> >::_Xlength
	int	3
$LN313@Emplace_re:
??$_Emplace_reallocate@AEBN@?$vector@NV?$allocator@N@std@@@std@@QEAAPEANQEANAEBN@Z ENDP ; std::vector<double,std::allocator<double> >::_Emplace_reallocate<double const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0V?$allocator@N@std@@$$V@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@N@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@N@std@@$$V@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@N@1@@Z PROC ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1><std::allocator<double> >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1534 :     }

	mov	rax, rcx
	ret	0
??$?0V?$allocator@N@std@@$$V@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@N@1@@Z ENDP ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1><std::allocator<double> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 282  : }

	ret	0
??$addressof@V?$_String_val@U?$_Simple_types@_W@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@_W@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<wchar_t> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z PROC ; std::move<std::allocator<wchar_t> &>, COMDAT

; 1309 :     return static_cast<remove_reference_t<_Ty>&&>(_Arg);

	mov	rax, rcx

; 1310 : }

	ret	0
??$move@AEAV?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ENDP ; std::move<std::allocator<wchar_t> &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1534 :     }

	mov	rax, rcx
	ret	0
??$?0V?$allocator@_W@std@@$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@_W@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1528 :     }

	mov	rax, rcx
	ret	0
??$?0$$V@?$_Compressed_pair@V?$allocator@_W@std@@V?$_String_val@U?$_Simple_types@_W@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1>::_Compressed_pair<std::allocator<wchar_t>,std::_String_val<std::_Simple_types<wchar_t> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z PROC		; std::_Refancy<char *,0>, COMDAT

; 326  :     return _Ptr;

	mov	rax, rcx

; 327  : }

	ret	0
??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z ENDP		; std::_Refancy<char *,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale
;	COMDAT ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
_TEXT	SEGMENT
$T1 = 40
_Psave$20 = 64
_Lock$21 = 72
_Psave_guard$22 = 80
__$ArrayPad$ = 88
_Loc$ = 112
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,_Mbstatet> >, COMDAT

; 434  : { // get facet reference from locale

$LN71:
	mov	r11, rsp
	push	rdi
	sub	rsp, 96					; 00000060H
	mov	QWORD PTR [r11-72], -2
	mov	QWORD PTR [r11+16], rbx
	mov	QWORD PTR [r11+24], rsi
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
	mov	rsi, rcx

; 435  :     _BEGIN_LOCK(_LOCK_LOCALE) // the thread lock, make get atomic

	xor	edx, edx
	lea	rcx, QWORD PTR [r11-32]
	call	QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
	npad	1

; 436  :     const locale::facet* _Psave = _Facetptr<_Facet>::_Psave; // static pointer to lazy facet

	mov	rax, QWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
	mov	QWORD PTR _Psave$20[rsp], rax

; 437  : 
; 438  :     const size_t _Id         = _Facet::id;

	mov	rcx, QWORD PTR __imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
	call	QWORD PTR __imp_??Bid@locale@std@@QEAA_KXZ
	mov	rdi, rax

; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	mov	rax, QWORD PTR [rsi+8]
	cmp	rdi, QWORD PTR [rax+24]
	jae	SHORT $LN15@use_facet
	mov	rcx, QWORD PTR [rax+16]
	mov	rbx, QWORD PTR [rcx+rdi*8]

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	test	rbx, rbx
	jne	SHORT $LN62@use_facet
	jmp	SHORT $LN64@use_facet
$LN15@use_facet:

; 383  :         const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr; // null if id off end

	xor	ebx, ebx
$LN64@use_facet:

; 384  :         if (_Facptr != nullptr || !_Ptr->_Xparent) {

	cmp	BYTE PTR [rax+36], 0
	je	SHORT $LN12@use_facet

; 385  :             return _Facptr; // found facet or not transparent
; 386  :         } else { // look in current locale
; 387  :             locale::_Locimp* _Ptr0 = _Getgloballocale();

	call	QWORD PTR __imp_?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ

; 388  :             return _Id < _Ptr0->_Facetcount ? _Ptr0->_Facetvec[_Id] // get from current locale

	cmp	rdi, QWORD PTR [rax+24]
	jae	SHORT $LN65@use_facet
	mov	rax, QWORD PTR [rax+16]
	mov	rbx, QWORD PTR [rax+rdi*8]
$LN12@use_facet:

; 439  :     const locale::facet* _Pf = _Loc._Getfacet(_Id);
; 440  : 
; 441  :     if (_Pf == nullptr) {

	test	rbx, rbx
	jne	SHORT $LN62@use_facet
$LN65@use_facet:

; 442  :         if (_Psave != nullptr) {

	mov	rbx, QWORD PTR _Psave$20[rsp]
	test	rbx, rbx
	jne	SHORT $LN62@use_facet

; 443  :             _Pf = _Psave; // lazy facet already allocated
; 444  :         } else if (_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1)) {

	mov	rdx, rsi
	lea	rcx, QWORD PTR _Psave$20[rsp]
	call	QWORD PTR __imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
	cmp	rax, -1
	je	SHORT $LN69@use_facet

; 447  : #else // _HAS_EXCEPTIONS
; 448  :             abort(); // lazy disallowed
; 449  : #endif // _HAS_EXCEPTIONS
; 450  :         } else { // queue up lazy facet for destruction
; 451  :             auto _Pfmod = const_cast<locale::facet*>(_Psave);

	mov	rbx, QWORD PTR _Psave$20[rsp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1527 :         : _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...) { // construct from forwarded values

	mov	QWORD PTR _Psave_guard$22[rsp], rbx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xlocale

; 457  :             _Facet_Register(_Pfmod);

	mov	rcx, rbx
	call	?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z ; std::_Facet_Register

; 458  : #endif // defined(_M_CEE)
; 459  : 
; 460  :             _Pfmod->_Incref();

	mov	rax, QWORD PTR [rbx]
	mov	rcx, rbx
	call	QWORD PTR [rax+8]

; 461  :             _Facetptr<_Facet>::_Psave = _Psave;

	mov	rbx, QWORD PTR _Psave$20[rsp]
	mov	QWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB, rbx ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
$LN62@use_facet:

; 462  :             _Pf                       = _Psave;
; 463  : 
; 464  :             (void) _Psave_guard.release();
; 465  :         }
; 466  :     }
; 467  : 
; 468  :     return static_cast<const _Facet&>(*_Pf); // should be dynamic_cast

	lea	rcx, QWORD PTR _Lock$21[rsp]
	call	QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
	mov	rax, rbx

; 469  :     _END_LOCK()
; 470  : } // end of use_facet body

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	mov	rbx, QWORD PTR [rsp+120]
	mov	rsi, QWORD PTR [rsp+128]
	add	rsp, 96					; 00000060H
	pop	rdi
	ret	0
$LN69@use_facet:

; 445  : #if _HAS_EXCEPTIONS
; 446  :             _THROW(bad_cast{}); // lazy disallowed

	lea	rcx, QWORD PTR $T1[rsp]
	call	??0bad_cast@std@@QEAA@XZ		; std::bad_cast::bad_cast
	lea	rdx, OFFSET FLAT:_TI2?AVbad_cast@std@@
	lea	rcx, QWORD PTR $T1[rsp]
	call	_CxxThrowException
	int	3
$LN66@use_facet:
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
_Psave$20 = 64
_Lock$21 = 72
_Psave_guard$22 = 80
__$ArrayPad$ = 88
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Lock$21[rdx]
	rex_jmp	QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
$T1 = 40
_Psave$20 = 64
_Lock$21 = 72
_Psave_guard$22 = 80
__$ArrayPad$ = 88
_Loc$ = 112
?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Psave_guard$22[rdx]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
_Psave$20 = 64
_Lock$21 = 72
_Psave_guard$22 = 80
__$ArrayPad$ = 88
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
	lea	rcx, QWORD PTR _Lock$21[rdx]
	rex_jmp	QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
_Psave$20 = 64
_Lock$21 = 72
_Psave_guard$22 = 80
__$ArrayPad$ = 88
_Loc$ = 112
?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$1
	lea	rcx, QWORD PTR _Psave_guard$22[rdx]
	jmp	??1?$unique_ptr@V_Facet_base@std@@U?$default_delete@V_Facet_base@std@@@2@@std@@QEAA@XZ ; std::unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >::~unique_ptr<std::_Facet_base,std::default_delete<std::_Facet_base> >
?dtor$1@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z PROC			; std::_Unfancy<wchar_t>, COMDAT

; 295  :     return _Ptr;

	mov	rax, rcx

; 296  : }

	ret	0
??$_Unfancy@_W@std@@YAPEA_WPEA_W@Z ENDP			; std::_Unfancy<wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z PROC	; std::addressof<wchar_t *>, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 282  : }

	ret	0
??$addressof@PEA_W@std@@YAPEAPEA_WAEAPEA_W@Z ENDP	; std::addressof<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$destroy@PEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEAPEA_W@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEAPEA_W@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>, COMDAT

; 824  :         _Ptr->~_Uty();
; 825  :     }

	ret	0
??$destroy@PEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEAPEA_W@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::destroy<wchar_t *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z
_TEXT	SEGMENT
this$ = 96
_Size_increase$ = 104
_Fn$dead$ = 112
<_Args_0>$ = 120
<_Args_1>$dead$ = 128
??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_a3050a43f3157934f354774ab3dd2e02>,unsigned __int64,wchar_t>, COMDAT

; 3809 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN157:
	push	rdi
	push	r12
	push	r14
	push	r15
	sub	rsp, 56					; 00000038H

; 3810 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3811 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3812 :         auto& _My_data            = _Get_data();
; 3813 :         const size_type _Old_size = _My_data._Mysize;

	mov	r12, QWORD PTR [rcx+16]

; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rdi, 9223372036854775806		; 7ffffffffffffffeH
	mov	rax, rdi
	mov	r15, r9
	sub	rax, r12
	mov	r14, rcx
	cmp	rax, rdx
	jb	$LN155@Reallocate

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;
; 3819 :         const size_type _Old_capacity = _My_data._Myres;

	mov	QWORD PTR [rsp+48], rbp
	mov	rbp, QWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+40], rsi
	lea	rsi, QWORD PTR [rdx+r12]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rcx, rsi
	mov	QWORD PTR [rsp+32], r13
	or	rcx, 7
	cmp	rcx, rdi

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN24@Reallocate

; 3770 :             return _Max;
; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rdx, rbp
	mov	rax, rdi
	shr	rdx, 1
	sub	rax, rdx
	cmp	rbp, rax
	ja	SHORT $LN24@Reallocate

; 3775 :             return _Max;
; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rdx+rbp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	mov	rdi, rcx
	cmp	rcx, rax
	cmovb	rdi, rax
$LN24@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, rdi
	mov	QWORD PTR [rsp+112], rbx
	add	rax, 1
	mov	r8, -1
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	mov	rcx, 9223372036854775807		; 7fffffffffffffffH
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	cmovb	rax, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	xor	r13d, r13d
	lea	rdx, QWORD PTR [rax+rax]
	cmp	rax, rcx
	jbe	SHORT $LN55@Reallocate

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);

	mov	rdx, r8

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	jmp	SHORT $LN148@Reallocate
$LN55@Reallocate:
	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN58@Reallocate
$LN148@Reallocate:

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rdx+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	cmp	rcx, rdx
	cmovbe	rcx, r8

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN111@Reallocate

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN57@Reallocate
$LN58@Reallocate:

; 175  :     }
; 176  : #endif // defined(_M_IX86) || defined(_M_X64)
; 177  : 
; 178  :     if (_Bytes != 0) {

	test	rdx, rdx
	je	SHORT $LN59@Reallocate

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rdx
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 179  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN57@Reallocate
$LN59@Reallocate:

; 180  :     }
; 181  : 
; 182  :     return nullptr;

	mov	rbx, r13
$LN57@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3825 :         _My_data._Myres       = _New_capacity;

	mov	QWORD PTR [r14+24], rdi

; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	lea	r8, QWORD PTR [r12+r12]
	mov	QWORD PTR [r14+16], rsi
	lea	rdi, QWORD PTR [r8+rbx]

; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	rcx, rbx
	cmp	rbp, 8
	jb	SHORT $LN3@Reallocate

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rsi, QWORD PTR [r14]
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	rdx, rsi
	call	memcpy

; 259  :         for (; 0 < _N; ++_Su, --_N)

	test	r15, r15
	je	SHORT $LN96@Reallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	movzx	eax, r13w
	mov	rcx, r15
	rep stosw
$LN96@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	lea	rdx, QWORD PTR [rbp*2+2]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2646 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	lea	rax, QWORD PTR [r15+r12]

; 211  :         _Left = _Right;

	mov	WORD PTR [rbx+rax*2], r13w
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN114@Reallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rsi-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rsi, rcx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rsi-8]
	cmp	rax, 31
	ja	SHORT $LN111@Reallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rsi, rcx
$LN114@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	mov	rcx, rsi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3832 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN111@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN3@Reallocate:
; File C:\Program Files (x86)\Windows Kits\10\Include\10.0.17763.0\ucrt\wchar.h

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	mov	rdx, r14
	call	memcpy

; 259  :         for (; 0 < _N; ++_Su, --_N)

	test	r15, r15
	je	SHORT $LN128@Reallocate

; 233  :         return (wchar_t*)memcpy(_S1, _S2, _N*sizeof(wchar_t));

	movzx	eax, r13w
	mov	rcx, r15
	rep stosw
$LN128@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2646 :                 _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

	lea	rcx, QWORD PTR [r15+r12]

; 211  :         _Left = _Right;

	mov	WORD PTR [rbx+rcx*2], r13w
$LN4@Reallocate:

; 3833 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 3834 :             _Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_ptr);
; 3835 :         }
; 3836 : 
; 3837 :         return *this;

	mov	QWORD PTR [r14], rbx
	mov	rax, r14
	mov	rbx, QWORD PTR [rsp+112]
	mov	rbp, QWORD PTR [rsp+48]
	mov	rsi, QWORD PTR [rsp+40]
	mov	r13, QWORD PTR [rsp+32]

; 3838 :     }

	add	rsp, 56					; 00000038H
	pop	r15
	pop	r14
	pop	r12
	pop	rdi
	ret	0
$LN155@Reallocate:

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXXZ ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
	int	3
$LN153@Reallocate:
??$_Reallocate_grow_by@V<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEAAAEAV01@_KV<lambda_a3050a43f3157934f354774ab3dd2e02>@@_K_W@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Reallocate_grow_by<<lambda_a3050a43f3157934f354774ab3dd2e02>,unsigned __int64,wchar_t>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$construct@PEA_WAEBQEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEAPEA_WAEBQEA_W@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEA_WAEBQEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEAPEA_WAEBQEA_W@Z PROC ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * const &>, COMDAT

; 818  :     static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args) { // construct _Objty(_Types...) at _Ptr

	mov	rax, QWORD PTR [r8]
	mov	QWORD PTR [rdx], rax

; 819  :         ::new (const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(_STD forward<_Types>(_Args)...);
; 820  :     }

	ret	0
??$construct@PEA_WAEBQEA_W@?$_Default_allocator_traits@V?$allocator@_W@std@@@std@@SAXAEAV?$allocator@_W@1@QEAPEA_WAEBQEA_W@Z ENDP ; std::_Default_allocator_traits<std::allocator<wchar_t> >::construct<wchar_t *,wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z
_TEXT	SEGMENT
this$ = 48
_New_size$dead$ = 56
_Fn$dead$ = 64
<_Args_0>$dead$ = 72
??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>,char>, COMDAT

; 3782 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

$LN116:
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H

; 3783 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 3784 :         // _Fn(_New_ptr, _New_size, _Args...)
; 3785 :         if (_New_size > max_size()) {
; 3786 :             _Xlen(); // result too long
; 3787 :         }
; 3788 : 
; 3789 :         auto& _My_data                = _Get_data();
; 3790 :         const size_type _Old_capacity = _My_data._Myres;

	mov	rbp, QWORD PTR [rcx+24]
	mov	rdi, rcx

; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rcx, rbp
	mov	rsi, 9223372036854775807		; 7fffffffffffffffH
	shr	rcx, 1
	mov	rax, rsi
	sub	rax, rcx
	cmp	rbp, rax
	ja	SHORT $LN24@Reallocate

; 3775 :             return _Max;
; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rcx+rbp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	mov	esi, 32767				; 00007fffH
	cmp	rax, rsi
	cmova	rsi, rax
$LN24@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, rsi
	mov	QWORD PTR [rsp+56], rbx
	add	rax, 1
	mov	rdx, -1
	cmovb	rax, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN57@Reallocate

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	cmp	rcx, rax
	cmovbe	rcx, rdx

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN99@Reallocate

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN56@Reallocate
$LN57@Reallocate:

; 175  :     }
; 176  : #endif // defined(_M_IX86) || defined(_M_X64)
; 177  : 
; 178  :     if (_Bytes != 0) {

	test	rax, rax
	je	SHORT $LN58@Reallocate

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 179  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN56@Reallocate
$LN58@Reallocate:

; 180  :     }
; 181  : 
; 182  :     return nullptr;

	xor	ebx, ebx
$LN56@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	xor	edx, edx

; 3794 :         _My_data._Orphan_all();
; 3795 :         _My_data._Mysize = _New_size;

	mov	QWORD PTR [rdi+16], 32767		; 00007fffH

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8d, 32767				; 00007fffH

; 3796 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rdi+24], rsi

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	rcx, rbx
	call	memset

; 343  :         _Left = _Right;

	mov	BYTE PTR [rbx+32767], 0

; 3797 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 3798 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	rbp, 16
	jb	SHORT $LN3@Reallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rdi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3799 :             _Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	lea	rdx, QWORD PTR [rbp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN102@Reallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN99@Reallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN102@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3805 :         return *this;

	mov	QWORD PTR [rdi], rbx
	mov	rax, rdi
	mov	rbx, QWORD PTR [rsp+56]

; 3806 :     }

	mov	rbp, QWORD PTR [rsp+64]
	mov	rsi, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN99@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN113@Reallocate:
??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
_TEXT	SEGMENT
this$ = 80
_New_size$ = 88
_Fn$dead$ = 96
<_Args_0>$ = 104
??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>, COMDAT

; 3782 :     basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args) {

$LN119:
	push	rbx
	push	rsi
	push	r14
	push	r15
	sub	rsp, 40					; 00000028H

; 3783 :         // reallocate to store exactly _New_size elements, new buffer prepared by
; 3784 :         // _Fn(_New_ptr, _New_size, _Args...)
; 3785 :         if (_New_size > max_size()) {

	mov	rbx, 9223372036854775807		; 7fffffffffffffffH
	mov	r15, r9
	mov	r14, rdx
	mov	rsi, rcx
	cmp	rdx, rbx
	ja	$LN117@Reallocate

; 3787 :         }
; 3788 : 
; 3789 :         auto& _My_data                = _Get_data();
; 3790 :         const size_type _Old_capacity = _My_data._Myres;

	mov	QWORD PTR [rsp+96], rbp
	mov	rbp, QWORD PTR [rcx+24]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rcx, rdx
	or	rcx, 15
	cmp	rcx, rbx

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN24@Reallocate

; 3770 :             return _Max;
; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rdx, rbp
	mov	rax, rbx
	shr	rdx, 1
	sub	rax, rdx
	cmp	rbp, rax
	ja	SHORT $LN24@Reallocate

; 3775 :             return _Max;
; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rdx+rbp]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	mov	rbx, rcx
	cmp	rcx, rax
	cmovb	rbx, rax
$LN24@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3793 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, rbx
	mov	QWORD PTR [rsp+32], rdi
	add	rax, 1
	mov	rdx, -1
	cmovb	rax, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN57@Reallocate

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	cmp	rcx, rax
	cmovbe	rcx, rdx

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN99@Reallocate

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rdi, QWORD PTR [rax+39]
	and	rdi, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rdi-8], rax

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN56@Reallocate
$LN57@Reallocate:

; 175  :     }
; 176  : #endif // defined(_M_IX86) || defined(_M_X64)
; 177  : 
; 178  :     if (_Bytes != 0) {

	test	rax, rax
	je	SHORT $LN58@Reallocate

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rdi, rax

; 179  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN56@Reallocate
$LN58@Reallocate:

; 180  :     }
; 181  : 
; 182  :     return nullptr;

	xor	edi, edi
$LN56@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	r8, r14

; 3794 :         _My_data._Orphan_all();
; 3795 :         _My_data._Mysize = _New_size;

	mov	QWORD PTR [rsi+16], r14

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, r15

; 3796 :         _My_data._Myres  = _New_capacity;

	mov	QWORD PTR [rsi+24], rbx

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rcx, rdi
	call	memcpy

; 343  :         _Left = _Right;

	mov	BYTE PTR [r14+rdi], 0

; 3797 :         _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
; 3798 :         if (_BUF_SIZE <= _Old_capacity) {

	cmp	rbp, 16
	jb	SHORT $LN3@Reallocate
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	mov	rcx, QWORD PTR [rsi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3799 :             _Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

	lea	rdx, QWORD PTR [rbp+1]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN102@Reallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN99@Reallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN102@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3805 :         return *this;

	mov	QWORD PTR [rsi], rdi
	mov	rax, rsi
	mov	rdi, QWORD PTR [rsp+32]
	mov	rbp, QWORD PTR [rsp+96]

; 3806 :     }

	add	rsp, 40					; 00000028H
	pop	r15
	pop	r14
	pop	rsi
	pop	rbx
	ret	0
$LN99@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN117@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3786 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
	int	3
$LN115@Reallocate:
??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
_TEXT	SEGMENT
this$ = 96
_Size_increase$ = 104
_Fn$dead$ = 112
<_Args_0>$ = 120
<_Args_1>$dead$ = 128
??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>, COMDAT

; 3809 :     basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args) {

$LN133:
	push	rbp
	push	rsi
	push	rdi
	push	r13
	sub	rsp, 56					; 00000038H

; 3810 :         // reallocate to increase size by _Size_increase elements, new buffer prepared by
; 3811 :         // _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3812 :         auto& _My_data            = _Get_data();
; 3813 :         const size_type _Old_size = _My_data._Mysize;

	mov	rbp, QWORD PTR [rcx+16]

; 3814 :         if (max_size() - _Old_size < _Size_increase) {

	mov	rdi, 9223372036854775807		; 7fffffffffffffffH
	mov	rax, rdi
	mov	r13, r9
	sub	rax, rbp
	mov	rsi, rcx
	cmp	rax, rdx
	jb	$LN131@Reallocate

; 3816 :         }
; 3817 : 
; 3818 :         const size_type _New_size     = _Old_size + _Size_increase;
; 3819 :         const size_type _Old_capacity = _My_data._Myres;

	mov	QWORD PTR [rsp+40], r14
	mov	r14, QWORD PTR [rcx+24]
	mov	QWORD PTR [rsp+32], r15
	lea	r15, QWORD PTR [rdx+rbp]

; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	mov	rcx, r15
	or	rcx, 15
	cmp	rcx, rdi

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN24@Reallocate

; 3770 :             return _Max;
; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;
; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rdx, r14
	mov	rax, rdi
	shr	rdx, 1
	sub	rax, rdx
	cmp	r14, rax
	ja	SHORT $LN24@Reallocate

; 3775 :             return _Max;
; 3776 :         }
; 3777 : 
; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rdx+r14]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	mov	rdi, rcx
	cmp	rcx, rax
	cmovb	rdi, rax
$LN24@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3822 :         const pointer _New_ptr        = _Al.allocate(_New_capacity + 1); // throws

	mov	rax, rdi
	mov	QWORD PTR [rsp+112], rbx
	add	rax, 1
	mov	QWORD PTR [rsp+48], r12
	mov	rdx, -1
	cmovb	rax, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN57@Reallocate

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	cmp	rcx, rax
	cmovbe	rcx, rdx

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	$LN103@Reallocate

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	lea	rbx, QWORD PTR [rax+39]
	and	rbx, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rbx-8], rax

; 174  :         return _Allocate_manually_vector_aligned<_Traits>(_Bytes);

	jmp	SHORT $LN56@Reallocate
$LN57@Reallocate:

; 175  :     }
; 176  : #endif // defined(_M_IX86) || defined(_M_X64)
; 177  : 
; 178  :     if (_Bytes != 0) {

	test	rax, rax
	je	SHORT $LN58@Reallocate

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rax
	call	??2@YAPEAX_K@Z				; operator new
	mov	rbx, rax

; 179  :         return _Traits::_Allocate(_Bytes);

	jmp	SHORT $LN56@Reallocate
$LN58@Reallocate:

; 180  :     }
; 181  : 
; 182  :     return nullptr;

	xor	ebx, ebx
$LN56@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3824 :         _My_data._Mysize      = _New_size;

	mov	QWORD PTR [rsi+16], r15

; 3825 :         _My_data._Myres       = _New_capacity;
; 3826 :         _Elem* const _Raw_new = _Unfancy(_New_ptr);

	lea	r15, QWORD PTR [rbx+rbp]
	mov	QWORD PTR [rsi+24], rdi
	lea	r12, QWORD PTR [rbx+r13]

; 3827 :         if (_BUF_SIZE <= _Old_capacity) {

	mov	r8, rbp
	mov	rcx, rbx
	cmp	r14, 16
	jb	SHORT $LN3@Reallocate

; 3828 :             const pointer _Old_ptr = _My_data._Bx._Ptr;

	mov	rdi, QWORD PTR [rsi]

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, rdi
	call	memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8, r13
	xor	edx, edx
	mov	rcx, r15
	call	memset

; 3829 :             _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
; 3830 :             _Al.deallocate(_Old_ptr, _Old_capacity + 1);

	lea	rdx, QWORD PTR [r14+1]

; 343  :         _Left = _Right;

	mov	BYTE PTR [r12+rbp], 0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN106@Reallocate

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	rcx, QWORD PTR [rdi-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rdi, rcx

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rdi-8]
	cmp	rax, 31
	ja	SHORT $LN103@Reallocate

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rdi, rcx
$LN106@Reallocate:

; 195  :     ::operator delete(_Ptr, _Bytes);

	mov	rcx, rdi
	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3832 :         } else {

	jmp	SHORT $LN4@Reallocate
$LN103@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN3@Reallocate:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 310  :         return static_cast<char*>(_CSTD memcpy(_First1, _First2, _Count));

	mov	rdx, rsi
	call	memcpy

; 339  :         return static_cast<char*>(_CSTD memset(_First, _Ch, _Count));

	mov	r8, r13
	xor	edx, edx
	mov	rcx, r15
	call	memset

; 343  :         _Left = _Right;

	mov	BYTE PTR [r12+rbp], 0
$LN4@Reallocate:

; 3833 :             _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
; 3834 :             _Alty_traits::construct(_Al, _STD addressof(_My_data._Bx._Ptr), _New_ptr);
; 3835 :         }
; 3836 : 
; 3837 :         return *this;

	mov	QWORD PTR [rsi], rbx
	mov	rax, rsi
	mov	r12, QWORD PTR [rsp+48]
	mov	rbx, QWORD PTR [rsp+112]
	mov	r14, QWORD PTR [rsp+40]
	mov	r15, QWORD PTR [rsp+32]

; 3838 :     }

	add	rsp, 56					; 00000038H
	pop	r13
	pop	rdi
	pop	rsi
	pop	rbp
	ret	0
$LN131@Reallocate:

; 3815 :             _Xlen(); // result too long

	call	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@CAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
	int	3
$LN129@Reallocate:
??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
;	COMDAT ??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z PROC ; std::addressof<std::codecvt<char,char,_Mbstatet> const >, COMDAT

; 281  :     return __builtin_addressof(_Val);

	mov	rax, rcx

; 282  : }

	ret	0
??$addressof@$$CBV?$codecvt@DDU_Mbstatet@@@std@@@std@@YAPEBV?$codecvt@DDU_Mbstatet@@@0@AEBV10@@Z ENDP ; std::addressof<std::codecvt<char,char,_Mbstatet> const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPEAD0AEAV?$allocator@D@0@@Z
_TEXT	SEGMENT
_First$dead$ = 8
_Last$dead$ = 16
_Al$dead$ = 24
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPEAD0AEAV?$allocator@D@0@@Z PROC ; std::_Destroy_range<std::allocator<char> >, COMDAT

; 1087 :                             // note that this is an optimization for debug mode codegen;
; 1088 :                             // in release mode the BE removes all of this
; 1089 :     using _Val = typename _Alloc::value_type;
; 1090 :     if
; 1091 :         _CONSTEXPR_IF(conjunction_v<is_trivially_destructible<_Val>, _Uses_default_destroy<_Alloc, _Val*>>) {
; 1092 :             (void) _First;
; 1093 :             (void) _Last;
; 1094 :             (void) _Al;
; 1095 :         }
; 1096 :     else {
; 1097 :         for (; _First != _Last; ++_First) {
; 1098 :             allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
; 1099 :         }
; 1100 :     }
; 1101 : }

	ret	0
??$_Destroy_range@V?$allocator@D@std@@@std@@YAXPEAD0AEAV?$allocator@D@0@@Z ENDP ; std::_Destroy_range<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$01@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 8
??$_Get_size_of_n@$01@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<2>, COMDAT

; 24   :     constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 25   :     size_t _Result                 = _Count * _Ty_size;
; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	mov	rdx, 9223372036854775807		; 7fffffffffffffffH
	lea	rax, QWORD PTR [rcx+rcx]
	cmp	rcx, rdx
	mov	r8, -1
	cmova	rax, r8

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);
; 29   :     }
; 30   : 
; 31   :     return _Result;
; 32   : }

	ret	0
??$_Get_size_of_n@$01@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<2>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_Vector_val<std::_Simple_types<char> >::_Vector_val<std::_Simple_types<char> >, COMDAT

; 318  :     _Vector_val() : _Myfirst(), _Mylast(), _Myend() { // initialize values

	xor	eax, eax
	mov	QWORD PTR [rcx], rax
	mov	QWORD PTR [rcx+8], rax
	mov	QWORD PTR [rcx+16], rax

; 319  :     }

	mov	rax, rcx
	ret	0
??0?$_Vector_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_Vector_val<std::_Simple_types<char> >::_Vector_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??1?$_Tidy_guard@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$_Tidy_guard@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ PROC ; std::_Tidy_guard<std::vector<char,std::allocator<char> > >::~_Tidy_guard<std::vector<char,std::allocator<char> > >, COMDAT

; 3513 :     ~_Tidy_guard() {

$LN53:
	push	rbx
	sub	rsp, 32					; 00000020H

; 3514 :         if (_Target) {

	mov	rbx, QWORD PTR [rcx]
	test	rbx, rbx
	je	SHORT $LN5@Tidy_guard
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1525 :         const auto _First = _My_data._Myfirst;

	mov	rcx, QWORD PTR [rbx]

; 1526 :         if (_First != pointer()) { // destroy and deallocate old array

	test	rcx, rcx
	je	SHORT $LN5@Tidy_guard

; 1527 :             _Destroy(_First, _My_data._Mylast);
; 1528 :             _Getal().deallocate(_First, static_cast<size_type>(_My_data._Myend - _First));

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN45@Tidy_guard

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN42@Tidy_guard

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN45@Tidy_guard:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1530 :             _My_data._Myfirst = pointer();

	xor	eax, eax
	mov	QWORD PTR [rbx], rax

; 1531 :             _My_data._Mylast  = pointer();

	mov	QWORD PTR [rbx+8], rax

; 1532 :             _My_data._Myend   = pointer();

	mov	QWORD PTR [rbx+16], rax
$LN5@Tidy_guard:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 3517 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
$LN42@Tidy_guard:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN50@Tidy_guard:
??1?$_Tidy_guard@V?$vector@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ENDP ; std::_Tidy_guard<std::vector<char,std::allocator<char> > >::~_Tidy_guard<std::vector<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Mylast@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Mylast@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAPEADXZ PROC ; std::vector<char,std::allocator<char> >::_Mylast, COMDAT

; 1623 :         return _Get_data()._Mylast;

	lea	rax, QWORD PTR [rcx+8]

; 1624 :     }

	ret	0
?_Mylast@?$vector@DV?$allocator@D@std@@@std@@AEAAAEAPEADXZ ENDP ; std::vector<char,std::allocator<char> >::_Mylast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Buy_nonzero@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$dead$ = 56
?_Buy_nonzero@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z PROC ; std::vector<char,std::allocator<char> >::_Buy_nonzero, COMDAT

; 1498 :     void _Buy_nonzero(const size_type _Newcapacity) { // allocate array with _Newcapacity elements

$LN56:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	mov	ecx, 800				; 00000320H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	mov	QWORD PTR [rbx], rax

; 1494 :         _My_data._Mylast  = _My_data._Myfirst;

	mov	QWORD PTR [rbx+8], rax

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	add	rax, 800				; 00000320H
	mov	QWORD PTR [rbx+16], rax

; 1499 :                                                       // pre: *this is _Tidy
; 1500 :                                                       // pre: _Newcapacity != 0
; 1501 :         if (_Newcapacity > max_size()) {
; 1502 :             _Xlength();
; 1503 :         }
; 1504 : 
; 1505 :         _Buy_raw(_Newcapacity);
; 1506 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Buy_nonzero@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z ENDP ; std::vector<char,std::allocator<char> >::_Buy_nonzero
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Ufill@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADPEAD_KU_Value_init_tag@2@@Z
_TEXT	SEGMENT
this$dead$ = 48
_Dest$ = 56
_Count$dead$ = 64
__formal$dead$ = 72
?_Ufill@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADPEAD_KU_Value_init_tag@2@@Z PROC ; std::vector<char,std::allocator<char> >::_Ufill, COMDAT

; 1438 :         _Value_init_tag) { // fill raw _Dest with _Count value-initialized objects, using allocator

$LN15:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8d, 800				; 00000320H
	mov	rcx, rbx
	xor	edx, edx
	call	memset

; 332  :     return _Zero_range(_First, _First + _Count);

	lea	rax, QWORD PTR [rbx+800]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1440 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Ufill@?$vector@DV?$allocator@D@std@@@std@@AEAAPEADPEAD_KU_Value_init_tag@2@@Z ENDP ; std::vector<char,std::allocator<char> >::_Ufill
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myfirst@?$vector@NV?$allocator@N@std@@@std@@AEAAAEAPEANXZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$vector@NV?$allocator@N@std@@@std@@AEAAAEAPEANXZ PROC ; std::vector<double,std::allocator<double> >::_Myfirst, COMDAT

; 1615 :         return _Get_data()._Myfirst;

	mov	rax, rcx

; 1616 :     }

	ret	0
?_Myfirst@?$vector@NV?$allocator@N@std@@@std@@AEAAAEAPEANXZ ENDP ; std::vector<double,std::allocator<double> >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ PROC ; std::vector<double,std::allocator<double> >::_Xlength, COMDAT

; 1536 :     [[noreturn]] static void _Xlength() { // report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1537 :         _Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@NV?$allocator@N@std@@@std@@CAXXZ ENDP ; std::vector<double,std::allocator<double> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Change_array@?$vector@NV?$allocator@N@std@@@std@@AEAAXQEAN_K1@Z
_TEXT	SEGMENT
this$ = 48
_Newvec$ = 56
_Newsize$ = 64
_Newcapacity$ = 72
?_Change_array@?$vector@NV?$allocator@N@std@@@std@@AEAAXQEAN_K1@Z PROC ; std::vector<double,std::allocator<double> >::_Change_array, COMDAT

; 1509 :         const size_type _Newcapacity) { // orphan all iterators, discard old array, acquire new array

$LN101:
	mov	QWORD PTR [rsp+16], rbx
	mov	QWORD PTR [rsp+24], rbp
	mov	QWORD PTR [rsp+32], rsi
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
	mov	rsi, r9

; 1510 :         _Orphan_all();
; 1511 : 
; 1512 :         if (_Myfirst() != pointer()) { // destroy and deallocate old array

	mov	rcx, QWORD PTR [rcx]
	mov	rbp, r8
	mov	rdi, rdx
	test	rcx, rcx
	je	SHORT $LN66@Change_arr

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	rdx, QWORD PTR [rbx+16]
	sub	rdx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 925  :         _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);

	and	rdx, -8

; 190  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	cmp	rdx, 4096				; 00001000H
	jb	SHORT $LN76@Change_arr

; 110  :     const uintptr_t _Ptr_container   = _Ptr_user[-1];

	mov	r8, QWORD PTR [rcx-8]
	add	rdx, 39					; 00000027H

; 111  : 
; 112  :     // If the following asserts, it likely means that we are performing
; 113  :     // an aligned delete on memory coming from an unaligned allocation.
; 114  :     _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");
; 115  : 
; 116  :     // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
; 117  :     // in range [_Min_back_shift, _Non_user_size]
; 118  : #ifdef _DEBUG
; 119  :     constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);
; 120  : #else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
; 121  :     constexpr uintptr_t _Min_back_shift = sizeof(void*);
; 122  : #endif // _DEBUG
; 123  :     const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;

	sub	rcx, r8

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	lea	rax, QWORD PTR [rcx-8]
	cmp	rax, 31
	ja	SHORT $LN73@Change_arr

; 125  :     _Ptr = reinterpret_cast<void*>(_Ptr_container);

	mov	rcx, r8
$LN76@Change_arr:

; 195  :     ::operator delete(_Ptr, _Bytes);

	call	??3@YAXPEAX_K@Z				; operator delete
$LN66@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1518 :         _Mylast()  = _Newvec + _Newsize;

	lea	rax, QWORD PTR [rdi+rbp*8]
	mov	QWORD PTR [rbx], rdi

; 1520 :     }

	mov	rbp, QWORD PTR [rsp+64]
	mov	QWORD PTR [rbx+8], rax
	lea	rax, QWORD PTR [rdi+rsi*8]
	mov	rsi, QWORD PTR [rsp+72]
	mov	QWORD PTR [rbx+16], rax
	mov	rbx, QWORD PTR [rsp+56]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
$LN73@Change_arr:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 124  :     _STL_VERIFY(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size, "invalid argument");

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN98@Change_arr:
?_Change_array@?$vector@NV?$allocator@N@std@@@std@@AEAAXQEAN_K1@Z ENDP ; std::vector<double,std::allocator<double> >::_Change_array
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Calculate_growth@?$vector@NV?$allocator@N@std@@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$ = 16
?_Calculate_growth@?$vector@NV?$allocator@N@std@@@std@@AEBA_K_K@Z PROC ; std::vector<double,std::allocator<double> >::_Calculate_growth, COMDAT

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	r8, QWORD PTR [rcx+16]

; 1473 :         const size_type _Oldcapacity = capacity();
; 1474 : 
; 1475 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	sub	r8, QWORD PTR [rcx]
	sar	r8, 3

; 1473 :         const size_type _Oldcapacity = capacity();
; 1474 : 
; 1475 :         if (_Oldcapacity > max_size() - _Oldcapacity / 2) {

	mov	rcx, r8
	shr	rcx, 1
	sub	rax, rcx
	cmp	r8, rax
	ja	SHORT $LN31@Calculate_

; 1476 :             return _Newsize; // geometric growth would overflow
; 1477 :         }
; 1478 : 
; 1479 :         const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

	lea	rax, QWORD PTR [rcx+r8]

; 1480 : 
; 1481 :         if (_Geometric < _Newsize) {

	cmp	rax, rdx
	jae	SHORT $LN1@Calculate_
$LN31@Calculate_:

; 1482 :             return _Newsize; // geometric growth would be insufficient

	mov	rax, rdx
$LN1@Calculate_:

; 1483 :         }
; 1484 : 
; 1485 :         return _Geometric; // geometric growth is sufficient
; 1486 :     }

	ret	0
?_Calculate_growth@?$vector@NV?$allocator@N@std@@@std@@AEBA_K_K@Z ENDP ; std::vector<double,std::allocator<double> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Umove_if_noexcept@?$vector@NV?$allocator@N@std@@@std@@AEAAXPEAN00@Z
_TEXT	SEGMENT
__$ArrayPad$ = 32
this$dead$ = 64
_First$ = 72
_Last$ = 80
_Dest$ = 88
?_Umove_if_noexcept@?$vector@NV?$allocator@N@std@@@std@@AEAAXPEAN00@Z PROC ; std::vector<double,std::allocator<double> >::_Umove_if_noexcept, COMDAT

; 1462 :         pointer _Dest) { // move_if_noexcept [_First, _Last) to raw _Dest, using allocator

$LN25:
	sub	rsp, 56					; 00000038H
	mov	rax, QWORD PTR __security_cookie
	xor	rax, rsp
	mov	QWORD PTR __$ArrayPad$[rsp], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	call	memmove
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1465 :     }

	mov	rcx, QWORD PTR __$ArrayPad$[rsp]
	xor	rcx, rsp
	call	__security_check_cookie
	add	rsp, 56					; 00000038H
	ret	0
?_Umove_if_noexcept@?$vector@NV?$allocator@N@std@@@std@@AEAAXPEAN00@Z ENDP ; std::vector<double,std::allocator<double> >::_Umove_if_noexcept
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Umove@?$vector@NV?$allocator@N@std@@@std@@AEAAPEANPEAN00@Z
_TEXT	SEGMENT
this$dead$ = 48
_First$ = 56
_Last$ = 64
_Dest$ = 72
?_Umove@?$vector@NV?$allocator@N@std@@@std@@AEAAPEANPEAN00@Z PROC ; std::vector<double,std::allocator<double> >::_Umove, COMDAT

; 1447 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

$LN23:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	sub	rbx, rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1447 :     pointer _Umove(pointer _First, pointer _Last, pointer _Dest) { // move [_First, _Last) to raw _Dest, using allocator

	mov	rdi, r9
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	r8, rbx
	call	memmove

; 1767 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1449 :     }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
?_Umove@?$vector@NV?$allocator@N@std@@@std@@AEAAPEANPEAN00@Z ENDP ; std::vector<double,std::allocator<double> >::_Umove
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?max_size@?$vector@NV?$allocator@N@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@NV?$allocator@N@std@@@std@@QEBA_KXZ PROC ; std::vector<double,std::allocator<double> >::max_size, COMDAT

; 1343 :         return _Min_value(

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 1344 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1345 :     }

	ret	0
?max_size@?$vector@NV?$allocator@N@std@@@std@@QEBA_KXZ ENDP ; std::vector<double,std::allocator<double> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?size@?$vector@NV?$allocator@N@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$vector@NV?$allocator@N@std@@@std@@QEBA_KXZ PROC	; std::vector<double,std::allocator<double> >::size, COMDAT

; 1339 :         return static_cast<size_type>(_Mylast() - _Myfirst());

	mov	rax, QWORD PTR [rcx+8]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1340 :     }

	ret	0
?size@?$vector@NV?$allocator@N@std@@@std@@QEBA_KXZ ENDP	; std::vector<double,std::allocator<double> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?allocate@?$allocator@N@std@@QEAAPEAN_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@N@std@@QEAAPEAN_K@Z PROC		; std::allocator<double>::allocate, COMDAT

; 929  :         _CRT_GUARDOVERFLOW const size_t _Count) { // allocate array of _Count elements

$LN31:
	sub	rsp, 40					; 00000028H

; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	mov	rcx, 2305843009213693951		; 1fffffffffffffffH
	lea	rax, QWORD PTR [rdx*8]
	mov	r8, -1
	cmp	rdx, rcx
	jbe	SHORT $LN4@allocate

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);

	mov	rax, r8

; 173  :     if (_Bytes >= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization

	jmp	SHORT $LN27@allocate
$LN4@allocate:
	cmp	rax, 4096				; 00001000H
	jb	SHORT $LN7@allocate
$LN27@allocate:

; 87   :     size_t _Block_size = _Non_user_size + _Bytes;

	lea	rcx, QWORD PTR [rax+39]

; 88   :     if (_Block_size <= _Bytes) { // add overflow, try allocating all of memory and assume the

	cmp	rcx, rax
	cmovbe	rcx, r8

; 49   :         return ::operator new(_Bytes);

	call	??2@YAPEAX_K@Z				; operator new
	mov	rcx, rax

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	test	rax, rax
	je	SHORT $LN16@allocate

; 95   :     void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));

	add	rax, 39					; 00000027H
	and	rax, -32				; ffffffffffffffe0H

; 96   :     static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

	mov	QWORD PTR [rax-8], rcx

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN16@allocate:

; 94   :     _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]

	call	QWORD PTR __imp__invalid_parameter_noinfo_noreturn
	int	3
$LN7@allocate:

; 178  :     if (_Bytes != 0) {

	test	rax, rax
	je	SHORT $LN8@allocate

; 49   :         return ::operator new(_Bytes);

	mov	rcx, rax

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	add	rsp, 40					; 00000028H

; 49   :         return ::operator new(_Bytes);

	jmp	??2@YAPEAX_K@Z				; operator new
$LN8@allocate:

; 930  :         return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
; 931  :     }

	add	rsp, 40					; 00000028H
	ret	0
$LN28@allocate:
?allocate@?$allocator@N@std@@QEAAPEAN_K@Z ENDP		; std::allocator<double>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >, COMDAT

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax

; 2003 :     }

	mov	rax, rcx
	ret	0
??0?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_String_val<std::_Simple_types<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXXZ PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen, COMDAT

; 3885 :     [[noreturn]] static void _Xlen() { // report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 3886 :         _Xlength_error("string too long");

	lea	rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlen:
?_Xlen@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@CAXXZ ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Requested$ = 16
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z PROC ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth, COMDAT

; 3766 :         const size_type _Max    = max_size();
; 3767 :         auto& _My_data          = _Get_data();
; 3768 :         const size_type _Masked = _Requested | _ALLOC_MASK;

	or	rdx, 7
	mov	r9, 9223372036854775806			; 7ffffffffffffffeH
	cmp	rdx, r9

; 3769 :         if (_Masked > _Max) { // the mask overflows, settle for max_size()

	ja	SHORT $LN25@Calculate_

; 3770 :             return _Max;
; 3771 :         }
; 3772 : 
; 3773 :         const size_type _Old = _My_data._Myres;

	mov	r8, QWORD PTR [rcx+24]

; 3774 :         if (_Old > _Max - _Old / 2) { // similarly, geometric overflows

	mov	rax, r9
	mov	rcx, r8
	shr	rcx, 1
	sub	rax, rcx
	cmp	r8, rax
	ja	SHORT $LN25@Calculate_

; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	lea	rax, QWORD PTR [rcx+r8]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\utility

; 28   :     return _Left < _Right ? _Right : _Left;

	cmp	rdx, rax
	cmovb	rdx, rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3778 :         return _Max_value(_Masked, _Old + _Old / 2);

	mov	rax, rdx

; 3779 :     }

	ret	0
$LN25@Calculate_:

; 3775 :             return _Max;

	mov	rax, r9

; 3779 :     }

	ret	0
?_Calculate_growth@?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@std@@AEBA_K_K@Z ENDP ; std::basic_string<wchar_t,std::char_traits<wchar_t>,std::allocator<wchar_t> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$dead$ = 16
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3861 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rcx+16], 0

; 2167 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct empty string with allocator
; 2168 :         _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2169 :         _Tidy_init();
; 2170 :     }

	mov	rax, rcx

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rcx+24], 15

; 343  :         _Left = _Right;

	mov	BYTE PTR [rcx], 0

; 2167 :         : _Mypair(_One_then_variadic_args_t(), _Al) { // construct empty string with allocator
; 2168 :         _Get_data()._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
; 2169 :         _Tidy_init();
; 2170 :     }

	ret	0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ
_TEXT	SEGMENT
?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ PROC ; std::vector<char,std::allocator<char> >::_Xlength, COMDAT

; 1536 :     [[noreturn]] static void _Xlength() { // report a length_error

$LN4:
	sub	rsp, 40					; 00000028H

; 1537 :         _Xlength_error("vector<T> too long");

	lea	rcx, OFFSET FLAT:??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long@
	call	QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
	int	3
$LN3@Xlength:
?_Xlength@?$vector@DV?$allocator@D@std@@@std@@CAXXZ ENDP ; std::vector<char,std::allocator<char> >::_Xlength
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Buy_raw@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcapacity$dead$ = 56
?_Buy_raw@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z PROC ; std::vector<char,std::allocator<char> >::_Buy_raw, COMDAT

; 1489 :     void _Buy_raw(const size_type _Newcapacity) { // allocate array with _Newcapacity elements

$LN40:
	push	rbx
	sub	rsp, 32					; 00000020H
	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 49   :         return ::operator new(_Bytes);

	mov	ecx, 800				; 00000320H
	call	??2@YAPEAX_K@Z				; operator new
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector

; 1493 :         _My_data._Myfirst = _Getal().allocate(_Newcapacity);

	mov	QWORD PTR [rbx], rax

; 1494 :         _My_data._Mylast  = _My_data._Myfirst;

	mov	QWORD PTR [rbx+8], rax

; 1495 :         _My_data._Myend   = _My_data._Myfirst + _Newcapacity;

	add	rax, 800				; 00000320H
	mov	QWORD PTR [rbx+16], rax

; 1496 :     }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
?_Buy_raw@?$vector@DV?$allocator@D@std@@@std@@AEAAX_K@Z ENDP ; std::vector<char,std::allocator<char> >::_Buy_raw
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?max_size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ PROC ; std::vector<char,std::allocator<char> >::max_size, COMDAT

; 1343 :         return _Min_value(

	mov	rax, 9223372036854775807		; 7fffffffffffffffH

; 1344 :             static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
; 1345 :     }

	ret	0
?max_size@?$vector@DV?$allocator@D@std@@@std@@QEBA_KXZ ENDP ; std::vector<char,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@N@std@@@std@@SA_KAEBV?$allocator@N@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@N@std@@@std@@SA_KAEBV?$allocator@N@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<double> >::max_size, COMDAT

; 828  :         return static_cast<size_t>(-1) / sizeof(value_type);

	mov	rax, 2305843009213693951		; 1fffffffffffffffH

; 829  :     }

	ret	0
?max_size@?$_Default_allocator_traits@V?$allocator@N@std@@@std@@SA_KAEBV?$allocator@N@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<double> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myend@?$vector@NV?$allocator@N@std@@@std@@AEAAAEAPEANXZ
_TEXT	SEGMENT
this$ = 8
?_Myend@?$vector@NV?$allocator@N@std@@@std@@AEAAAEAPEANXZ PROC ; std::vector<double,std::allocator<double> >::_Myend, COMDAT

; 1631 :         return _Get_data()._Myend;

	lea	rax, QWORD PTR [rcx+16]

; 1632 :     }

	ret	0
?_Myend@?$vector@NV?$allocator@N@std@@@std@@AEAAAEAPEANXZ ENDP ; std::vector<double,std::allocator<double> >::_Myend
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Myfirst@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBQEANXZ
_TEXT	SEGMENT
this$ = 8
?_Myfirst@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBQEANXZ PROC ; std::vector<double,std::allocator<double> >::_Myfirst, COMDAT

; 1619 :         return _Get_data()._Myfirst;

	mov	rax, rcx

; 1620 :     }

	ret	0
?_Myfirst@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBQEANXZ ENDP ; std::vector<double,std::allocator<double> >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Getal@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBV?$allocator@N@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBV?$allocator@N@2@XZ PROC ; std::vector<double,std::allocator<double> >::_Getal, COMDAT

; 1593 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1594 :     }

	ret	0
?_Getal@?$vector@NV?$allocator@N@std@@@std@@AEBAAEBV?$allocator@N@2@XZ ENDP ; std::vector<double,std::allocator<double> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Umove_if_noexcept1@?$vector@NV?$allocator@N@std@@@std@@AEAAXPEAN00U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_First$ = 16
_Last$ = 24
_Dest$ = 32
__formal$dead$ = 40
?_Umove_if_noexcept1@?$vector@NV?$allocator@N@std@@@std@@AEAAXPEAN00U?$integral_constant@_N$00@2@@Z PROC ; std::vector<double,std::allocator<double> >::_Umove_if_noexcept1, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	r8, rdx

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rcx, r9
	jmp	memmove
?_Umove_if_noexcept1@?$vector@NV?$allocator@N@std@@@std@@AEAAXPEAN00U?$integral_constant@_N$00@2@@Z ENDP ; std::vector<double,std::allocator<double> >::_Umove_if_noexcept1
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?capacity@?$vector@NV?$allocator@N@std@@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$vector@NV?$allocator@N@std@@@std@@QEBA_KXZ PROC ; std::vector<double,std::allocator<double> >::capacity, COMDAT

; 1348 :         return static_cast<size_type>(_Myend() - _Myfirst());

	mov	rax, QWORD PTR [rcx+16]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 1349 :     }

	ret	0
?capacity@?$vector@NV?$allocator@N@std@@@std@@QEBA_KXZ ENDP ; std::vector<double,std::allocator<double> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty, COMDAT

; 2058 :         }

	mov	rax, rcx
	ret	0
??0_Bxty@?$_String_val@U?$_Simple_types@_W@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<wchar_t> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\vector
;	COMDAT ?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEBAAEBV?$allocator@D@2@XZ PROC ; std::vector<char,std::allocator<char> >::_Getal, COMDAT

; 1593 :         return _Mypair._Get_first();

	mov	rax, rcx

; 1594 :     }

	ret	0
?_Getal@?$vector@DV?$allocator@D@std@@@std@@AEBAAEBV?$allocator@D@2@XZ ENDP ; std::vector<char,std::allocator<char> >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QEBAAEBV?$allocator@N@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QEBAAEBV?$allocator@N@2@XZ PROC ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_first, COMDAT

; 1541 :         return *this;

	mov	rax, rcx

; 1542 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@N@std@@V?$_Vector_val@U?$_Simple_types@N@std@@@2@$00@std@@QEBAAEBV?$allocator@N@2@XZ ENDP ; std::_Compressed_pair<std::allocator<double>,std::_Vector_val<std::_Simple_types<double> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 1541 :         return *this;

	mov	rax, rcx

; 1542 :     }

	ret	0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_Vector_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_Vector_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??$_Immortalize_impl@V_Generic_error_category@std@@@std@@YAHPEAX0PEAPEAX@Z
_TEXT	SEGMENT
__formal$ = 8
_Storage_ptr$ = 16
__formal$ = 24
??$_Immortalize_impl@V_Generic_error_category@std@@@std@@YAHPEAX0PEAPEAX@Z PROC ; std::_Immortalize_impl<std::_Generic_error_category>, COMDAT

; 404  :     _Generic_error_category() noexcept { // default constructor

	lea	rax, OFFSET FLAT:??_7_Generic_error_category@std@@6B@

; 405  :         _Addr = _Generic_addr;

	mov	QWORD PTR [rdx+8], 3
	mov	QWORD PTR [rdx], rax

; 496  :     ::new (_Storage_ptr) _Ty();
; 497  :     return 1;

	mov	eax, 1

; 498  : }

	ret	0
??$_Immortalize_impl@V_Generic_error_category@std@@@std@@YAHPEAX0PEAPEAX@Z ENDP ; std::_Immortalize_impl<std::_Generic_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\system_error
;	COMDAT ??$_Immortalize_impl@V_System_error_category@std@@@std@@YAHPEAX0PEAPEAX@Z
_TEXT	SEGMENT
__formal$ = 8
_Storage_ptr$ = 16
__formal$ = 24
??$_Immortalize_impl@V_System_error_category@std@@@std@@YAHPEAX0PEAPEAX@Z PROC ; std::_Immortalize_impl<std::_System_error_category>, COMDAT

; 440  :     _System_error_category() noexcept { // default constructor

	lea	rax, OFFSET FLAT:??_7_System_error_category@std@@6B@

; 441  :         _Addr = _System_addr;

	mov	QWORD PTR [rdx+8], 7
	mov	QWORD PTR [rdx], rax

; 496  :     ::new (_Storage_ptr) _Ty();
; 497  :     return 1;

	mov	eax, 1

; 498  : }

	ret	0
??$_Immortalize_impl@V_System_error_category@std@@@std@@YAHPEAX0PEAPEAX@Z ENDP ; std::_Immortalize_impl<std::_System_error_category>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ??$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
$T1 = 48
$T25 = 64
$T16 = 64
$T3 = 64
$T28 = 80
__$ReturnUdt$GSCopy$ = 88
$T15 = 96
$T24 = 112
$T17 = 128
$T26 = 168
__$ReturnUdt$ = 240
_Input$ = 248
_Al$dead$ = 256
??$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z PROC ; std::filesystem::_Convert_wide_to<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 162  :         const wstring_view _Input, const _Alloc& _Al) {

$LN73:
	mov	rax, rsp
	push	rsi
	push	rdi
	push	r14
	sub	rsp, 208				; 000000d0H
	mov	QWORD PTR $T28[rsp], -2
	mov	QWORD PTR [rax+24], rbx
	mov	QWORD PTR [rax+32], rbp
	mov	rbx, rdx
	mov	rdi, rcx
	mov	QWORD PTR __$ReturnUdt$GSCopy$[rsp], rcx
	xor	ebp, ebp
	mov	DWORD PTR $T1[rsp], ebp

; 163  :         if constexpr (is_same_v<_EcharT, char>) {
; 164  :             return _Convert_wide_to_narrow<_Traits>(__std_fs_code_page(), _Input, _Al);

	vmovups	xmm0, XMMWORD PTR [rdx]
	vmovups	XMMWORD PTR $T3[rsp], xmm0
	call	__std_fs_code_page
	mov	r14d, eax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3861 :         _My_data._Mysize = 0;

	mov	QWORD PTR [rdi+16], rbp

; 3862 :         _My_data._Myres  = _BUF_SIZE - 1;

	mov	QWORD PTR [rdi+24], 15

; 343  :         _Left = _Right;

	mov	BYTE PTR [rdi], bpl
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 95   :         return _Output;

	mov	DWORD PTR $T1[rsp], 2

; 51   :         }
; 52   : 
; 53   :         return _Result._Len;
; 54   :     }
; 55   : 
; 56   :     _NODISCARD inline wstring _Convert_narrow_to_wide(const __std_code_page _Code_page, const string_view _Input) {
; 57   :         wstring _Output;
; 58   : 
; 59   :         if (!_Input.empty()) {
; 60   :             if (_Input.size() > static_cast<size_t>(INT_MAX)) {
; 61   :                 _Xsystem_error_invalid_argument();
; 62   :             }
; 63   : 
; 64   :             const int _Len = _Check_convert_result(__std_fs_convert_narrow_to_wide(
; 65   :                 _Code_page, _Input.data(), static_cast<int>(_Input.size()), nullptr, 0));
; 66   : 
; 67   :             _Output.resize(static_cast<size_t>(_Len));
; 68   : 
; 69   :             (void) _Check_convert_result(__std_fs_convert_narrow_to_wide(
; 70   :                 _Code_page, _Input.data(), static_cast<int>(_Input.size()), _Output.data(), _Len));
; 71   :         }
; 72   : 
; 73   :         return _Output;
; 74   :     }
; 75   : 
; 76   :     template <class _Traits, class _Alloc>
; 77   :     _NODISCARD inline basic_string<char, _Traits, _Alloc> _Convert_wide_to_narrow(
; 78   :         const __std_code_page _Code_page, const wstring_view _Input, const _Alloc& _Al) {
; 79   :         basic_string<char, _Traits, _Alloc> _Output(_Al);
; 80   : 
; 81   :         if (!_Input.empty()) {

	vmovups	xmm0, XMMWORD PTR [rbx]
	vpextrq	rsi, xmm0, 1
	test	rsi, rsi
	je	SHORT $LN64@Convert_wi

; 82   :             if (_Input.size() > static_cast<size_t>(INT_MAX)) {

	cmp	rsi, 2147483647				; 7fffffffH
	ja	$LN69@Convert_wi

; 84   :             }
; 85   : 
; 86   :             const int _Len = _Check_convert_result(__std_fs_convert_wide_to_narrow(

	mov	DWORD PTR [rsp+32], ebp
	xor	r9d, r9d
	mov	r8d, esi
	mov	rbp, QWORD PTR $T3[rsp]
	mov	rdx, rbp
	mov	ecx, eax
	call	__std_fs_convert_wide_to_narrow
	mov	rbx, rax

; 49   :         if (_Result._Err != __std_win_error::_Success) {

	shr	rax, 32					; 00000020H
	test	eax, eax
	jne	$LN70@Convert_wi

; 89   :             _Output.resize(static_cast<size_t>(_Len));

	movsxd	rdx, ebx
	mov	rcx, rdi
	call	?resize@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::resize
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2014 :         value_type* _Result = _Bx._Buf;

	mov	r9, rdi

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdi+24], 16

; 2015 :         if (_Large_string_engaged()) {

	jb	SHORT $LN53@Convert_wi
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	r9, QWORD PTR [rdi]
$LN53@Convert_wi:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 91   :             (void) _Check_convert_result(__std_fs_convert_wide_to_narrow(

	mov	DWORD PTR [rsp+32], ebx
	mov	r8d, esi
	mov	rdx, rbp
	mov	ecx, r14d
	call	__std_fs_convert_wide_to_narrow

; 49   :         if (_Result._Err != __std_win_error::_Success) {

	shr	rax, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN71@Convert_wi
$LN64@Convert_wi:

; 163  :         if constexpr (is_same_v<_EcharT, char>) {
; 164  :             return _Convert_wide_to_narrow<_Traits>(__std_fs_code_page(), _Input, _Al);

	mov	rax, rdi

; 165  :         } else if constexpr (is_same_v<_EcharT, char32_t>) {
; 166  :             return _Convert_wide_to_utf32<_Traits>(_Input, _Al);
; 167  :         } else { // wchar_t, char16_t
; 168  :             return basic_string<_EcharT, _Traits, _Alloc>(_Input.data(), _Input.data() + _Input.size(), _Al);
; 169  :         }
; 170  :     }

	lea	r11, QWORD PTR [rsp+208]
	mov	rbx, QWORD PTR [r11+48]
	mov	rbp, QWORD PTR [r11+56]
	mov	rsp, r11
	pop	r14
	pop	rdi
	pop	rsi
	ret	0
$LN71@Convert_wi:

; 50   :             _THROW(system_error(_Make_ec(_Result._Err)));

	mov	edx, eax
	lea	rcx, QWORD PTR $T24[rsp]
	call	?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z ; std::filesystem::_Make_ec
	vmovups	xmm0, XMMWORD PTR [rax]
	vmovups	XMMWORD PTR $T25[rsp], xmm0
	lea	rdx, QWORD PTR $T25[rsp]
	lea	rcx, QWORD PTR $T26[rsp]
	call	??0system_error@std@@QEAA@Verror_code@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T26[rsp]
	call	_CxxThrowException
	int	3
$LN69@Convert_wi:

; 83   :                 _Xsystem_error_invalid_argument();

	call	?_Xsystem_error_invalid_argument@filesystem@std@@YAXXZ ; std::filesystem::_Xsystem_error_invalid_argument
	int	3
$LN70@Convert_wi:

; 50   :             _THROW(system_error(_Make_ec(_Result._Err)));

	mov	edx, eax
	lea	rcx, QWORD PTR $T15[rsp]
	call	?_Make_ec@filesystem@std@@YA?AVerror_code@2@W4__std_win_error@@@Z ; std::filesystem::_Make_ec
	vmovups	xmm0, XMMWORD PTR [rax]
	vmovups	XMMWORD PTR $T16[rsp], xmm0
	lea	rdx, QWORD PTR $T16[rsp]
	lea	rcx, QWORD PTR $T17[rsp]
	call	??0system_error@std@@QEAA@Verror_code@1@@Z ; std::system_error::system_error
	lea	rdx, OFFSET FLAT:_TI4?AVsystem_error@std@@
	lea	rcx, QWORD PTR $T17[rsp]
	call	_CxxThrowException
	int	3
$LN67@Convert_wi:
??$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z ENDP ; std::filesystem::_Convert_wide_to<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T25 = 64
$T16 = 64
$T3 = 64
$T28 = 80
__$ReturnUdt$GSCopy$ = 88
$T15 = 96
$T24 = 112
$T17 = 128
$T26 = 168
__$ReturnUdt$ = 240
_Input$ = 248
_Al$dead$ = 256
?dtor$1@?0???$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA PROC ; `std::filesystem::_Convert_wide_to<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN10@dtor$1
	and	DWORD PTR $T1[rbp], -3
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN10@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::filesystem::_Convert_wide_to<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 48
$T25 = 64
$T16 = 64
$T3 = 64
$T28 = 80
__$ReturnUdt$GSCopy$ = 88
$T15 = 96
$T24 = 112
$T17 = 128
$T26 = 168
__$ReturnUdt$ = 240
_Input$ = 248
_Al$dead$ = 256
?dtor$1@?0???$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA PROC ; `std::filesystem::_Convert_wide_to<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
	push	rbp
	sub	rsp, 32					; 00000020H
	mov	rbp, rdx
	mov	eax, DWORD PTR $T1[rbp]
	and	eax, 2
	test	eax, eax
	je	SHORT $LN10@dtor$1
	and	DWORD PTR $T1[rbp], -3
	mov	rcx, QWORD PTR __$ReturnUdt$GSCopy$[rbp]
	call	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN10@dtor$1:
	add	rsp, 32					; 00000020H
	pop	rbp
	ret	0
?dtor$1@?0???$_Convert_wide_to@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@V?$basic_string_view@_WU?$char_traits@_W@std@@@1@AEBV?$allocator@D@1@@Z@4HA ENDP ; `std::filesystem::_Convert_wide_to<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ??$append@V?$basic_string_view@DU?$char_traits@D@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??$append@V?$basic_string_view@DU?$char_traits@D@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append<std::basic_string_view<char,std::char_traits<char> >,void>, COMDAT

; 2592 :         const basic_string_view<_Elem, _Traits> _As_view = _Right;

	vmovups	xmm0, XMMWORD PTR [rdx]

; 2593 :         return append(_As_view.data(), _Convert_size<size_type>(_As_view.size()));

	vpextrq	r8, xmm0, 1
	vmovq	rdx, xmm0
	jmp	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
??$append@V?$basic_string_view@DU?$char_traits@D@std@@@std@@X@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV?$basic_string_view@DU?$char_traits@D@std@@@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append<std::basic_string_view<char,std::char_traits<char> >,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z
_TEXT	SEGMENT
$T13 = 32
__$ReturnUdt$ = 64
_Source$ = 72
_Tag$dead$ = 80
??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z PROC ; std::filesystem::_Convert_Source_to_wide<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::filesystem::_Normal_conversion>, COMDAT

; 272  :     _NODISCARD inline wstring _Convert_Source_to_wide(const _Src& _Source, _Conversion _Tag = {}) {

$LN34:
	push	rbx
	sub	rsp, 48					; 00000030H
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 272  :     _NODISCARD inline wstring _Convert_Source_to_wide(const _Src& _Source, _Conversion _Tag = {}) {

	mov	rbx, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 3264 :         return _Get_data()._Mysize;

	mov	rax, QWORD PTR [rdx+16]

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN20@Convert_So
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rdx, QWORD PTR [rdx]
$LN20@Convert_So:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 199  :             return _Convert_narrow_to_wide(__std_fs_code_page(), _Input);

	mov	QWORD PTR $T13[rsp], rdx
	mov	QWORD PTR $T13[rsp+8], rax
	call	__std_fs_code_page
	lea	r8, QWORD PTR $T13[rsp]
	mov	edx, eax
	mov	rcx, rbx
	call	?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z ; std::filesystem::_Convert_narrow_to_wide

; 273  :         return _Convert_stringoid_to_wide(_Stringoid_from_Source(_Source), _Tag);

	mov	rax, rbx

; 274  :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$_Convert_Source_to_wide@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@U_Normal_conversion@filesystem@2@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@U_Normal_conversion@01@@Z ENDP ; std::filesystem::_Convert_Source_to_wide<std::basic_string<char,std::char_traits<char>,std::allocator<char> >,std::filesystem::_Normal_conversion>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ??$_Stringoid_from_Source@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Source$ = 16
??$_Stringoid_from_Source@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::filesystem::_Stringoid_from_Source<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rdx+24], 16

; 3264 :         return _Get_data()._Mysize;

	mov	rax, QWORD PTR [rdx+16]

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN16@Stringoid_
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstddef

; 295  :     return _Ptr;

	mov	rdx, QWORD PTR [rdx]
$LN16@Stringoid_:
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 1141 :           _Mysize(_Count) { // construct basic_string_view around a character-type sequence with explicit size

	mov	QWORD PTR [rcx+8], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 233  :         return basic_string_view<_EcharT>(_Source.data(), _Source.size()); // erase mismatching _Traits

	mov	rax, rcx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 1140 :         : _Mydata(_Cts),

	mov	QWORD PTR [rcx], rdx
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem

; 234  :     }

	ret	0
??$_Stringoid_from_Source@DU?$char_traits@D@std@@V?$allocator@D@2@@filesystem@std@@YA?AV?$basic_string_view@DU?$char_traits@D@std@@@1@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::filesystem::_Stringoid_from_Source<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z PROC ; std::forward<std::allocator<char> const &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1298 : }

	ret	0
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ENDP ; std::forward<std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@V?$allocator@N@std@@@std@@YA$$QEAV?$allocator@N@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@N@std@@@std@@YA$$QEAV?$allocator@N@0@AEAV10@@Z PROC ; std::forward<std::allocator<double> >, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1298 : }

	ret	0
??$forward@V?$allocator@N@std@@@std@@YA$$QEAV?$allocator@N@0@AEAV10@@Z ENDP ; std::forward<std::allocator<double> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z PROC ; std::forward<std::allocator<wchar_t> >, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1298 : }

	ret	0
??$forward@V?$allocator@_W@std@@@std@@YA$$QEAV?$allocator@_W@0@AEAV10@@Z ENDP ; std::forward<std::allocator<wchar_t> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\type_traits
;	COMDAT ??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z PROC	; std::forward<wchar_t * const &>, COMDAT

; 1297 :     return static_cast<_Ty&&>(_Arg);

	mov	rax, rcx

; 1298 : }

	ret	0
??$forward@AEBQEA_W@std@@YAAEBQEA_WAEBQEA_W@Z ENDP	; std::forward<wchar_t * const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n@PEAD_KV?$allocator@D@std@@@std@@YAPEADPEAD_KAEAV?$allocator@D@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$dead$ = 56
_Al$dead$ = 64
??$_Uninitialized_value_construct_n@PEAD_KV?$allocator@D@std@@@std@@YAPEADPEAD_KAEAV?$allocator@D@0@@Z PROC ; std::_Uninitialized_value_construct_n<char *,unsigned __int64,std::allocator<char> >, COMDAT

; 337  :     _NoThrowFwdIt _First, _Diff _Count, _Alloc& _Al) { // value-initialize _Count objects to raw _First, using _Al

$LN8:
	push	rbx
	sub	rsp, 32					; 00000020H

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	r8d, 800				; 00000320H

; 337  :     _NoThrowFwdIt _First, _Diff _Count, _Alloc& _Al) { // value-initialize _Count objects to raw _First, using _Al

	mov	rbx, rcx

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	call	memset

; 332  :     return _Zero_range(_First, _First + _Count);

	lea	rax, QWORD PTR [rbx+800]

; 338  :     return _Uninitialized_value_construct_n1(_First, _Count, _Al,
; 339  :         bool_constant<conjunction_v<_Use_memset_value_construct_t<_NoThrowFwdIt>,
; 340  :             _Uses_default_construct<_Alloc, decltype(_Unfancy(_First))>>>{});
; 341  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninitialized_value_construct_n@PEAD_KV?$allocator@D@std@@@std@@YAPEADPEAD_KAEAV?$allocator@D@0@@Z ENDP ; std::_Uninitialized_value_construct_n<char *,unsigned __int64,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ??$_Uninitialized_move@PEANPEANV?$allocator@N@std@@@std@@YAPEANQEAN0PEANAEAV?$allocator@N@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
_Al$dead$ = 72
??$_Uninitialized_move@PEANPEANV?$allocator@N@std@@@std@@YAPEANQEAN0PEANAEAV?$allocator@N@0@@Z PROC ; std::_Uninitialized_move<double *,double *,std::allocator<double> >, COMDAT

; 221  :     _Alloc& _Al) { // move [_First, _Last) to raw _Dest, using _Al

$LN16:
	mov	QWORD PTR [rsp+32], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility

; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 1767 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rdi+rbx]
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory

; 241  : }

	mov	rbx, QWORD PTR [rsp+72]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Uninitialized_move@PEANPEANV?$allocator@N@std@@@std@@YAPEANQEAN0PEANAEAV?$allocator@N@0@@Z ENDP ; std::_Uninitialized_move<double *,double *,std::allocator<double> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Idl_distance@PEANPEAN@std@@YA_JAEBQEAN0@Z
_TEXT	SEGMENT
_First$ = 8
_Last$ = 16
??$_Idl_distance@PEANPEAN@std@@YA_JAEBQEAN0@Z PROC	; std::_Idl_distance<double *,double *>, COMDAT

; 487  :     if constexpr (_Is_random_iter_v<_Iter>) {
; 488  :         return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);

	mov	rax, QWORD PTR [rdx]
	sub	rax, QWORD PTR [rcx]
	sar	rax, 3

; 489  :     } else {
; 490  :         (void) _First; // TRANSITION, VSO#486357
; 491  :         (void) _Last; // TRANSITION, VSO#486357
; 492  :         return _Distance_unknown{};
; 493  :     }
; 494  : }

	ret	0
??$_Idl_distance@PEANPEAN@std@@YA_JAEBQEAN0@Z ENDP	; std::_Idl_distance<double *,double *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$_Get_size_of_n@$07@std@@YA_K_K@Z
_TEXT	SEGMENT
_Count$ = 8
??$_Get_size_of_n@$07@std@@YA_K_K@Z PROC		; std::_Get_size_of_n<8>, COMDAT

; 24   :     constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
; 25   :     size_t _Result                 = _Count * _Ty_size;
; 26   :     if (_Max_possible < _Count) { // multiply overflow, try allocating all of memory and assume the

	mov	rdx, 2305843009213693951		; 1fffffffffffffffH
	lea	rax, QWORD PTR [rcx*8]
	cmp	rcx, rdx
	mov	r8, -1
	cmova	rax, r8

; 27   :                                   // allocation function will throw bad_alloc
; 28   :         _Result = static_cast<size_t>(-1);
; 29   :     }
; 30   : 
; 31   :     return _Result;
; 32   : }

	ret	0
??$_Get_size_of_n@$07@std@@YA_K_K@Z ENDP		; std::_Get_size_of_n<8>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0
;	COMDAT ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>, COMDAT
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring

; 2002 :     _String_val() : _Bx(), _Mysize(0), _Myres(0) { // initialize values

	xor	eax, eax
	mov	QWORD PTR [rcx+16], rax
	mov	QWORD PTR [rcx+24], rax
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory0

; 1534 :     }

	mov	rax, rcx
	ret	0
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const &>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
classSize$dead$ = 16
?__autoclassinit2@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAAX_K@Z PROC ; std::basic_string_view<char,std::char_traits<char> >::__autoclassinit2, COMDAT
	vpxor	xmm0, xmm0, xmm0
	vmovups	XMMWORD PTR [rcx], xmm0
	ret	0
?__autoclassinit2@?$basic_string_view@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ENDP ; std::basic_string_view<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT

; 2032 :         return _BUF_SIZE <= _Myres;

	cmp	QWORD PTR [rcx+24], 16

; 2024 :         if (_Large_string_engaged()) {

	jb	SHORT $LN14@data

; 3250 :         return _Get_data()._Myptr();

	mov	rax, QWORD PTR [rcx]

; 3251 :     }

	ret	0
$LN14@data:

; 3250 :         return _Get_data()._Myptr();

	mov	rax, rcx

; 3251 :     }

	ret	0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\filesystem
;	COMDAT ??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z
_TEXT	SEGMENT
$T3 = 32
__$ReturnUdt$ = 64
_Input$ = 72
__formal$dead$ = 80
??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z PROC ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>, COMDAT

; 195  :     _NODISCARD inline wstring _Convert_stringoid_to_wide(const string_view _Input, _Conversion) {

$LN7:
	push	rbx
	sub	rsp, 48					; 00000030H

; 196  :         static_assert(_Is_any_of_v<_Conversion, _Normal_conversion, _Utf8_conversion>);
; 197  : 
; 198  :         if constexpr (is_same_v<_Conversion, _Normal_conversion>) {
; 199  :             return _Convert_narrow_to_wide(__std_fs_code_page(), _Input);

	vmovups	xmm0, XMMWORD PTR [rdx]
	vmovups	XMMWORD PTR $T3[rsp], xmm0
	mov	rbx, rcx
	call	__std_fs_code_page
	lea	r8, QWORD PTR $T3[rsp]
	mov	edx, eax
	mov	rcx, rbx
	call	?_Convert_narrow_to_wide@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@2@W4__std_code_page@@V?$basic_string_view@DU?$char_traits@D@std@@@2@@Z ; std::filesystem::_Convert_narrow_to_wide
	mov	rax, rbx

; 200  :         } else {
; 201  :             return _Convert_narrow_to_wide(__std_code_page::_Utf8, _Input);
; 202  :         }
; 203  :     }

	add	rsp, 48					; 00000030H
	pop	rbx
	ret	0
??$_Convert_stringoid_to_wide@U_Normal_conversion@filesystem@std@@@filesystem@std@@YA?AV?$basic_string@_WU?$char_traits@_W@std@@V?$allocator@_W@2@@1@V?$basic_string_view@DU?$char_traits@D@std@@@1@U_Normal_conversion@01@@Z ENDP ; std::filesystem::_Convert_stringoid_to_wide<std::filesystem::_Normal_conversion>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ??$_Uninitialized_value_construct_n1@PEAD_KV?$allocator@D@std@@@std@@YAPEADPEAD_KAEAV?$allocator@D@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
_First$ = 48
_Count$dead$ = 56
__formal$dead$ = 64
__formal$dead$ = 72
??$_Uninitialized_value_construct_n1@PEAD_KV?$allocator@D@std@@@std@@YAPEADPEAD_KAEAV?$allocator@D@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Uninitialized_value_construct_n1<char *,unsigned __int64,std::allocator<char> >, COMDAT

; 331  :     true_type) { // value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

$LN6:
	push	rbx
	sub	rsp, 32					; 00000020H

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	xor	edx, edx
	mov	r8d, 800				; 00000320H

; 331  :     true_type) { // value-initialize _Count objects to raw _First, using default _Alloc construct, all-bits-zero type

	mov	rbx, rcx

; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	call	memset

; 332  :     return _Zero_range(_First, _First + _Count);

	lea	rax, QWORD PTR [rbx+800]

; 333  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Uninitialized_value_construct_n1@PEAD_KV?$allocator@D@std@@@std@@YAPEADPEAD_KAEAV?$allocator@D@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Uninitialized_value_construct_n1<char *,unsigned __int64,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Get_unwrapped@N@std@@YAPEANQEAN@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Get_unwrapped@N@std@@YAPEANQEAN@Z PROC		; std::_Get_unwrapped<double>, COMDAT

; 275  :     return _Ptr;

	mov	rax, rcx

; 276  : }

	ret	0
??$_Get_unwrapped@N@std@@YAPEANQEAN@Z ENDP		; std::_Get_unwrapped<double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Get_unwrapped_n@N_J$0A@@std@@YAPEANQEAN_J@Z
_TEXT	SEGMENT
_Src$ = 8
__formal$dead$ = 16
??$_Get_unwrapped_n@N_J$0A@@std@@YAPEANQEAN_J@Z PROC	; std::_Get_unwrapped_n<double,__int64,0>, COMDAT

; 395  :     return _Src;

	mov	rax, rcx

; 396  : }

	ret	0
??$_Get_unwrapped_n@N_J$0A@@std@@YAPEANQEAN_J@Z ENDP	; std::_Get_unwrapped_n<double,__int64,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Copy_memmove@PEANPEAN@std@@YAPEANPEAN00@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
_Dest$ = 64
??$_Copy_memmove@PEANPEAN@std@@YAPEANPEAN00@Z PROC	; std::_Copy_memmove<double *,double *>, COMDAT

; 1761 : inline _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest) { // implement copy-like function as memmove

$LN4:
	mov	QWORD PTR [rsp+8], rbx
	push	rdi
	sub	rsp, 32					; 00000020H
	mov	rbx, rdx
	mov	rdi, r8

; 1762 :     const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
; 1763 :     const char* const _Last_ch  = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
; 1764 :     char* const _Dest_ch        = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
; 1765 :     const auto _Count           = static_cast<size_t>(_Last_ch - _First_ch);

	sub	rbx, rcx

; 1766 :     _CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	rdx, rcx
	mov	r8, rbx
	mov	rcx, rdi
	call	memmove

; 1767 :     return reinterpret_cast<_OutIt>(_Dest_ch + _Count);

	lea	rax, QWORD PTR [rbx+rdi]

; 1768 : }

	mov	rbx, QWORD PTR [rsp+48]
	add	rsp, 32					; 00000020H
	pop	rdi
	ret	0
??$_Copy_memmove@PEANPEAN@std@@YAPEANPEAN00@Z ENDP	; std::_Copy_memmove<double *,double *>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xutility
;	COMDAT ??$_Seek_wrapped@N@std@@YAXAEAPEANQEAN@Z
_TEXT	SEGMENT
_It$ = 8
_UIt$ = 16
??$_Seek_wrapped@N@std@@YAXAEAPEANQEAN@Z PROC		; std::_Seek_wrapped<double>, COMDAT

; 435  :     _It = _UIt;

	mov	QWORD PTR [rcx], rdx

; 436  : }

	ret	0
??$_Seek_wrapped@N@std@@YAXAEAPEANQEAN@Z ENDP		; std::_Seek_wrapped<double>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\VC\Tools\MSVC\14.20.27508\include\xmemory
;	COMDAT ??$_Zero_range@PEAD@std@@YAPEADQEAD0@Z
_TEXT	SEGMENT
_First$ = 48
_Last$ = 56
??$_Zero_range@PEAD@std@@YAPEADQEAD0@Z PROC		; std::_Zero_range<char *>, COMDAT

; 311  : inline _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes

$LN4:
	push	rbx
	sub	rsp, 32					; 00000020H

; 312  :     char* const _First_ch = reinterpret_cast<char*>(_First);
; 313  :     char* const _Last_ch  = reinterpret_cast<char*>(_Last);
; 314  :     _CSTD memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));

	mov	r8, rdx
	mov	rbx, rdx
	sub	r8, rcx
	xor	edx, edx
	call	memset

; 315  :     return _Last;

	mov	rax, rbx

; 316  : }

	add	rsp, 32					; 00000020H
	pop	rbx
	ret	0
??$_Zero_range@PEAD@std@@YAPEADQEAD0@Z ENDP		; std::_Zero_range<char *>
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
	movsxd	rax, DWORD PTR [rcx-4]
	sub	rcx, rax
	jmp	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
END
